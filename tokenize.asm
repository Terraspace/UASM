; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG5968	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
stokstr1 DW	028H
	DW	029H
	DW	02aH
	DW	02bH
	DW	02cH
	DW	02dH
	DW	02eH
	DW	02fH
stokstr2 DW	05bH
	DW	00H
	DW	05dH
CONST	ENDS
_DATA	SEGMENT
$SG5560	DB	'1to2', 00H
	ORG $+3
$SG5563	DB	'1to4', 00H
	ORG $+3
$SG5566	DB	'1to8', 00H
	ORG $+3
$SG5569	DB	'1to16', 00H
	ORG $+2
$SG5746	DB	'::', 00H
	ORG $+1
$SG5748	DB	':', 00H
	ORG $+2
$SG5751	DB	'OUT', 00H
$SG5753	DB	'%', 00H
	ORG $+2
$SG5771	DB	'=', 00H
	ORG $+6
$SG5774	DB	'=!<>&|', 0a6H, 00H
$SG5781	DB	'&', 00H
	ORG $+2
$SG5863	DB	'?', 00H
_DATA	ENDS
EXTRN	SymFind:NEAR
xdata	SEGMENT
$unwind$IsMultiLine DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$IsMultiLine DD @imagerel(IsMultiLine#)
	DD	@imagerel(IsMultiLine#+133)
	DD	@imagerel($unwind$IsMultiLine#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
pdata	ENDS
_TEXT	SEGMENT
tokenarray$ = 48
IsMultiLine PROC NEAR

; 98   : {

	sub	rsp, 40					; 00000028H

; 99   :     struct asym *sym;
; 100  :     int i;
; 101  : 
; 102  :     if ( tokenarray[1].token == T_DIRECTIVE && tokenarray[1].tokval == T_EQU )

	movzx	edx, BYTE PTR [rcx+32]
	cmp	dl, 3
	jne	SHORT $LN7@IsMultiLin
	cmp	DWORD PTR [rcx+48], 448			; 000001c0H

; 103  :         return( FALSE );

	je	SHORT $LN1@IsMultiLin
$LN7@IsMultiLin:

; 104  :     i = ( tokenarray[1].token == T_COLON ? 2 : 0 );

	xor	eax, eax
	cmp	dl, 58					; 0000003aH
	mov	r8d, 2
	cmove	eax, r8d

; 105  :     /* don't concat macros */
; 106  :     if ( tokenarray[i].token == T_ID ) {

	movsxd	rdx, eax
	shl	rdx, 5
	movzx	eax, BYTE PTR [rdx+rcx]
	cmp	al, 8
	jne	SHORT $LN6@IsMultiLin

; 107  :         sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rdx+rcx+8]
	call	SymFind

; 108  :         if ( sym && ( sym->state == SYM_MACRO )
; 109  : #if VARARGML
; 110  :             && sym->mac_multiline == FALSE  /* v2.11: added */
; 111  : #endif
; 112  :            )

	test	rax, rax
	je	SHORT $LN3@IsMultiLin
	cmp	DWORD PTR [rax+40], 9
	jne	SHORT $LN3@IsMultiLin
	test	BYTE PTR [rax+52], 8
	jne	SHORT $LN3@IsMultiLin
$LN1@IsMultiLin:

; 120  :         return( FALSE );

	xor	al, al

; 123  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@IsMultiLin:

; 113  :             return( FALSE );
; 114  :     } else if ( tokenarray[i].token == T_INSTRUCTION ||
; 115  :                ( tokenarray[i].token == T_DIRECTIVE &&
; 116  :                ( tokenarray[i].tokval == T_ECHO ||
; 117  :                 tokenarray[i].tokval == T_INCLUDE ||
; 118  :                 tokenarray[i].tokval == T_FORC ||
; 119  :                 tokenarray[i].tokval == T_IRPC ) ) ) {

	cmp	al, 1
	je	SHORT $LN1@IsMultiLin
	cmp	al, 3
	jne	SHORT $LN3@IsMultiLin
	mov	eax, DWORD PTR [rdx+rcx+16]
	cmp	eax, 446				; 000001beH
	je	SHORT $LN1@IsMultiLin
	cmp	eax, 402				; 00000192H
	je	SHORT $LN1@IsMultiLin
	cmp	eax, 391				; 00000187H
	je	SHORT $LN1@IsMultiLin
	cmp	eax, 393				; 00000189H
	je	SHORT $LN1@IsMultiLin
$LN3@IsMultiLin:

; 121  :     }
; 122  :     return( TRUE );

	mov	al, 1

; 123  : }

	add	rsp, 40					; 00000028H
	ret	0
IsMultiLine ENDP
_TEXT	ENDS
PUBLIC	get_broads
EXTRN	_memicmp:NEAR
EXTRN	EmitError:NEAR
xdata	SEGMENT
$unwind$get_broads DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$get_broads DD @imagerel($LN13#)
	DD	@imagerel($LN13#+224)
	DD	@imagerel($unwind$get_broads#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
p$ = 48
get_broads PROC NEAR

; 126  : void get_broads(struct line_status *p) {

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H

; 127  : 	/************************************************/
; 128  : 	if (!evex)

	cmp	BYTE PTR evex, 0
	mov	rbx, rcx
	jne	SHORT $LN10@get_broads

; 129  : 		EmitError(UNAUTHORISED_USE_OF_EVEX_ENCODING);

	mov	ecx, 278				; 00000116H
	call	EmitError
$LN10@get_broads:

; 130  : 
; 131  : 	if (_memicmp(p->input, "1to2", 4) == 0) {

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:$SG5560
	mov	r8d, 4
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN9@get_broads

; 132  : 		broadflags = 0x10;

	mov	BYTE PTR broadflags, 16

; 133  : 		p->input += 4;

	add	QWORD PTR [rbx], 4
	jmp	SHORT $LN2@get_broads
$LN9@get_broads:

; 134  : 	}
; 135  : 	else if (_memicmp(p->input, "1to4", 4) == 0){

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:$SG5563
	mov	r8d, 4
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN7@get_broads

; 136  :       broadflags = 0x20;

	mov	BYTE PTR broadflags, 32			; 00000020H

; 137  :       p->input += 4;

	add	QWORD PTR [rbx], 4
	jmp	SHORT $LN2@get_broads
$LN7@get_broads:

; 138  :     }
; 139  :     else if (_memicmp(p->input, "1to8", 4) == 0){

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:$SG5566
	mov	r8d, 4
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN5@get_broads

; 140  :       broadflags = 0x30;

	mov	BYTE PTR broadflags, 48			; 00000030H

; 141  :       p->input += 4;

	add	QWORD PTR [rbx], 4
	jmp	SHORT $LN2@get_broads
$LN5@get_broads:

; 142  :     }
; 143  :     else if (_memicmp(p->input, "1to16", 5) == 0){

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:$SG5569
	mov	r8d, 5
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN3@get_broads

; 144  :       broadflags = 0x40;

	mov	BYTE PTR broadflags, 64			; 00000040H

; 145  :       p->input += 5;

	add	QWORD PTR [rbx], 5

; 146  :     }
; 147  :     else

	jmp	SHORT $LN2@get_broads
$LN3@get_broads:

; 148  :       EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN2@get_broads:

; 149  :     if (*p->input++ != '}')

	mov	rax, QWORD PTR [rbx]
	inc	rax
	movzx	ecx, BYTE PTR [rax-1]
	mov	QWORD PTR [rbx], rax
	cmp	cl, 125					; 0000007dH
	je	SHORT $LN1@get_broads

; 150  :       EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15
	call	EmitError
$LN1@get_broads:

; 151  : 
; 152  :   }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
get_broads ENDP
_TEXT	ENDS
PUBLIC	get_decos
EXTRN	isspace:NEAR
xdata	SEGMENT
$unwind$get_decos DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$get_decos DD @imagerel($LN35#)
	DD	@imagerel($LN35#+375)
	DD	@imagerel($unwind$get_decos#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
p$ = 48
get_decos PROC NEAR

; 155  : void get_decos(struct line_status *p) {

$LN35:
	push	rbx
	sub	rsp, 32					; 00000020H

; 156  : 			/************************************************/
; 157  : 			unsigned char c;
; 158  : 			if (!evex)

	cmp	BYTE PTR evex, 0
	mov	rbx, rcx
	jne	SHORT $LN23@get_decos

; 159  : 				EmitError(UNAUTHORISED_USE_OF_EVEX_ENCODING);

	mov	ecx, 278				; 00000116H
	call	EmitError
$LN23@get_decos:

; 160  : 			c = (*p->input | 0x20);

	mov	rax, QWORD PTR [rbx]
	movzx	ecx, BYTE PTR [rax]
	or	cl, 32					; 00000020H

; 161  : 			p->input++;

	inc	rax

; 162  : 			/* if first decorator is the z  */
; 163  : 			if (c == 'z'){

	cmp	cl, 122					; 0000007aH
	mov	QWORD PTR [rbx], rax
	jne	$LN22@get_decos

; 164  :             decoflags |= 0x80; 

	or	BYTE PTR decoflags, 128			; 00000080H

; 165  :             p->input++;

	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]

; 166  :             c = *p->input;
; 167  :             if (c != '}'){

	cmp	BYTE PTR [rax], 125			; 0000007dH

; 168  :               EmitError(DECORATOR_OR_BRACE_EXPECTED);
; 169  :               return;

	jne	$LN32@get_decos

; 170  :             }
; 171  :             p->input++;

	inc	rax
	mov	QWORD PTR [rbx], rax

; 172  :             while ( isspace( *p->input )) p->input++;

	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN19@get_decos
	npad	4
$LL20@get_decos:
	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL20@get_decos
$LN19@get_decos:

; 173  :             c = *p->input;

	mov	rax, QWORD PTR [rbx]

; 174  :             if (c != '{'){

	cmp	BYTE PTR [rax], 123			; 0000007bH
	je	SHORT $LN18@get_decos

; 175  :               EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14

; 239  :           return;
; 240  :         }
; 241  :       }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitError
$LN18@get_decos:

; 176  :               return;
; 177  :             }
; 178  :             p->input++;

	lea	rcx, QWORD PTR [rax+1]
	mov	QWORD PTR [rbx], rcx

; 179  :             c = (*p->input | 0x20);

	movzx	eax, BYTE PTR [rcx]
	or	al, 32					; 00000020H

; 180  :             if (c != 'k'){

	cmp	al, 107					; 0000006bH

; 181  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);
; 182  :                 return;

	jne	$LN32@get_decos

; 183  :             }else{
; 184  :               p->input++;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rax

; 185  :               c = *p->input;

	movzx	ecx, BYTE PTR [rax]

; 186  :               if (c > '7' || c < '1'){

	lea	eax, DWORD PTR [rcx-49]
	cmp	al, 6
	ja	$LN9@get_decos

; 187  :                 EmitError(WRONG_MASK_REGISTER_NUBER);
; 188  :                 return;
; 189  :               }
; 190  :               decoflags |= (c & 0x7);

	and	cl, 7
	or	BYTE PTR decoflags, cl

; 191  :               p->input++;
; 192  :               c = *p->input;
; 193  :               if (c != '}'){
; 194  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);
; 195  :                 return;

	jmp	SHORT $LN34@get_decos
$LN22@get_decos:

; 196  :               }
; 197  :               p->input++;
; 198  :             }
; 199  :           }
; 200  :           /* if first decorator is the mask register */
; 201  :           else if (c == 'k'){

	cmp	cl, 107					; 0000006bH
	jne	$LN11@get_decos

; 202  :           c = *p->input;

	movzx	ecx, BYTE PTR [rax]

; 203  :           if (c > '7' || c < '1'){

	lea	eax, DWORD PTR [rcx-49]
	cmp	al, 6
	ja	$LN9@get_decos

; 205  :             return;
; 206  :           }
; 207  :           decoflags |= (c & 0x7);

	and	cl, 7
	or	BYTE PTR decoflags, cl

; 208  :           p->input++;

	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]

; 209  :           c = *p->input;
; 210  :           if (c != '}'){

	cmp	BYTE PTR [rax], 125			; 0000007dH

; 211  :             EmitError(DECORATOR_OR_BRACE_EXPECTED);
; 212  :             return;

	jne	SHORT $LN32@get_decos

; 213  :           }
; 214  :           p->input++;

	inc	rax
	mov	QWORD PTR [rbx], rax

; 215  :           /* check if there is more decorators */
; 216  :           while ( isspace( *p->input )) p->input++;

	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN6@get_decos
	npad	6
$LL7@get_decos:
	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL7@get_decos
$LN6@get_decos:

; 217  :           c = *p->input;

	mov	rax, QWORD PTR [rbx]

; 218  :           if (c == '{'){

	cmp	BYTE PTR [rax], 123			; 0000007bH
	jne	SHORT $LN1@get_decos

; 219  :             p->input++;

	inc	rax
	mov	QWORD PTR [rbx], rax

; 220  :             c = (*p->input | 0x20);

	movzx	ecx, BYTE PTR [rax]
	or	cl, 32					; 00000020H

; 221  :             if (c == 'z'){

	cmp	cl, 122					; 0000007aH
	jne	SHORT $LN11@get_decos

; 222  :               decoflags |= 0x80;

	or	BYTE PTR decoflags, 128			; 00000080H
$LN34@get_decos:

; 223  :               p->input++;

	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]

; 224  :               c = *p->input;
; 225  :               if (c != '}'){

	cmp	BYTE PTR [rax], 125			; 0000007dH
	je	SHORT $LN3@get_decos
$LN32@get_decos:

; 226  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15

; 239  :           return;
; 240  :         }
; 241  :       }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitError
$LN3@get_decos:

; 227  :                 return;
; 228  :               }
; 229  :               p->input++;

	inc	rax
	mov	QWORD PTR [rbx], rax

; 239  :           return;
; 240  :         }
; 241  :       }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN9@get_decos:

; 204  :             EmitError(WRONG_MASK_REGISTER_NUBER);

	mov	ecx, 16

; 239  :           return;
; 240  :         }
; 241  :       }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitError
$LN11@get_decos:

; 230  :             }
; 231  :             else {
; 232  :               EmitError(TO_MANY_DECORATORS);
; 233  :               return;
; 234  :             }
; 235  :           }
; 236  :         }
; 237  :         else {
; 238  :           EmitError(TO_MANY_DECORATORS);

	mov	ecx, 17
	call	EmitError
$LN1@get_decos:

; 239  :           return;
; 240  :         }
; 241  :       }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
get_decos ENDP
_TEXT	ENDS
EXTRN	isdigit:NEAR
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$get_float DD 0d2d01H
	DD	04e42dH
	DD	05d41eH
	DD	06c41aH
	DD	0a6413H
	DD	09540fH
	DD	08340bH
	DD	06207H
xdata	ENDS
pdata	SEGMENT
$pdata$get_float DD @imagerel(get_float#)
	DD	@imagerel(get_float#+53)
	DD	@imagerel($unwind$get_float#)
pdata	ENDS
xdata	SEGMENT
$chain$6$get_float DD 020421H
	DD	0b7404H
	DD	@imagerel(get_float#)
	DD	@imagerel(get_float#+53)
	DD	@imagerel($unwind$get_float#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$get_float DD @imagerel(get_float#+53)
	DD	@imagerel(get_float#+149)
	DD	@imagerel($chain$6$get_float#)
pdata	ENDS
xdata	SEGMENT
$chain$7$get_float DD 021H
	DD	@imagerel(get_float#)
	DD	@imagerel(get_float#+53)
	DD	@imagerel($unwind$get_float#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$get_float DD @imagerel(get_float#+149)
	DD	@imagerel(get_float#+240)
	DD	@imagerel($chain$7$get_float#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buf$ = 64
p$ = 72
get_float PROC NEAR

; 245  : {

	mov	rax, rsp
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi

; 246  :     /* valid floats look like:  (int)[.(int)][e(int)]
; 247  :      * Masm also allows hex format, terminated by 'r' (3F800000r)
; 248  :      */
; 249  : 
; 250  :     char    got_decimal = FALSE;
; 251  :     char    got_e = FALSE;
; 252  :     char    *ptr = p->input;

	mov	rsi, QWORD PTR [rdx]
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-16], r13

; 253  : 
; 254  :     for( ; *ptr != NULLC; ptr++ ) {

	movzx	ebx, BYTE PTR [rsi]
	xor	bpl, bpl
	xor	r12b, r12b
	test	bl, bl
	mov	QWORD PTR [rax-24], r14
	mov	r13, rdx
	mov	r14, rcx
	je	SHORT $LN18@get_float
	mov	QWORD PTR [rax+32], rdi
	npad	7
$LL11@get_float:

; 255  :         char c = *ptr;
; 256  :         if( isdigit( c ) ) {

	movsx	edi, bl
	mov	ecx, edi
	call	isdigit
	test	eax, eax
	jne	SHORT $LN10@get_float

; 257  :             ;
; 258  :         } else if ( c == '.' && got_decimal == FALSE ) {

	cmp	bl, 46					; 0000002eH
	jne	SHORT $LN6@get_float
	test	bpl, bpl
	jne	SHORT $LN14@get_float

; 259  :             got_decimal = TRUE;

	mov	bpl, 1
	jmp	SHORT $LN10@get_float
$LN6@get_float:

; 260  :         } else if ( tolower( c ) == 'e' && got_e == FALSE ) {

	sub	bl, 65					; 00000041H
	cmp	bl, 25
	ja	SHORT $LN14@get_float
	or	edi, 32					; 00000020H
$LN14@get_float:
	cmp	edi, 101				; 00000065H
	jne	SHORT $LN19@get_float
	test	r12b, r12b
	jne	SHORT $LN19@get_float

; 261  :             got_e = TRUE;
; 262  :             /* accept e+2 / e-4 /etc. */
; 263  :             if ( *(ptr+1) == '+' || *(ptr+1) == '-' )

	movzx	ecx, BYTE PTR [rsi+1]
	mov	r12b, 1
	cmp	cl, 43					; 0000002bH
	je	SHORT $LN2@get_float
	cmp	cl, 45					; 0000002dH
	jne	SHORT $LN10@get_float
$LN2@get_float:

; 264  :                 ptr++;

	inc	rsi
$LN10@get_float:

; 253  : 
; 254  :     for( ; *ptr != NULLC; ptr++ ) {

	mov	bl, BYTE PTR [rsi+1]
	inc	rsi
	test	bl, bl
	jne	SHORT $LL11@get_float
$LN19@get_float:
	mov	rdi, QWORD PTR [rsp+88]
$LN18@get_float:

; 265  :             /* it's accepted if there's no digit behind 'e' */
; 266  :             //if ( !isdigit( *(ptr+1) ) )
; 267  :             //    break;
; 268  :         } else
; 269  :             break;
; 270  :     }
; 271  : 
; 272  :     buf->token = T_FLOAT;

	mov	BYTE PTR [r14], 11

; 273  :     buf->floattype = NULLC;

	mov	BYTE PTR [r14+1], 0

; 274  :     memcpy( p->output, p->input, ptr - p->input );

	mov	rdx, QWORD PTR [r13]
	mov	rcx, QWORD PTR [r13+8]
	mov	r8, rsi
	sub	r8, rdx
	call	memcpy
	mov	r14, QWORD PTR [rsp+32]
	mov	r12, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 275  :     p->output += ( ptr - p->input );

	mov	r11, rsi
	sub	r11, QWORD PTR [r13]
	add	QWORD PTR [r13+8], r11
	mov	rax, QWORD PTR [r13+8]

; 276  :     *p->output++ = NULLC;

	mov	BYTE PTR [rax], 0
	inc	QWORD PTR [r13+8]

; 277  :     p->input = ptr;

	mov	QWORD PTR [r13], rsi
	mov	r13, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+80]

; 278  : 
; 279  :     /* the binary value isn't used currently */
; 280  :     //*((float *)(&buf->value)) = atof( buf->string_ptr );
; 281  : 
; 282  :     return( NOT_ERROR );

	xor	eax, eax

; 283  : }

	add	rsp, 56					; 00000038H
	ret	0
get_float ENDP
_TEXT	ENDS
EXTRN	GetTextLine:NEAR
xdata	SEGMENT
$unwind$ConcatLine DD 0d2d01H
	DD	05d42dH
	DD	06c428H
	DD	0b7418H
	DD	0a6413H
	DD	09540eH
	DD	083409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$ConcatLine DD @imagerel(ConcatLine#)
	DD	@imagerel(ConcatLine#+282)
	DD	@imagerel($unwind$ConcatLine#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
src$ = 64
cnt$ = 72
out$ = 80
ls$ = 88
ConcatLine PROC NEAR

; 287  : {

	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi
	mov	rsi, rcx

; 288  :     char *p = src+1;

	lea	rdi, QWORD PTR [rcx+1]

; 289  :     int max;
; 290  : 
; 291  :     while ( isspace(*p) ) p++;

	movsx	ecx, BYTE PTR [rcx+1]
	mov	QWORD PTR [rsp+48], r12
	mov	QWORD PTR [rsp+40], r13
	mov	rbp, r9
	mov	rbx, r8
	mov	r13d, edx
	call	isspace
	test	eax, eax
	je	SHORT $LN8@ConcatLine
	npad	1
$LL9@ConcatLine:
	movsx	ecx, BYTE PTR [rdi+1]
	inc	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL9@ConcatLine
$LN8@ConcatLine:

; 292  :     if ( *p == NULLC || *p == ';' ) {

	movzx	eax, BYTE PTR [rdi]
	test	al, al
	je	SHORT $LN6@ConcatLine
	cmp	al, 59					; 0000003bH
	jne	$LN5@ConcatLine
$LN6@ConcatLine:

; 293  :         //char *buffer = GetAlignedPointer( out, strlen( out ) );
; 294  :         char *buffer = out;
; 295  :         if( GetTextLine( buffer ) ) {

	mov	rcx, rbx
	call	GetTextLine
	test	rax, rax
	je	$LN5@ConcatLine

; 296  :             p = buffer;
; 297  :             /* skip leading spaces */
; 298  :             while ( isspace( *p ) ) p++;

	movsx	ecx, BYTE PTR [rbx]
	call	isspace
	test	eax, eax
	je	SHORT $LN3@ConcatLine
	npad	4
$LL4@ConcatLine:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL4@ConcatLine
$LN3@ConcatLine:

; 299  :             max = strlen( p );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	dec	rcx

; 300  :             if ( cnt == 0 )

	test	r13d, r13d
	jne	SHORT $LN2@ConcatLine

; 301  :                 *src++ = ' ';

	mov	BYTE PTR [rsi], 32			; 00000020H
	inc	rsi
$LN2@ConcatLine:

; 302  :             if ( ( src - ls->start ) + max >= MAX_LINE_LEN ) {

	movsxd	rax, ecx
	sub	rax, QWORD PTR [rbp+16]
	add	rax, rsi
	cmp	rax, 1024				; 00000400H
	jl	SHORT $LN1@ConcatLine

; 303  :                 EmitError( LINE_TOO_LONG );

	mov	ecx, 61					; 0000003dH
	call	EmitError

; 304  :                 max = MAX_LINE_LEN - ( src - ls->start + 1 );

	mov	ecx, DWORD PTR [rbp+16]
	sub	ecx, esi
	add	ecx, 1023				; 000003ffH

; 305  :                 *(p+max) = NULLC;

	movsxd	rax, ecx
	mov	BYTE PTR [rax+rbx], 0
$LN1@ConcatLine:

; 306  :             }
; 307  :             memcpy( src, p, max+1 );

	lea	eax, DWORD PTR [rcx+1]
	mov	rdx, rbx
	mov	rcx, rsi
	movsxd	r8, eax
	call	memcpy

; 308  :             return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN10@ConcatLine
$LN5@ConcatLine:

; 309  :         }
; 310  :     }
; 311  :     return( EMPTY );

	mov	eax, -2
$LN10@ConcatLine:
	mov	r13, QWORD PTR [rsp+40]
	mov	r12, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 312  : }

	add	rsp, 56					; 00000038H
	ret	0
ConcatLine ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$get_string DD 0113a01H
	DD	05f43aH
	DD	06e42fH
	DD	07d42bH
	DD	08c427H
	DD	097423H
	DD	0a641bH
	DD	0f5417H
	DD	0e3410H
	DD	0a20cH
xdata	ENDS
pdata	SEGMENT
$pdata$get_string DD @imagerel(get_string#)
	DD	@imagerel(get_string#+1217)
	DD	@imagerel($unwind$get_string#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buf$ = 96
tv642 = 104
p$ = 104
get_string PROC NEAR

; 316  : {

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, rsp
	sub	rsp, 88					; 00000058H
	mov	QWORD PTR [rax+24], rbx

; 317  :     char    symbol_o;
; 318  :     char    symbol_c;
; 319  :     char    c;
; 320  :     char    *src = p->input;

	mov	rbx, QWORD PTR [rdx]
	mov	QWORD PTR [rax+32], rbp
	mov	QWORD PTR [rax-8], rsi

; 321  :     char    *dst = p->output;

	mov	rsi, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax-16], rdi
	mov	QWORD PTR [rax-24], r12
	mov	QWORD PTR [rax-32], r13
	mov	QWORD PTR [rax-40], r14

; 322  :     int     count = 0;
; 323  :     int     level;
; 324  : 
; 325  :     symbol_o = *src;

	movzx	r14d, BYTE PTR [rbx]
	xor	r12d, r12d
	mov	QWORD PTR [rax-48], r15

; 326  : 
; 327  :     switch( symbol_o ) {

	cmp	r14b, 34				; 00000022H
	mov	r13, rdx
	je	$LN53@get_string
	cmp	r14b, 39				; 00000027H
	je	$LN53@get_string
	cmp	r14b, 60				; 0000003cH
	je	SHORT $LN43@get_string
	cmp	r14b, 123				; 0000007bH
	jne	$undelimited_string$5675

; 349  :             }
; 350  :         }
; 351  :         break;  /* end of string marker is the same */
; 352  :     case '{':
; 353  :         if ( p->flags & TOK_NOCURLBRACES )

	test	BYTE PTR [rdx+28], 2
	jne	$undelimited_string$5675
$LN43@get_string:

; 354  :             goto undelimited_string;
; 355  :     case '<':
; 356  :         buf->string_delim = symbol_o;
; 357  :         symbol_c = ( symbol_o == '<' ? '>' : '}' );

	cmp	r14b, 60				; 0000003cH
	mov	BYTE PTR [rcx+1], r14b
	mov	eax, 125				; 0000007dH
	mov	ecx, 62					; 0000003eH

; 358  :         src++;
; 359  :         for( level = 0; count < MAX_STRING_LEN; ) {

	mov	r15d, r12d
	cmove	eax, ecx
	inc	rbx
	mov	DWORD PTR tv642[rsp], eax
	npad	6
$LL41@get_string:

; 360  :             c = *src;

	movzx	edi, BYTE PTR [rbx]

; 361  :             if( c == symbol_o ) { /* < or { ? */

	cmp	dil, r14b
	jne	SHORT $LN39@get_string

; 362  :                 level++;
; 363  :                 *dst++ = c; src++;

	mov	BYTE PTR [rsi], dil
	inc	rsi
	inc	r15d
	inc	rbx

; 364  :                 count++;

	inc	r12d
	jmp	$LN76@get_string
$LN39@get_string:

; 365  :             } else if( c == symbol_c ) { /* > or }? */

	cmp	dil, al
	jne	SHORT $LN37@get_string

; 366  :                 if( level ) {

	test	r15d, r15d
	je	$LN36@get_string

; 367  :                     level--;
; 368  :                     *dst++ = c; src++;

	mov	BYTE PTR [rsi], dil
	inc	rsi
	dec	r15d
	inc	rbx

; 369  :                     count++;

	inc	r12d

; 377  :                 }

	jmp	$LN76@get_string
$LN37@get_string:

; 378  : #if 1
; 379  :             /*
; 380  :              a " or ' inside a <>/{} string? Since it's not a must that
; 381  :              [double-]quotes are paired in a literal it must be done
; 382  :              directive-dependant!
; 383  :              see: IFIDN <">,<">
; 384  :              */
; 385  :             } else if( ( c == '"' || c == '\'' ) && ( p->flags2 & DF_STRPARM ) == 0 ) {

	cmp	dil, 34					; 00000022H
	je	SHORT $LN32@get_string
	cmp	dil, 39					; 00000027H
	jne	$LN33@get_string
$LN32@get_string:
	test	BYTE PTR [r13+29], 2
	jne	$LN33@get_string

; 386  :                 char delim = c;
; 387  :                 char *tdst;
; 388  :                 char *tsrc;
; 389  :                 int tcount;
; 390  :                 *dst++ = c; src++;

	inc	rbx
	mov	BYTE PTR [rsi], dil
	inc	rsi

; 391  :                 count++;
; 392  :                 tdst = dst;
; 393  :                 tsrc = src;
; 394  :                 tcount = count;
; 395  :                 while (*src != delim && *src != NULLC && count < MAX_STRING_LEN-1 ) {

	movzx	eax, BYTE PTR [rbx]
	inc	r12d
	mov	rcx, rsi
	cmp	al, dil
	mov	rdx, rbx
	mov	r8d, r12d
	je	SHORT $LN80@get_string
$LL31@get_string:
	test	al, al
	je	SHORT $LN30@get_string
	cmp	r12d, 991				; 000003dfH
	jge	SHORT $LN30@get_string

; 396  :                     if ( symbol_o == '<' && *src == '!' && *(src+1) != NULLC )

	cmp	r14b, 60				; 0000003cH
	jne	SHORT $LN29@get_string
	cmp	al, 33					; 00000021H
	jne	SHORT $LN29@get_string
	cmp	BYTE PTR [rbx+1], 0
	lea	rax, QWORD PTR [rbx+1]
	cmovne	rbx, rax
$LN29@get_string:

; 397  :                         src++;
; 398  :                     *dst++ = *src++;

	movzx	eax, BYTE PTR [rbx]
	inc	rbx
	inc	rsi
	mov	BYTE PTR [rsi-1], al
	mov	al, BYTE PTR [rbx]

; 399  :                     count++;

	inc	r12d
	cmp	al, dil
	jne	SHORT $LL31@get_string

; 402  :                     *dst++ = *src++;

	mov	BYTE PTR [rsi], al
	inc	rsi
	inc	rbx

; 403  :                     count++;

	inc	r12d

; 404  :                     continue;

	jmp	$LN76@get_string
$LN30@get_string:

; 400  :                 }
; 401  :                 if ( *src == delim ) {

	cmp	BYTE PTR [rbx], dil
	jne	SHORT $LN28@get_string
$LN80@get_string:

; 402  :                     *dst++ = *src++;

	movzx	eax, BYTE PTR [rbx]
	inc	rsi
	inc	rbx
	mov	BYTE PTR [rsi-1], al

; 403  :                     count++;

	inc	r12d

; 404  :                     continue;

	jmp	$LN76@get_string
$LN28@get_string:

; 405  :                 } else {
; 406  :                     /* restore values */
; 407  :                     src = tsrc;

	mov	rbx, rdx

; 408  :                     dst = tdst;

	mov	rsi, rcx

; 409  :                     count = tcount;

	mov	r12d, r8d

; 410  :                 }

	jmp	$LN76@get_string
$LN33@get_string:

; 411  : #endif
; 412  :             } else if( c == '!' && symbol_o == '<' && *(src+1) ) {

	cmp	dil, 33					; 00000021H
	jne	SHORT $LN25@get_string
	cmp	r14b, 60				; 0000003cH
	jne	SHORT $LN21@get_string
	cmp	BYTE PTR [rbx+1], 0
	lea	rax, QWORD PTR [rbx+1]
	je	SHORT $LN21@get_string

; 413  :                 /* handle literal-character operator '!'.
; 414  :                  * it makes the next char to enter the literal uninterpreted.
; 415  :                  */
; 416  :                 /* v2.09: don't store the '!' */
; 417  :                 //*dst++ = c; src++;
; 418  :                 //count++;
; 419  :                 //if ( count == MAX_STRING_LEN )
; 420  :                 //    break;
; 421  :                 src++;
; 422  :                 *dst++ = *src++;

	lea	rbx, QWORD PTR [rax+1]
	movzx	eax, BYTE PTR [rax]
	inc	rsi
	mov	BYTE PTR [rsi-1], al

; 423  :                 count++;

	inc	r12d
	jmp	$LN76@get_string
$LN25@get_string:

; 424  :             } else if( c == '\\' &&  ConcatLine( src, count, dst, p ) != EMPTY ) {

	cmp	dil, 92					; 0000005cH
	jne	SHORT $LN23@get_string
	mov	r9, r13
	mov	r8, rsi
	mov	edx, r12d
	mov	rcx, rbx
	call	ConcatLine
	cmp	eax, -2
	je	SHORT $LN21@get_string

; 425  :                 p->flags3 |= TF3_ISCONCAT;

	or	BYTE PTR [r13+30], 1
	jmp	$LN76@get_string
$LN23@get_string:

; 426  :             } else if( c == NULLC || ( c == ';' && symbol_o == '{' )) {

	test	dil, dil
	je	SHORT $LN20@get_string
	cmp	dil, 59					; 0000003bH
	jne	SHORT $LN21@get_string
	cmp	r14b, 123				; 0000007bH
	je	SHORT $LN20@get_string
$LN21@get_string:

; 453  :                 goto undelimited_string;
; 454  :             } else {
; 455  :                 *dst++ = c; src++;

	mov	BYTE PTR [rsi], dil
	inc	rsi
	inc	rbx

; 456  :                 count++;

	inc	r12d

; 457  :             }
; 458  :         }

	jmp	$LN76@get_string
$LN20@get_string:

; 427  :                 if ( p->flags == TOK_DEFAULT && (( p->flags2 & DF_NOCONCAT ) == 0 ) ) { /* <{ */

	cmp	BYTE PTR [r13+28], 0
	jne	$LN15@get_string
	test	BYTE PTR [r13+29], 32			; 00000020H
	jne	$LN15@get_string

; 428  :                     /* if last nonspace character was a comma
; 429  :                      * get next line and continue string scan
; 430  :                      */
; 431  :                     char *tmp = dst-1;
; 432  :                     while ( isspace(*tmp) ) tmp--;

	movsx	ecx, BYTE PTR [rsi-1]
	lea	rdi, QWORD PTR [rsi-1]
	call	isspace
	test	eax, eax
	je	SHORT $LN17@get_string
$LL18@get_string:
	movsx	ecx, BYTE PTR [rdi-1]
	dec	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL18@get_string
$LN17@get_string:

; 433  :                     if ( *tmp == ',' ) {

	cmp	BYTE PTR [rdi], 44			; 0000002cH
	jne	$LN15@get_string

; 434  :                         DebugMsg1(("Tokenize.get_string: comma concatenation: %s\n", src ));
; 435  :                         tmp = GetAlignedPointer( p->output, strlen( p->output ) );

	mov	rdx, QWORD PTR [r13+8]
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rdx
	repne scasb
	not	rcx
	lea	rbp, QWORD PTR [rcx+7]
	and	rbp, -8
	add	rbp, rdx

; 436  :                         if( GetTextLine( tmp ) ) {

	mov	rcx, rbp
	call	GetTextLine
	test	rax, rax
	je	$LN15@get_string

; 437  :                             /* skip leading spaces */
; 438  :                             while ( isspace( *tmp ) ) tmp++;

	movsx	ecx, BYTE PTR [rbp]
	call	isspace
	test	eax, eax
	je	SHORT $LN13@get_string
	npad	9
$LL14@get_string:
	movsx	ecx, BYTE PTR [rbp+1]
	inc	rbp
	call	isspace
	test	eax, eax
	jne	SHORT $LL14@get_string
$LN13@get_string:

; 439  :                             /* this size check isn't fool-proved yet */
; 440  :                             if ( strlen( tmp ) + count >= MAX_LINE_LEN ) {

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbp
	repne scasb
	movsxd	rax, r12d
	not	rcx
	dec	rcx
	add	rcx, rax
	cmp	rcx, 1024				; 00000400H
	jae	SHORT $LN69@get_string

; 443  :                             }
; 444  :                             strcpy( src, tmp );

	mov	rcx, rbx
	sub	rcx, rbp
	npad	7
$LL58@get_string:
	movzx	eax, BYTE PTR [rbp]
	inc	rbp
	test	al, al
	mov	BYTE PTR [rcx+rbp-1], al
	jne	SHORT $LL58@get_string
$LN76@get_string:

; 358  :         src++;
; 359  :         for( level = 0; count < MAX_STRING_LEN; ) {

	cmp	r12d, 992				; 000003e0H
	mov	eax, DWORD PTR tv642[rsp]
	jl	$LL41@get_string

; 339  :                     break; /* exit loop */
; 340  :                 /* a pair of quotes inside the string is
; 341  :                  * handled as a single quote */
; 342  :             } else if( c == NULLC ) {

	mov	rcx, QWORD PTR buf$[rsp]
	jmp	$LN50@get_string
$LN36@get_string:

; 370  :                 } else {
; 371  :                     /* store the string delimiter unless it is <> */
; 372  :                     /* v2.08: don't store delimiters for {}-literals */
; 373  :                     //if (symbol_o != '<')
; 374  :                     //    *dst++ = c;
; 375  :                     src++;
; 376  :                     break; /* exit loop */

	mov	rcx, QWORD PTR buf$[rsp]
	inc	rbx
	jmp	$LN50@get_string
$LN69@get_string:

; 441  :                                 EmitError( LINE_TOO_LONG );

	mov	ecx, 61					; 0000003dH
	call	EmitError

; 442  :                                 return( ERROR );

	mov	eax, -1
	jmp	$LN56@get_string
$LN15@get_string:

; 445  :                             continue;
; 446  :                         }
; 447  :                     }
; 448  :                 }
; 449  :                 src = p->input;

	mov	rbx, QWORD PTR [r13]

; 450  :                 dst = p->output;

	mov	rsi, QWORD PTR [r13+8]
	mov	rcx, QWORD PTR buf$[rsp]

; 451  :                 *dst++ = *src++;

	movzx	eax, BYTE PTR [rbx]
	inc	rsi

; 452  :                 count = 1;

	mov	r12d, 1
	mov	BYTE PTR [rsi-1], al
	inc	rbx
$undelimited_string$5675:

; 459  :         break;
; 460  :     default:
; 461  :         undelimited_string:
; 462  :         buf->string_delim = NULLC;
; 463  :         /* this is an undelimited string,
; 464  :          * so just copy it until we hit something that looks like the end.
; 465  :          * this format is used by the INCLUDE directive, but may also
; 466  :          * occur inside the string macros!
; 467  :          */
; 468  :         /* v2.05: also stop if a ')' is found - see literal2.asm regression test */
; 469  :         //for( count = 0 ; count < MAX_STRING_LEN && *src != NULLC && !isspace( *src ) && *src != ',' && *src != ';'; ) {
; 470  :         for( ; count < MAX_STRING_LEN &&
; 471  :             /* v2.08: stop also at < and % */
; 472  :             //*src != NULLC && !isspace( *src ) && *src != ',' && *src != ';' && *src != ')'; ) {
; 473  :             //*src && !isspace( *src ) && *src != ',' && *src != ')' && *src != '<' && *src != '%'; ) {
; 474  :             *src && !isspace( *src ) && *src != ',' && *src != ')' && *src != '%'; ) {

	cmp	r12d, 992				; 000003e0H
	mov	BYTE PTR [rcx+1], 0
	jge	$LN50@get_string
	npad	5
$LL9@get_string:
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	$LN81@get_string
	movsx	ecx, al
	call	isspace
	test	eax, eax
	jne	$LN82@get_string
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 44					; 0000002cH
	je	$LN83@get_string
	cmp	al, 41					; 00000029H
	je	$LN84@get_string
	cmp	al, 37					; 00000025H
	je	$LN85@get_string

; 475  :             if ( *src == ';' && p->flags == TOK_DEFAULT )

	cmp	al, 59					; 0000003bH
	jne	SHORT $LN7@get_string
	cmp	BYTE PTR [r13+28], 0
	je	$LN86@get_string
$LN7@get_string:

; 476  :                 break;
; 477  :             /* v2.11: handle '\' also for expanded lines */
; 478  :             //if (  *src == '\\' && !( p->flags & TOK_NOCURLBRACES ) ) {
; 479  :             if (  *src == '\\' && ( p->flags == TOK_DEFAULT || ( p->flags & TOK_LINE ) ) ) {

	cmp	al, 92					; 0000005cH
	jne	SHORT $LN4@get_string
	movzx	eax, BYTE PTR [r13+28]
	test	al, al
	je	SHORT $LN5@get_string
	test	al, 4
	je	SHORT $LN4@get_string
$LN5@get_string:

; 480  :                 if ( ConcatLine( src, count, dst, p ) != EMPTY ) {

	mov	r9, r13
	mov	r8, rsi
	mov	edx, r12d
	mov	rcx, rbx
	call	ConcatLine
	cmp	eax, -2
	je	SHORT $LN4@get_string

; 481  :                     DebugMsg1(("Tokenize.get_string: backslash concatenation: >%s<\n", src ));
; 482  :                     p->flags3 |= TF3_ISCONCAT;

	or	BYTE PTR [r13+30], 1

; 483  :                     if ( count )

	test	r12d, r12d
	jne	SHORT $LN77@get_string

; 484  :                         continue;
; 485  :                     return( EMPTY );

	lea	eax, QWORD PTR [r12-2]
	jmp	$LN56@get_string
$LN4@get_string:

; 486  :                 }
; 487  :             }
; 488  :             /* v2.08: handle '!' operator */
; 489  :             if ( *src == '!' && *(src+1) && count < MAX_STRING_LEN - 1 )

	cmp	BYTE PTR [rbx], 33			; 00000021H
	jne	SHORT $LN2@get_string
	cmp	BYTE PTR [rbx+1], 0
	lea	rax, QWORD PTR [rbx+1]
	je	SHORT $LN2@get_string
	cmp	r12d, 991				; 000003dfH
	jge	SHORT $LN2@get_string

; 490  :                 *dst++ = *src++;

	mov	BYTE PTR [rsi], 33			; 00000021H
	inc	rsi
	mov	rbx, rax
$LN2@get_string:

; 491  :             *dst++ = *src++;

	movzx	eax, BYTE PTR [rbx]
	inc	rsi
	inc	rbx
	mov	BYTE PTR [rsi-1], al

; 492  :             count++;

	inc	r12d
$LN77@get_string:

; 459  :         break;
; 460  :     default:
; 461  :         undelimited_string:
; 462  :         buf->string_delim = NULLC;
; 463  :         /* this is an undelimited string,
; 464  :          * so just copy it until we hit something that looks like the end.
; 465  :          * this format is used by the INCLUDE directive, but may also
; 466  :          * occur inside the string macros!
; 467  :          */
; 468  :         /* v2.05: also stop if a ')' is found - see literal2.asm regression test */
; 469  :         //for( count = 0 ; count < MAX_STRING_LEN && *src != NULLC && !isspace( *src ) && *src != ',' && *src != ';'; ) {
; 470  :         for( ; count < MAX_STRING_LEN &&
; 471  :             /* v2.08: stop also at < and % */
; 472  :             //*src != NULLC && !isspace( *src ) && *src != ',' && *src != ';' && *src != ')'; ) {
; 473  :             //*src && !isspace( *src ) && *src != ',' && *src != ')' && *src != '<' && *src != '%'; ) {
; 474  :             *src && !isspace( *src ) && *src != ',' && *src != ')' && *src != '%'; ) {

	cmp	r12d, 992				; 000003e0H
	jl	$LL9@get_string

; 339  :                     break; /* exit loop */
; 340  :                 /* a pair of quotes inside the string is
; 341  :                  * handled as a single quote */
; 342  :             } else if( c == NULLC ) {

	mov	rcx, QWORD PTR buf$[rsp]
	jmp	SHORT $LN50@get_string
$LN53@get_string:

; 328  :     case '"':
; 329  :     case '\'':
; 330  :         buf->string_delim = symbol_o;

	mov	BYTE PTR [rcx+1], r14b

; 331  :         *dst++ = symbol_o;

	mov	BYTE PTR [rsi], r14b
	inc	rsi

; 332  :         src++;

	inc	rbx
$LL52@get_string:

; 333  :         for ( ; count < MAX_STRING_LEN; src++, count++ ) {
; 334  :             c = *src;

	movzx	eax, BYTE PTR [rbx]

; 335  :             if( c == symbol_o ) { /* another quote? */

	cmp	al, r14b
	jne	SHORT $LN49@get_string

; 336  :                 *dst++ = c; /* store it */

	mov	BYTE PTR [rsi], al

; 337  :                 src++;

	inc	rbx
	inc	rsi

; 338  :                 if( *src != c )

	cmp	BYTE PTR [rbx], al
	jne	SHORT $LN50@get_string

; 339  :                     break; /* exit loop */
; 340  :                 /* a pair of quotes inside the string is
; 341  :                  * handled as a single quote */
; 342  :             } else if( c == NULLC ) {

	jmp	SHORT $LN51@get_string
$LN49@get_string:
	test	al, al
	je	SHORT $LN72@get_string

; 346  :                 break;
; 347  :             } else {
; 348  :                 *dst++ = c;

	mov	BYTE PTR [rsi], al
	inc	rsi
$LN51@get_string:
	inc	r12d
	inc	rbx
	cmp	r12d, 992				; 000003e0H
	jl	SHORT $LL52@get_string

; 339  :                     break; /* exit loop */
; 340  :                 /* a pair of quotes inside the string is
; 341  :                  * handled as a single quote */
; 342  :             } else if( c == NULLC ) {

	jmp	SHORT $LN50@get_string
$LN72@get_string:

; 343  :                 /* missing terminating quote, change to undelimited string */
; 344  :                 buf->string_delim = NULLC;

	mov	BYTE PTR [rcx+1], 0

; 345  :                 count++; /* count the first quote */

	inc	r12d
	jmp	SHORT $LN50@get_string
$LN81@get_string:

; 339  :                     break; /* exit loop */
; 340  :                 /* a pair of quotes inside the string is
; 341  :                  * handled as a single quote */
; 342  :             } else if( c == NULLC ) {

	mov	rcx, QWORD PTR buf$[rsp]
	jmp	SHORT $LN50@get_string
$LN82@get_string:
	mov	rcx, QWORD PTR buf$[rsp]
	jmp	SHORT $LN50@get_string
$LN83@get_string:
	mov	rcx, QWORD PTR buf$[rsp]
	jmp	SHORT $LN50@get_string
$LN84@get_string:
	mov	rcx, QWORD PTR buf$[rsp]
	jmp	SHORT $LN50@get_string
$LN85@get_string:
	mov	rcx, QWORD PTR buf$[rsp]
	jmp	SHORT $LN50@get_string
$LN86@get_string:
	mov	rcx, QWORD PTR buf$[rsp]
$LN50@get_string:

; 493  :         }
; 494  :         break;
; 495  :     }
; 496  : 
; 497  :     if ( count == MAX_STRING_LEN ) {

	cmp	r12d, 992				; 000003e0H
	jne	SHORT $LN1@get_string

; 498  :         EmitError( STRING_OR_TEXT_LITERAL_TOO_LONG );

	mov	ecx, 155				; 0000009bH
	call	EmitError

; 499  :         return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN56@get_string
$LN1@get_string:

; 500  :     }
; 501  :     *dst++ = NULLC;

	mov	BYTE PTR [rsi], 0
	lea	rax, QWORD PTR [rsi+1]

; 502  :     buf->token = T_STRING;

	mov	BYTE PTR [rcx], 9

; 503  :     buf->stringlen = count;

	mov	DWORD PTR [rcx+16], r12d

; 504  :     p->input = src;
; 505  :     p->output = dst;

	mov	QWORD PTR [r13+8], rax

; 506  :     return( NOT_ERROR );

	xor	eax, eax
	mov	QWORD PTR [r13], rbx
$LN56@get_string:
	mov	r15, QWORD PTR [rsp+40]
	mov	r14, QWORD PTR [rsp+48]
	mov	r13, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+112]

; 507  : }

	add	rsp, 88					; 00000058H
	ret	0
get_string ENDP
_TEXT	ENDS
EXTRN	strchr:NEAR
EXTRN	isalnum:NEAR
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$get_special_symbol DD 0b2601H
	DD	04c426H
	DD	097418H
	DD	086413H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$get_special_symbol DD @imagerel(get_special_symbol#)
	DD	@imagerel(get_special_symbol#+877)
	DD	@imagerel($unwind$get_special_symbol#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buf$ = 48
p$ = 56
get_special_symbol PROC NEAR

; 511  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx

; 512  :     char    symbol;
; 513  :     char    c;
; 514  :     int     i;
; 515  :     int  index;
; 516  : 
; 517  :     symbol = *p->input;

	mov	rcx, QWORD PTR [rdx]
	movsx	esi, BYTE PTR [rcx]
	mov	QWORD PTR [rsp+32], r12
	mov	rbx, rdx

; 518  :     switch( symbol ) {

	lea	eax, DWORD PTR [rsi-37]
	mov	ebp, esi
	cmp	eax, 56					; 00000038H
	ja	$LN9@get_specia
	lea	r12, OFFSET FLAT:__ImageBase
	cdqe
	movzx	eax, BYTE PTR $LN34@get_specia[r12+rax]
	mov	r8d, DWORD PTR $LN35@get_specia[r12+rax*4]
	add	r8, r12
	jmp	r8
$LN27@get_specia:

; 519  :     case ':' : /* T_COLON binary operator (0x3A) */
; 520  :         p->input++;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdx], rax

; 521  :         if ( *p->input == ':' ) {

	cmp	BYTE PTR [rax], 58			; 0000003aH
	jne	SHORT $LN26@get_specia

; 522  :             p->input++;

	inc	rax
	mov	QWORD PTR [rdx], rax

; 523  :             buf->token = T_DBL_COLON;
; 524  :             buf->string_ptr = "::";

	lea	rax, OFFSET FLAT:$SG5746
	mov	BYTE PTR [rdi], 13
	mov	QWORD PTR [rdi+8], rax

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN30@get_specia
$LN26@get_specia:

; 525  :         } else {
; 526  :             buf->token = T_COLON;
; 527  :             buf->string_ptr = ":";

	lea	rax, OFFSET FLAT:$SG5748
	mov	BYTE PTR [rdi], 58			; 0000003aH
	mov	QWORD PTR [rdi+8], rax

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN30@get_specia
$LN24@get_specia:

; 528  :         }
; 529  :         break;
; 530  :     case '%' : /* T_PERCENT (0x25) */
; 531  : #if PERCENT_OUT
; 532  :         /* %OUT directive? */
; 533  :         if ( ( _memicmp( p->input+1, "OUT", 3 ) == 0 ) && !is_valid_id_char( *(p->input+4) ) ) {

	lea	rdx, OFFSET FLAT:$SG5751
	inc	rcx
	mov	r8d, 3
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN23@get_specia
	mov	rax, QWORD PTR [rbx]
	movsx	ecx, BYTE PTR [rax+4]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN23@get_specia
	mov	rax, QWORD PTR [rbx]
	movzx	ecx, BYTE PTR [rax+4]
	cmp	cl, 95					; 0000005fH
	je	SHORT $LN23@get_specia
	cmp	cl, 64					; 00000040H
	je	SHORT $LN23@get_specia
	cmp	cl, 36					; 00000024H
	je	SHORT $LN23@get_specia
	cmp	cl, 63					; 0000003fH
	je	SHORT $LN23@get_specia

; 534  :             buf->token = T_DIRECTIVE;

	mov	BYTE PTR [rdi], 3

; 535  :             buf->tokval = T_ECHO;

	mov	DWORD PTR [rdi+16], 446			; 000001beH

; 536  :             buf->dirtype = DRT_ECHO;

	mov	BYTE PTR [rdi+1], 46			; 0000002eH

; 537  :             memcpy( p->output, p->input, 4 );

	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 538  :             p->input += 4;
; 539  :             p->output += 4;

	add	QWORD PTR [rbx+8], 4
	mov	rax, QWORD PTR [rbx+8]
	add	QWORD PTR [rbx], 4

; 540  :             *(p->output)++ = NULLC;

	mov	BYTE PTR [rax], 0
	inc	QWORD PTR [rbx+8]

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN30@get_specia
$LN23@get_specia:

; 541  :             break;
; 542  :         }
; 543  : #endif
; 544  :         p->input++;

	inc	QWORD PTR [rbx]

; 545  :         if ( p->flags == TOK_DEFAULT && p->index == 0 ) {

	cmp	BYTE PTR [rbx+28], 0
	jne	SHORT $LN22@get_specia
	cmp	DWORD PTR [rbx+24], 0
	jne	SHORT $LN22@get_specia

; 546  :             p->flags3 |= TF3_EXPANSION;

	or	BYTE PTR [rbx+30], 2

; 547  :             return( EMPTY );

	mov	eax, -2
	jmp	$LN30@get_specia
$LN22@get_specia:

; 548  :         }
; 549  :         buf->token = T_PERCENT;
; 550  :         buf->string_ptr = "%";

	lea	rax, OFFSET FLAT:$SG5753
	mov	BYTE PTR [rdi], 37			; 00000025H
	mov	QWORD PTR [rdi+8], rax

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN30@get_specia
$LN21@get_specia:

; 551  :         break;
; 552  :     case '(' : /* 0x28: T_OP_BRACKET operator - needs a matching ')' */
; 553  :         /* v2.11: reset c-expression flag if a macro function call is detected */
; 554  :         if ( ( p->flags2 & DF_CEXPR ) && p->index && (buf-1)->token == T_ID ) {

	test	BYTE PTR [rdx+29], 1
	je	SHORT $LN19@get_specia
	cmp	DWORD PTR [rdx+24], 0
	je	SHORT $LN19@get_specia
	cmp	BYTE PTR [rdi-32], 8
	jne	SHORT $LN19@get_specia

; 555  :             struct asym *sym = SymSearch( (buf-1)->string_ptr );

	mov	rcx, QWORD PTR [rdi-24]
	call	SymFind

; 556  :             if ( sym && ( sym->state == SYM_MACRO ) && sym->isfunc )

	test	rax, rax
	je	SHORT $LN19@get_specia
	cmp	DWORD PTR [rax+40], 9
	jne	SHORT $LN19@get_specia
	test	BYTE PTR [rax+52], 2
	je	SHORT $LN19@get_specia

; 557  :                 p->flags2 &= ~DF_CEXPR;

	and	BYTE PTR [rbx+29], -2
$LN19@get_specia:

; 558  :         }
; 559  :         /* no break */
; 560  :     case ')' : /* 0x29: T_CL_BRACKET */
; 561  :     case '*' : /* 0x2A: binary operator */
; 562  :     case '+' : /* 0x2B: unary|binary operator */
; 563  :     case ',' : /* 0x2C: T_COMMA */
; 564  :     case '-' : /* 0x2D: unary|binary operator */
; 565  :     case '.' : /* 0x2E: T_DOT binary operator */
; 566  :     case '/' : /* 0x2F: binary operator */
; 567  :         /* all of these are themselves a token */
; 568  :         p->input++;

	inc	QWORD PTR [rbx]

; 569  :         buf->token = symbol;
; 570  :         buf->specval = 0; /* initialize, in case the token needs extra data */
; 571  :         /* v2.06: use constants for the token string */
; 572  :         buf->string_ptr = (char *)&stokstr1[symbol - '('];

	lea	eax, DWORD PTR [rbp-40]
	mov	BYTE PTR [rdi], sil
	movsxd	rcx, eax
	mov	BYTE PTR [rdi+1], 0
	lea	rax, QWORD PTR stokstr1[r12+rcx*2]
	mov	QWORD PTR [rdi+8], rax

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN30@get_specia
$LN17@get_specia:

; 573  :         break;
; 574  :     case '[' : /* T_OP_SQ_BRACKET operator - needs a matching ']' (0x5B) */
; 575  :     case ']' : /* T_CL_SQ_BRACKET (0x5D) */
; 576  :         p->input++;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdx], rax

; 577  : #if AVXSUPP
; 578  :         while ( isspace( *p->input )) p->input++; 

	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN15@get_specia
	npad	13
$LL16@get_specia:
	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL16@get_specia
$LN15@get_specia:

; 579  :         c = *p->input;

	mov	rax, QWORD PTR [rbx]
	movzx	edx, BYTE PTR [rax]

; 580  : #endif
; 581  :         buf->token = symbol;
; 582  :         /* v2.06: use constants for the token string */
; 583  :         buf->string_ptr = (char *)&stokstr2[symbol - '['];

	lea	eax, DWORD PTR [rbp-91]
	mov	BYTE PTR [rdi], sil

; 584  : #if AVXSUPP
; 585  :         /* Intercept here '{' for EVEX mask or broadcast events 
; 586  :          * it could be {k1}, ]{k1}{z}, {1to2},{1to4},{1to8},{1to16}
; 587  :         */
; 588  :         if (c == '{')

	cmp	dl, 123					; 0000007bH
	movsxd	rcx, eax
	lea	rax, QWORD PTR stokstr2[r12+rcx*2]
	mov	QWORD PTR [rdi+8], rax
	jne	$LN28@get_specia

; 589  :         {
; 590  :           p->input++;

	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]

; 591  :           if ((*p->input | 0x20) == 'k' || (*p->input | 0x20) == 'z')

	movzx	ecx, BYTE PTR [rax]
	or	cl, 32					; 00000020H
	cmp	cl, 107					; 0000006bH
	je	SHORT $LN12@get_specia
	cmp	cl, 122					; 0000007aH
	je	SHORT $LN12@get_specia

; 593  :           else
; 594  :             get_broads( p ) ;   // broadcast decorators

	mov	rcx, rbx
	call	get_broads

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN30@get_specia
$LN12@get_specia:

; 592  :             get_decos( p ) ;    // mask decorators

	mov	rcx, rbx
	call	get_decos

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN30@get_specia
$LN10@get_specia:

; 595  :         }
; 596  : #endif
; 597  :         break;
; 598  :     case '=' : /* (0x3D) */
; 599  :         if ( *(p->input+1) != '=' ) {

	cmp	BYTE PTR [rcx+1], 61			; 0000003dH
	je	SHORT $LN9@get_specia

; 600  :             buf->token = T_DIRECTIVE;
; 601  :             buf->tokval = T_EQU;
; 602  :             buf->dirtype = DRT_EQUALSGN; /* to make it differ from EQU directive */
; 603  :             buf->string_ptr = "=";

	lea	rax, OFFSET FLAT:$SG5771
	mov	BYTE PTR [rdi], 3
	mov	DWORD PTR [rdi+16], 448			; 000001c0H
	mov	QWORD PTR [rdi+8], rax
	mov	BYTE PTR [rdi+1], 48			; 00000030H

; 604  :             p->input++;

	inc	QWORD PTR [rdx]

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN30@get_specia
$LN9@get_specia:

; 605  :             break;
; 606  :         }
; 607  :         /* fall through */
; 608  :     default:
; 609  :         /* detect C style operators.
; 610  :          * DF_CEXPR is set if .IF, .WHILE, .ELSEIF or .UNTIL
; 611  :          * has been detected in the current line.
; 612  :          * will catch: '!', '<', '>', '&', '==', '!=', '<=', '>=', '&&', '||'
; 613  :          * A single '|' will also be caught, although it isn't a valid
; 614  :          * operator - it will cause a 'operator expected' error msg later.
; 615  :          * the tokens are stored as one- or two-byte sized "strings".
; 616  :          */
; 617  :       if ( ( p->flags2 & DF_CEXPR ) && strchr( "=!<>&|", symbol ) ) {     //habran added ''

	test	BYTE PTR [rdx+29], 1
	je	$LN7@get_specia
	lea	rcx, OFFSET FLAT:$SG5774
	mov	edx, ebp
	call	strchr
	test	rax, rax
	je	SHORT $LN7@get_specia

; 618  :             *(p->output)++ = symbol;

	mov	rax, QWORD PTR [rbx+8]
	mov	BYTE PTR [rax], sil
	inc	QWORD PTR [rbx+8]

; 619  :             p->input++;

	inc	QWORD PTR [rbx]

; 620  :             buf->stringlen = 1;
; 621  :             if ( symbol == '&' || symbol == '|' ) {

	cmp	sil, 38					; 00000026H
	mov	DWORD PTR [rdi+16], 1
	je	SHORT $LN5@get_specia
	cmp	sil, 124				; 0000007cH
	je	SHORT $LN5@get_specia

; 626  :                 }
; 627  :             } else if ( *p->input == '=' ) {

	mov	rax, QWORD PTR [rbx]
	cmp	BYTE PTR [rax], 61			; 0000003dH
	jne	SHORT $LN4@get_specia

; 628  :                 *(p->output)++ = '=';

	mov	rax, QWORD PTR [rbx+8]
	mov	BYTE PTR [rax], 61			; 0000003dH
	inc	QWORD PTR [rbx+8]

; 629  :                 p->input++;

	inc	QWORD PTR [rbx]

; 630  :                 buf->stringlen = 2;

	mov	DWORD PTR [rdi+16], 2
	jmp	SHORT $LN4@get_specia
$LN5@get_specia:

; 622  :                 if ( *p->input == symbol ) {

	mov	rax, QWORD PTR [rbx]
	cmp	BYTE PTR [rax], sil
	jne	SHORT $LN4@get_specia

; 623  :                     *(p->output)++ = symbol;

	mov	rax, QWORD PTR [rbx+8]
	mov	BYTE PTR [rax], sil
	inc	QWORD PTR [rbx+8]

; 624  :                     p->input++;

	inc	QWORD PTR [rbx]

; 625  :                     buf->stringlen = 2;

	mov	DWORD PTR [rdi+16], 2
$LN4@get_specia:

; 631  :             }
; 632  :             buf->token = T_STRING;

	mov	BYTE PTR [rdi], 9

; 633  :             buf->string_delim = NULLC;

	mov	BYTE PTR [rdi+1], 0

; 634  :             *(p->output)++ = NULLC;

	mov	rax, QWORD PTR [rbx+8]
	mov	BYTE PTR [rax], 0
	inc	QWORD PTR [rbx+8]

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN30@get_specia
$LN7@get_specia:

; 635  :             break;
; 636  :         }
; 637  :         /* v2.08: ampersand is a special token */
; 638  :         if ( symbol == '&' ) {

	cmp	sil, 38					; 00000026H
	jne	SHORT $LN1@get_specia

; 639  :             p->input++;

	inc	QWORD PTR [rbx]

; 640  :             buf->token = '&';
; 641  :             buf->string_ptr = "&";

	lea	rax, OFFSET FLAT:$SG5781
	mov	BYTE PTR [rdi], sil
	mov	QWORD PTR [rdi+8], rax
$LN28@get_specia:

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN30@get_specia
$LN1@get_specia:

; 642  :             break;
; 643  :         }
; 644  :         /* anything we don't recognise we will consider a string,
; 645  :          * delimited by space characters, commas, newlines or nulls
; 646  :          */
; 647  :         return( get_string( buf, p ) );

	mov	rdx, rbx
	mov	rcx, rdi
	call	get_string
$LN30@get_specia:
	mov	r12, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 650  : }

	add	rsp, 40					; 00000028H
	ret	0
	npad	1
$LN35@get_specia:
	DD	$LN24@get_specia
	DD	$LN21@get_specia
	DD	$LN19@get_specia
	DD	$LN27@get_specia
	DD	$LN10@get_specia
	DD	$LN17@get_specia
	DD	$LN9@get_specia
$LN34@get_specia:
	DB	0
	DB	6
	DB	6
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	6
	DB	5
get_special_symbol ENDP
_TEXT	ENDS
EXTRN	ModuleInfo:BYTE
xdata	SEGMENT
$unwind$get_number DD 0b5801H
	DD	083458H
	DD	04e421H
	DD	05d41cH
	DD	0b7411H
	DD	0a6409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$get_number DD @imagerel(get_number#)
	DD	@imagerel(get_number#+184)
	DD	@imagerel($unwind$get_number#)
pdata	ENDS
xdata	SEGMENT
$chain$6$get_number DD 040a21H
	DD	06c40aH
	DD	095405H
	DD	@imagerel(get_number#)
	DD	@imagerel(get_number#+184)
	DD	@imagerel($unwind$get_number#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$get_number DD @imagerel(get_number#+184)
	DD	@imagerel(get_number#+353)
	DD	@imagerel($chain$6$get_number#)
pdata	ENDS
xdata	SEGMENT
$chain$7$get_number DD 021H
	DD	@imagerel(get_number#)
	DD	@imagerel(get_number#+184)
	DD	@imagerel($unwind$get_number#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$get_number DD @imagerel(get_number#+353)
	DD	@imagerel(get_number#+940)
	DD	@imagerel($chain$7$get_number#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buf$ = 64
p$ = 72
get_number PROC NEAR

; 673  : {

	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+80], rsi

; 674  :     char                *ptr = p->input;

	mov	rsi, QWORD PTR [rdx]
	mov	QWORD PTR [rsp+88], rdi

; 675  :     char                *dig_start;
; 676  :     char                *dig_end;
; 677  :     unsigned            base = 0;

	xor	r9d, r9d

; 678  :     unsigned            len;
; 679  :     uint_32             digits_seen;
; 680  :     char                last_char;
; 681  : 
; 682  : #define VALID_BINARY    0x0003
; 683  : #define VALID_OCTAL     0x00ff
; 684  : #define VALID_DECIMAL   0x03ff
; 685  : #define OK_NUM( t )     ((digits_seen & ~VALID_##t) == 0)
; 686  : 
; 687  :     digits_seen = 0;
; 688  : #if CHEXPREFIX
; 689  :     if( *ptr == '0' && (tolower( *(ptr+1) ) == 'x' ) ) {

	cmp	BYTE PTR [rsi], 48			; 00000030H
	mov	QWORD PTR [rsp+40], r13
	mov	QWORD PTR [rsp+32], r14
	mov	r13, rdx
	mov	rdi, rsi
	mov	r14, rcx
	mov	r10d, r9d
	jne	SHORT $LN35@get_number
	movzx	eax, BYTE PTR [rsi+1]
	cmp	al, 65					; 00000041H
	jl	SHORT $LN38@get_number
	cmp	al, 90					; 0000005aH
	jg	SHORT $LN38@get_number
	movsx	ecx, al
	or	ecx, 32					; 00000020H
	jmp	SHORT $LN39@get_number
$LN38@get_number:
	movsx	ecx, al
$LN39@get_number:
	cmp	ecx, 120				; 00000078H
	jne	SHORT $LN35@get_number

; 690  :         ptr += 2;

	add	rdi, 2

; 691  :         base = 16;

	lea	r9d, QWORD PTR [rcx-104]
$LN35@get_number:
	mov	QWORD PTR [rsp+64], rbx

; 692  :     }
; 693  : #endif
; 694  :     dig_start = ptr;

	mov	r11d, 1
	mov	rbx, rdi
$LL34@get_number:

; 695  :     for( ;; ptr++ ) {
; 696  :         if (*ptr >= '0' && *ptr <= '9')

	movzx	ecx, BYTE PTR [rdi]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN31@get_number
	cmp	cl, 57					; 00000039H
	jg	SHORT $LN31@get_number

; 697  :             digits_seen |= 1 << (*ptr - '0');

	mov	al, cl
	mov	edx, r11d
	sub	eax, 48					; 00000030H
	movzx	ecx, al
	shl	edx, cl
	or	r10d, edx
	inc	rdi
	jmp	SHORT $LL34@get_number
$LN31@get_number:

; 698  :         else {
; 699  :             last_char = tolower( *ptr );

	cmp	cl, 65					; 00000041H
	jl	SHORT $LN40@get_number
	cmp	cl, 90					; 0000005aH
	jg	SHORT $LN40@get_number
	or	cl, 32					; 00000020H
$LN40@get_number:

; 700  :             if ( last_char >= 'a' && last_char <= 'f' )

	lea	eax, DWORD PTR [rcx-97]
	cmp	al, 5
	ja	SHORT $LN29@get_number

; 701  :                 digits_seen |= 1 << ( last_char + 10 - 'a' );

	mov	al, cl
	mov	edx, r11d
	sub	eax, 87					; 00000057H
	movzx	ecx, al
	shl	edx, cl
	or	r10d, edx
	inc	rdi
	jmp	SHORT $LL34@get_number
$LN29@get_number:

; 702  :             else
; 703  :                 break;
; 704  :         }
; 705  :     }
; 706  : 
; 707  :     /* note that a float MUST contain a dot.
; 708  :      * 1234e78 is NOT a valid float
; 709  :      */
; 710  :     if ( last_char == '.' )

	cmp	cl, 46					; 0000002eH
	jne	$LN27@get_number

; 711  :         return( get_float( buf, p ) );

	movzx	ebx, BYTE PTR [rsi]
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+48], r12
	xor	bpl, bpl
	xor	r12b, r12b
	test	bl, bl
	je	SHORT $LN68@get_number
	npad	4
$LL54@get_number:
	movsx	edi, bl
	mov	ecx, edi
	call	isdigit
	test	eax, eax
	jne	SHORT $LN53@get_number
	cmp	bl, 46					; 0000002eH
	jne	SHORT $LN49@get_number
	test	bpl, bpl
	jne	SHORT $LN57@get_number
	mov	bpl, 1
	jmp	SHORT $LN53@get_number
$LN49@get_number:
	sub	bl, 65					; 00000041H
	cmp	bl, 25
	ja	SHORT $LN57@get_number
	or	edi, 32					; 00000020H
$LN57@get_number:
	cmp	edi, 101				; 00000065H
	jne	SHORT $LN68@get_number
	test	r12b, r12b
	jne	SHORT $LN68@get_number
	movzx	ecx, BYTE PTR [rsi+1]
	mov	r12b, 1
	cmp	cl, 43					; 0000002bH
	je	SHORT $LN45@get_number
	cmp	cl, 45					; 0000002dH
	jne	SHORT $LN53@get_number
$LN45@get_number:
	inc	rsi
$LN53@get_number:
	mov	bl, BYTE PTR [rsi+1]
	inc	rsi
	test	bl, bl
	jne	SHORT $LL54@get_number
$LN68@get_number:
	mov	BYTE PTR [r14], 11
	mov	BYTE PTR [r14+1], 0
	mov	rdx, QWORD PTR [r13]
	mov	rcx, QWORD PTR [r13+8]
	mov	r8, rsi
	sub	r8, rdx
	call	memcpy
	mov	r12, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+72]
	mov	r11, rsi
	sub	r11, QWORD PTR [r13]
	add	QWORD PTR [r13+8], r11
	mov	rax, QWORD PTR [r13+8]
	mov	BYTE PTR [rax], 0
	mov	QWORD PTR [r13], rsi
	jmp	$LN71@get_number
$LN27@get_number:

; 712  : 
; 713  : #if 0
; 714  :     /* v2.08: if suffix isn't followed by a non-id char, don't use it! */
; 715  :     if ( last_char && is_valid_id_char( *(ptr+1) ) ) {
; 716  :         last_char = NULLC;
; 717  :         while ( *(ptr-1) > '9' )
; 718  :             ptr--;
; 719  :         digits_seen &= 0x3FF;
; 720  : 
; 721  :     }
; 722  : #endif
; 723  : 
; 724  : #if CHEXPREFIX
; 725  :     if ( base != 0 ) {

	test	r9d, r9d
	je	SHORT $LN26@get_number

; 726  :         dig_end = ptr;
; 727  :         if ( digits_seen == 0 )

	test	r10d, r10d
	mov	rdx, rdi

; 728  :             base = 0;
; 729  :     } else

	jne	$LN6@get_number
$LN5@get_number:

; 811  :         buf->token = T_BAD_NUM;

	mov	BYTE PTR [r14], 12
$LL3@get_number:

; 812  :         DebugMsg(("get_number: BAD_NUMBER (%s), radix=%u, base=%u, ptr=>%s<, digits_seen=%Xh\n", dig_start, ModuleInfo.radix, base, ptr, digits_seen ));
; 813  :         /* swallow remainder of token */
; 814  :         while( is_valid_id_char( *ptr ) ) ++ptr;

	movsx	ecx, BYTE PTR [rdi]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN1@get_number
	movzx	eax, BYTE PTR [rdi]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN1@get_number
	cmp	al, 64					; 00000040H
	je	SHORT $LN1@get_number
	cmp	al, 36					; 00000024H
	je	SHORT $LN1@get_number
	cmp	al, 63					; 0000003fH
	jne	SHORT $number_done$5812
$LN1@get_number:
	inc	rdi
	jmp	SHORT $LL3@get_number
$LN26@get_number:

; 730  : #endif
; 731  :     switch( last_char ) {

	movsx	eax, cl
	add	eax, -104				; ffffffffffffff98H
	cmp	eax, 17
	ja	$LN13@get_number
	lea	rdx, OFFSET FLAT:__ImageBase
	cdqe
	mov	ecx, DWORD PTR $LN67@get_number[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN21@get_number:

; 732  :     case 'r': /* a float with the "real number designator" */
; 733  :         buf->token = T_FLOAT;

	mov	BYTE PTR [r14], 11

; 734  :         buf->floattype = 'r';

	mov	BYTE PTR [r14+1], 114			; 00000072H

; 735  :         ptr++;

	inc	rdi
$number_done$5812:

; 815  :     }
; 816  : number_done:
; 817  :     len = ptr - p->input;
; 818  :     memcpy( p->output, p->input, len );

	mov	rdx, QWORD PTR [r13]
	mov	rcx, QWORD PTR [r13+8]
	mov	eax, edi
	sub	eax, DWORD PTR [r13]
	mov	r8d, eax
	mov	ebx, eax
	call	memcpy

; 819  : 
; 820  :     p->output += len;

	add	QWORD PTR [r13+8], rbx
	mov	rax, QWORD PTR [r13+8]

; 821  :     *p->output++ = NULLC;

	mov	BYTE PTR [rax], 0

; 822  :     p->input = ptr;

	mov	QWORD PTR [r13], rdi
$LN71@get_number:
	inc	QWORD PTR [r13+8]
	mov	r14, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+88]
	mov	r13, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+64]

; 823  : 
; 824  :     return( NOT_ERROR );

	xor	eax, eax

; 825  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN20@get_number:

; 736  :         goto number_done;
; 737  :     case 'h':
; 738  :         base = 16;
; 739  :         dig_end = ptr;

	mov	rdx, rdi

; 740  :         ptr++;

	inc	rdi
	mov	r9d, 16

; 803  : #else
; 804  :     if ( base != 0 && is_valid_id_char( *ptr ) == FALSE ) {
; 805  : #endif
; 806  :         buf->token = T_NUM;
; 807  :         buf->numbase = base;
; 808  :         buf->itemlen = dig_end - dig_start;

	sub	edx, ebx
	mov	BYTE PTR [r14], 10
	mov	BYTE PTR [r14+1], r9b
	mov	DWORD PTR [r14+16], edx

; 809  :         //DebugMsg(("get_number: inp=%s, value=%" I32_SPEC "X\n", p->input, buf->value64 ));
; 810  :     } else {

	jmp	SHORT $number_done$5812
$LN19@get_number:

; 741  :         break;
; 742  :     //case 'b':
; 743  :     case 'y':
; 744  :         if( OK_NUM( BINARY ) ) {

	test	r10d, -4				; fffffffcH
	jne	$LN5@get_number

; 745  :             base = 2;
; 746  :             dig_end = ptr;

	mov	rdx, rdi

; 747  :             ptr++;

	inc	rdi
	mov	r9d, 2

; 803  : #else
; 804  :     if ( base != 0 && is_valid_id_char( *ptr ) == FALSE ) {
; 805  : #endif
; 806  :         buf->token = T_NUM;
; 807  :         buf->numbase = base;
; 808  :         buf->itemlen = dig_end - dig_start;

	sub	edx, ebx
	mov	BYTE PTR [r14], 10
	mov	BYTE PTR [r14+1], r9b
	mov	DWORD PTR [r14+16], edx

; 809  :         //DebugMsg(("get_number: inp=%s, value=%" I32_SPEC "X\n", p->input, buf->value64 ));
; 810  :     } else {

	jmp	$number_done$5812
$LN17@get_number:

; 748  :         }
; 749  :         break;
; 750  :     //case 'd':
; 751  :     case 't':
; 752  :         if( OK_NUM( DECIMAL ) ) {

	test	r10d, -1024				; fffffc00H
	jne	$LN5@get_number

; 753  :             base = 10;
; 754  :             dig_end = ptr;

	mov	rdx, rdi
	mov	r9d, 10

; 755  :             ptr++;

	inc	rdi

; 803  : #else
; 804  :     if ( base != 0 && is_valid_id_char( *ptr ) == FALSE ) {
; 805  : #endif
; 806  :         buf->token = T_NUM;
; 807  :         buf->numbase = base;
; 808  :         buf->itemlen = dig_end - dig_start;

	sub	edx, ebx
	mov	BYTE PTR [r14], r9b
	mov	BYTE PTR [r14+1], r9b
	mov	DWORD PTR [r14+16], edx

; 809  :         //DebugMsg(("get_number: inp=%s, value=%" I32_SPEC "X\n", p->input, buf->value64 ));
; 810  :     } else {

	jmp	$number_done$5812
$LN15@get_number:

; 756  :         }
; 757  :         break;
; 758  :     case 'q':
; 759  :     case 'o':
; 760  :         if( OK_NUM( OCTAL ) ) {

	test	r10d, -256				; ffffff00H
	jne	$LN5@get_number

; 761  :             base = 8;
; 762  :             dig_end = ptr;

	mov	rdx, rdi

; 763  :             ptr++;

	inc	rdi
	mov	r9d, 8

; 803  : #else
; 804  :     if ( base != 0 && is_valid_id_char( *ptr ) == FALSE ) {
; 805  : #endif
; 806  :         buf->token = T_NUM;
; 807  :         buf->numbase = base;
; 808  :         buf->itemlen = dig_end - dig_start;

	sub	edx, ebx
	mov	BYTE PTR [r14], 10
	mov	BYTE PTR [r14+1], r9b
	mov	DWORD PTR [r14+16], edx

; 809  :         //DebugMsg(("get_number: inp=%s, value=%" I32_SPEC "X\n", p->input, buf->value64 ));
; 810  :     } else {

	jmp	$number_done$5812
$LN13@get_number:

; 764  :         }
; 765  :         break;
; 766  :     default:
; 767  :         last_char = tolower( *(ptr-1) );

	movzx	r8d, BYTE PTR [rdi-1]
	lea	rdx, QWORD PTR [rdi-1]
	cmp	r8b, 65					; 00000041H
	jl	SHORT $LN42@get_number
	cmp	r8b, 90					; 0000005aH
	jg	SHORT $LN42@get_number
	or	r8b, 32					; 00000020H
$LN42@get_number:

; 768  :         if ( ( last_char == 'b' || last_char == 'd' ) && digits_seen >= ( 1UL << ModuleInfo.radix ) ) {

	cmp	r8b, 98					; 00000062H
	movzx	r9d, BYTE PTR ModuleInfo+396
	je	SHORT $LN11@get_number
	cmp	r8b, 100				; 00000064H
	jne	SHORT $LN7@get_number
$LN11@get_number:
	movzx	ecx, r9b
	mov	eax, r11d
	shl	eax, cl
	cmp	r10d, eax
	jb	SHORT $LN7@get_number

; 769  :             char *tmp = dig_start;
; 770  :             char max = ( last_char == 'b' ? '1' : '9' );

	cmp	r8b, 98					; 00000062H
	mov	ecx, 57					; 00000039H
	mov	esi, 49					; 00000031H
	cmove	ecx, esi

; 771  :             for ( dig_end = ptr-1; tmp < dig_end && *tmp <= max; tmp++ );

	cmp	rbx, rdx
	mov	rax, rbx
	jae	SHORT $LN69@get_number
$LL10@get_number:
	cmp	BYTE PTR [rax], cl
	jg	SHORT $LN69@get_number
	inc	rax
	cmp	rax, rdx
	jb	SHORT $LL10@get_number
$LN69@get_number:

; 772  :             if ( tmp == dig_end ) {

	cmp	rax, rdx
	jne	SHORT $LN7@get_number

; 773  :                 base = ( last_char == 'b' ? 2 : 10 );

	mov	r9d, 2
	mov	eax, 10
	cmp	r8b, 98					; 00000062H
	cmove	eax, r9d
	mov	r9d, eax

; 774  :                 break;

	jmp	SHORT $LN6@get_number
$LN7@get_number:

; 775  :             }
; 776  :         }
; 777  :         dig_end = ptr;
; 778  : #if COCTALS
; 779  :         if( Options.allow_c_octals && *dig_start == '0' ) {
; 780  :             if( OK_NUM( OCTAL ) ) {
; 781  :                 base = 8;
; 782  :                 break;
; 783  :             }
; 784  :         }
; 785  : #endif
; 786  :         /* radix      max. digits_seen
; 787  :          -----------------------------------------------------------
; 788  :          2            3      2^2-1  (0,1)
; 789  :          8            255    2^8-1  (0,1,2,3,4,5,6,7)
; 790  :          10           1023   2^10-1 (0,1,2,3,4,5,6,7,8,9)
; 791  :          16           65535  2^16-1 (0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f)
; 792  :          */
; 793  :         if ( digits_seen < (1UL << ModuleInfo.radix) )

	movzx	r9d, r9b
	mov	rdx, rdi
	mov	ecx, r9d
	shl	r11d, cl
	cmp	r10d, r11d
	jae	$LN5@get_number
$LN6@get_number:

; 794  :             base = ModuleInfo.radix;
; 795  :         break;
; 796  :     }
; 797  : 
; 798  : #if MASMNUMBER
; 799  :     /* Masm doesn't swallow alphanum chars which may follow the
; 800  :      * number!
; 801  :      */
; 802  :     if ( base != 0 ) {

	test	r9d, r9d
	je	$LN5@get_number

; 803  : #else
; 804  :     if ( base != 0 && is_valid_id_char( *ptr ) == FALSE ) {
; 805  : #endif
; 806  :         buf->token = T_NUM;
; 807  :         buf->numbase = base;
; 808  :         buf->itemlen = dig_end - dig_start;

	sub	edx, ebx
	mov	BYTE PTR [r14], 10
	mov	BYTE PTR [r14+1], r9b
	mov	DWORD PTR [r14+16], edx

; 809  :         //DebugMsg(("get_number: inp=%s, value=%" I32_SPEC "X\n", p->input, buf->value64 ));
; 810  :     } else {

	jmp	$number_done$5812
	npad	1
$LN67@get_number:

; 825  : }

	DD	$LN20@get_number
	DD	$LN13@get_number
	DD	$LN13@get_number
	DD	$LN13@get_number
	DD	$LN13@get_number
	DD	$LN13@get_number
	DD	$LN13@get_number
	DD	$LN15@get_number
	DD	$LN13@get_number
	DD	$LN15@get_number
	DD	$LN21@get_number
	DD	$LN13@get_number
	DD	$LN17@get_number
	DD	$LN13@get_number
	DD	$LN13@get_number
	DD	$LN13@get_number
	DD	$LN13@get_number
	DD	$LN19@get_number
get_number ENDP
_TEXT	ENDS
EXTRN	EmitErr:NEAR
xdata	SEGMENT
$unwind$get_id_in_backquotes DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$get_id_in_backquotes DD @imagerel(get_id_in_backquotes#)
	DD	@imagerel(get_id_in_backquotes#+120)
	DD	@imagerel($unwind$get_id_in_backquotes#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buf$ = 48
p$ = 56
get_id_in_backquotes PROC NEAR

; 830  : {

	sub	rsp, 40					; 00000028H

; 831  :     char *optr = p->output;

	mov	r8, QWORD PTR [rdx+8]

; 832  :     buf->token = T_ID;

	mov	BYTE PTR [rcx], 8

; 833  :     buf->idarg = 0;

	mov	DWORD PTR [rcx+16], 0

; 834  : 
; 835  :     p->input++;         /* strip off the backquotes */

	inc	QWORD PTR [rdx]
	mov	rcx, QWORD PTR [rdx]

; 836  :     for( ; *p->input != '`'; ) {

	cmp	BYTE PTR [rcx], 96			; 00000060H
	je	SHORT $LN3@get_id_in_
	npad	3
$LL4@get_id_in_:

; 837  :         if( *p->input == NULLC || *p->input == ';' ) {

	movzx	eax, BYTE PTR [rcx]
	test	al, al
	je	SHORT $LN8@get_id_in_
	cmp	al, 59					; 0000003bH
	je	SHORT $LN8@get_id_in_

; 841  :         }
; 842  :         *optr++ = *p->input++;

	mov	BYTE PTR [r8], al
	inc	QWORD PTR [rdx]
	mov	rcx, QWORD PTR [rdx]
	inc	r8
	cmp	BYTE PTR [rcx], 96			; 00000060H
	mov	rax, rcx
	jne	SHORT $LL4@get_id_in_
$LN3@get_id_in_:

; 843  :     }
; 844  :     p->input++;         /* skip the terminating '`' */

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdx], rax

; 845  :     *optr++ = NULLC;

	lea	rax, QWORD PTR [r8+1]
	mov	BYTE PTR [r8], 0

; 846  :     p->output = optr;

	mov	QWORD PTR [rdx+8], rax

; 847  :     return( NOT_ERROR );

	xor	eax, eax

; 848  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@get_id_in_:

; 838  :             *p->output = NULLC;

	mov	rax, QWORD PTR [rdx+8]

; 839  :             EmitErr( BACKQUOTE_MISSING, p->output );

	mov	ecx, 97					; 00000061H
	mov	BYTE PTR [rax], 0
	mov	rdx, QWORD PTR [rdx+8]
	call	EmitErr

; 840  :             return( ERROR );

	mov	eax, -1

; 848  : }

	add	rsp, 40					; 00000028H
	ret	0
get_id_in_backquotes ENDP
_TEXT	ENDS
EXTRN	SpecialTable:BYTE
EXTRN	InstrTable:BYTE
EXTRN	optable_idx:BYTE
EXTRN	FindResWord:NEAR
xdata	SEGMENT
$unwind$get_id DD 0b6001H
	DD	04c460H
	DD	09741fH
	DD	086417H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$get_id DD @imagerel(get_id#)
	DD	@imagerel(get_id#+616)
	DD	@imagerel($unwind$get_id#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buf$ = 48
p$ = 56
get_id	PROC NEAR

; 855  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp

; 856  :     //struct ReservedWord *resw;
; 857  :     char *src = p->input;
; 858  :     char *dst = p->output;

	mov	rbp, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, QWORD PTR [rdx]
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	mov	rbx, rdx
	npad	11
$LL24@get_id:

; 859  :     int  index;
; 860  :     unsigned size;
; 861  : 
; 862  : #if CONCATID || DOTNAMEX
; 863  : continue_scan:
; 864  : #endif
; 865  :     do {
; 866  :         *dst++ = *src++;

	movzx	eax, BYTE PTR [rsi]
	inc	rsi
	inc	rbp
	mov	BYTE PTR [rbp-1], al

; 867  :     } while ( is_valid_id_char( *src ) );

	movsx	ecx, BYTE PTR [rsi]
	call	isalnum
	test	eax, eax
	jne	SHORT $LL24@get_id
	movzx	eax, BYTE PTR [rsi]
	cmp	al, 95					; 0000005fH
	je	SHORT $LL24@get_id
	cmp	al, 64					; 00000040H
	je	SHORT $LL24@get_id
	cmp	al, 36					; 00000024H
	je	SHORT $LL24@get_id
	cmp	al, 63					; 0000003fH
	je	SHORT $LL24@get_id
	mov	QWORD PTR [rsp+32], r12

; 868  : #if CONCATID
; 869  :     /* v2.05: in case there's a backslash right behind
; 870  :      * the ID, check if a line concatenation is to occur.
; 871  :      * If yes, and the first char of the concatenated line
; 872  :      * is also a valid ID char, continue to scan the name.
; 873  :      * Problem: it's ok for EQU, but less good for other directives.
; 874  :      */
; 875  :     if ( *src == '\\' ) {
; 876  :         if ( ConcatLine( src, src - p->input, dst, p ) != EMPTY ) {
; 877  :             p->concat = TRUE;
; 878  :             if ( is_valid_id_char( *src ) )
; 879  :                 goto continue_scan;
; 880  :         }
; 881  :     }
; 882  : #endif
; 883  : #if DOTNAMEX
; 884  :     /* if the name starts with a dot or underscore, then accept dots
; 885  :      * within the name (though not as last char). OPTION DOTNAME
; 886  :      * must be on.
; 887  :      */
; 888  :     if ( *src == '.' && ModuleInfo.dotname &&
; 889  :         ( *(p->output) == '.' || *(p->output) == '_' ) &&
; 890  :         ( is_valid_id_char(*(src+1)) || *(src+1) == '.' ) )
; 891  :         goto continue_scan;
; 892  : #endif
; 893  :     /* v2.04: check added */
; 894  :     size = dst - p->output;

	mov	r12d, ebp
	sub	r12d, DWORD PTR [rbx+8]

; 895  :     if ( size > MAX_ID_LEN ) {

	cmp	r12d, 247				; 000000f7H
	jbe	SHORT $LN21@get_id

; 896  :         EmitErr( IDENTIFIER_TOO_LONG );

	mov	ecx, 70					; 00000046H
	call	EmitErr

; 897  :         dst = p->output + MAX_ID_LEN;

	mov	rbp, QWORD PTR [rbx+8]
	add	rbp, 247				; 000000f7H
$LN21@get_id:

; 898  :     }
; 899  :     *dst++ = NULLC;

	mov	BYTE PTR [rbp], 0
	inc	rbp

; 900  : 
; 901  :     /* now decide what to do with it */
; 902  : 
; 903  :     if( size == 1 && *p->output == '?' ) {

	cmp	r12d, 1
	jne	SHORT $LN20@get_id
	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax], 63			; 0000003fH
	jne	SHORT $LN20@get_id

; 904  :         p->input = src;

	mov	QWORD PTR [rbx], rsi

; 905  :         buf->token = T_QUESTION_MARK;
; 906  :         buf->string_ptr = "?";

	lea	rax, OFFSET FLAT:$SG5863
	mov	BYTE PTR [rdi], 63			; 0000003fH
	mov	QWORD PTR [rdi+8], rax

; 907  :         return( NOT_ERROR );

	jmp	SHORT $LN12@get_id
$LN20@get_id:

; 908  :     }
; 909  :     index = FindResWord( p->output, size );

	mov	rcx, QWORD PTR [rbx+8]
	movzx	edx, r12b
	call	FindResWord

; 910  :     if( index == 0 ) {

	test	eax, eax
	jne	SHORT $LN19@get_id

; 911  :         /* if ID begins with a DOT, check for OPTION DOTNAME.
; 912  :          * if not set, skip the token and return a T_DOT instead!
; 913  :          */
; 914  :         if ( *p->output == '.' && ModuleInfo.dotname == FALSE ) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax], 46			; 0000002eH
	jne	SHORT $LN18@get_id
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	jne	SHORT $LN18@get_id

; 915  :            buf->token = T_DOT;
; 916  :            buf->string_ptr = (char *)&stokstr1['.' - '('];

	lea	rax, OFFSET FLAT:stokstr1+12
	mov	BYTE PTR [rdi], 46			; 0000002eH
	mov	QWORD PTR [rdi+8], rax

; 917  :            p->input++;

	inc	QWORD PTR [rbx]

; 918  :            return( NOT_ERROR );

	jmp	SHORT $LN12@get_id
$LN18@get_id:

; 919  :         }
; 920  :         p->input = src;

	mov	QWORD PTR [rbx], rsi

; 921  :         p->output = dst;

	mov	QWORD PTR [rbx+8], rbp
$LN1@get_id:

; 1012 :     default: /* shouldn't happen */
; 1013 :         DebugMsg(("get_id: error, unknown type in SpecialTable[%u]=%u\n", index, SpecialTable[index].type ));
; 1014 :         /**/myassert( 0 );
; 1015 :         buf->token = T_ID;
; 1016 :         buf->idarg = 0;

	mov	DWORD PTR [rdi+16], 0
	mov	BYTE PTR [rdi], 8
$LN12@get_id:
	mov	r12, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 1017 :         break;
; 1018 :     }
; 1019 :     return( NOT_ERROR );

	xor	eax, eax

; 1020 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN19@get_id:

; 922  :         buf->token = T_ID;
; 923  :         buf->idarg = 0;
; 924  :         return( NOT_ERROR );
; 925  :     }
; 926  :     p->input = src;
; 927  :     p->output = dst;
; 928  :     buf->tokval = index; /* is a enum instr_token value */
; 929  :     /* v2.11: RWF_SPECIAL now obsolete */
; 930  :     //if ( ! ( ResWordTable[index].flags & RWF_SPECIAL ) ) {
; 931  :     if ( index >= SPECIAL_LAST ) {

	cmp	eax, 455				; 000001c7H
	mov	QWORD PTR [rbx], rsi
	mov	QWORD PTR [rbx+8], rbp
	mov	DWORD PTR [rdi+16], eax
	jl	SHORT $LN17@get_id

; 932  : 
; 933  :         //  DebugMsg(("found item >%s< in instruction table, rm=%X\n", buf->string_ptr, InstrTable[index].rm_byte));
; 934  : 
; 935  :         /* if -Zm is set, the following from the Masm docs is relevant:
; 936  :          *
; 937  :          * Reserved Keywords Dependent on CPU Mode with OPTION M510
; 938  :          *
; 939  :          * With OPTION M510, keywords and instructions not available in the
; 940  :          * current CPU mode (such as ENTER under .8086) are not treated as
; 941  :          * keywords. This also means the USE32, FLAT, FAR32, and NEAR32 segment
; 942  :          * types and the 80386/486 registers are not keywords with a processor
; 943  :          * selection less than .386.
; 944  :          * If you remove OPTION M510, any reserved word used as an identifier
; 945  :          * generates a syntax error. You can either rename the identifiers or
; 946  :          * use OPTION NOKEYWORD. For more information on OPTION NOKEYWORD, see
; 947  :          * OPTION NOKEYWORD, later in this appendix.
; 948  :          *
; 949  :          * The current implementation of this rule below is likely to be improved.
; 950  :          */
; 951  :         if ( ModuleInfo.m510 ) {

	test	BYTE PTR ModuleInfo+408, 128		; 00000080H
	je	SHORT $LN15@get_id

; 952  :             /* checking the cpu won't give the expected results currently since
; 953  :              * some instructions in the table (i.e. MOV) start with a 386 variant!
; 954  :              */
; 955  :             index = IndexFromToken( buf->tokval );

	add	eax, -455				; fffffe39H
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	ecx, WORD PTR optable_idx[rdx+rax*2]

; 956  : #if 0 /* changed for v1.96 */
; 957  :             if (( InstrTable[index].cpu & P_EXT_MASK ) > ( ModuleInfo.curr_cpu & P_EXT_MASK )) {
; 958  : #else
; 959  :             if (( InstrTable[index].cpu & P_CPU_MASK ) > ( ModuleInfo.curr_cpu & P_CPU_MASK ) ||
; 960  :                 ( InstrTable[index].cpu & P_EXT_MASK ) > ( ModuleInfo.curr_cpu & P_EXT_MASK )) {

	imul	rcx, 14
	movzx	r8d, WORD PTR InstrTable[rcx+rdx+10]
	mov	edx, DWORD PTR ModuleInfo+392
	mov	eax, edx
	mov	ecx, r8d
	and	eax, 240				; 000000f0H
	and	ecx, 240				; 000000f0H
	cmp	ecx, eax
	jg	SHORT $LN1@get_id
	and	r8d, 65280				; 0000ff00H
	and	edx, 65280				; 0000ff00H
	cmp	r8d, edx

; 961  : #endif
; 962  :                 buf->token = T_ID;
; 963  :                 buf->idarg = 0;
; 964  :                 return( NOT_ERROR );

	jg	$LN1@get_id
$LN15@get_id:

; 965  :             }
; 966  :         }
; 967  :         buf->token = T_INSTRUCTION;

	mov	BYTE PTR [rdi], 1

; 968  :         return( NOT_ERROR );

	jmp	$LN12@get_id
$LN17@get_id:

; 969  :     }
; 970  :     index = buf->tokval;
; 971  : 
; 972  :     /* for RWT_SPECIAL, field <bytval> contains further infos:
; 973  :      - RWT_REG:             register number (regnum)
; 974  :      - RWT_DIRECTIVE:       type of directive (dirtype)
; 975  :      - RWT_UNARY_OPERATOR:  operator precedence
; 976  :      - RWT_BINARY_OPERATOR: operator precedence
; 977  :      - RWT_STYPE:           memtype
; 978  :      - RWT_RES_ID:          for languages, LANG_xxx value
; 979  :                             for the rest, unused.
; 980  :      */
; 981  :     buf->bytval = SpecialTable[index].bytval;

	cdqe
	lea	rdx, OFFSET FLAT:__ImageBase
	lea	r8, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[rdx+r8*4+10]
	mov	BYTE PTR [rdi+1], al

; 982  : 
; 983  :     switch ( SpecialTable[index].type ) {

	movzx	eax, BYTE PTR SpecialTable[rdx+r8*4+11]
	add	eax, -2
	cmp	eax, 5
	ja	$LN1@get_id
	cdqe
	mov	ecx, DWORD PTR $LN34@get_id[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN11@get_id:

; 984  :     case RWT_REG:
; 985  :         buf->token = T_REG;

	mov	BYTE PTR [rdi], 2

; 986  : #if AVXSUPP 
; 987  :         /* Intercept here '{' for EVEX mask  {k1}{z} */
; 988  :         while ( isspace( *p->input )) p->input++;

	mov	rax, QWORD PTR [rbx]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN9@get_id
	npad	10
$LL10@get_id:
	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL10@get_id
$LN9@get_id:

; 989  :         if (*p->input == '{'){

	mov	rax, QWORD PTR [rbx]
	cmp	BYTE PTR [rax], 123			; 0000007bH
	jne	$LN12@get_id

; 990  :           p->input++;

	inc	rax

; 991  :           get_decos( p ) ; // mask decorators

	mov	rcx, rbx
	mov	QWORD PTR [rbx], rax
	call	get_decos

; 992  :       }
; 993  : #endif        
; 994  :         break;

	jmp	$LN12@get_id
$LN7@get_id:

; 995  :     case RWT_DIRECTIVE:
; 996  :         buf->token = T_DIRECTIVE;

	mov	BYTE PTR [rdi], 3

; 997  :         if ( p->flags2 == 0 )

	cmp	BYTE PTR [rbx+29], 0
	jne	$LN12@get_id

; 998  :             p->flags2 = SpecialTable[index].value;

	movzx	eax, BYTE PTR SpecialTable[rdx+r8*4]
	mov	BYTE PTR [rbx+29], al

; 999  :         break;

	jmp	$LN12@get_id
$LN5@get_id:

; 1000 :     case RWT_UNARY_OP: /* OFFSET, LOW, HIGH, LOWWORD, HIGHWORD, SHORT, ... */
; 1001 :         buf->token  = T_UNARY_OPERATOR;

	mov	BYTE PTR [rdi], 4

; 1002 :         break;

	jmp	$LN12@get_id
$LN4@get_id:

; 1003 :     case RWT_BINARY_OP: /* GE, GT, LE, LT, EQ, NE, MOD, PTR */
; 1004 :         buf->token = T_BINARY_OPERATOR;

	mov	BYTE PTR [rdi], 5

; 1005 :         break;

	jmp	$LN12@get_id
$LN3@get_id:

; 1006 :     case RWT_STYPE:  /* BYTE, WORD, FAR, NEAR, FAR16, NEAR32 ... */
; 1007 :         buf->token = T_STYPE;

	mov	BYTE PTR [rdi], 6

; 1008 :         break;

	jmp	$LN12@get_id
$LN2@get_id:

; 1009 :     case RWT_RES_ID: /* DUP, ADDR, FLAT, VARARG, language types [, FRAME (64-bit)] */
; 1010 :         buf->token = T_RES_ID;

	mov	BYTE PTR [rdi], 7

; 1011 :         break;

	jmp	$LN12@get_id
	npad	1
$LN34@get_id:

; 1020 : }

	DD	$LN11@get_id
	DD	$LN7@get_id
	DD	$LN5@get_id
	DD	$LN4@get_id
	DD	$LN3@get_id
	DD	$LN2@get_id
get_id	ENDP
_TEXT	ENDS
PUBLIC	GetToken
EXTRN	Options:BYTE
EXTRN	isalpha:NEAR
xdata	SEGMENT
$unwind$GetToken DD 051101H
	DD	097411H
	DD	08340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$GetToken DD @imagerel($LN13#)
	DD	@imagerel($LN13#+279)
	DD	@imagerel($unwind$GetToken#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
token$ = 48
p$ = 56
GetToken PROC NEAR

; 1041 : {

$LN13:
	sub	rsp, 40					; 00000028H

; 1042 :     if( isdigit( *p->input ) ) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	movsx	ecx, BYTE PTR [rax]
	mov	rbx, rdx
	call	isdigit
	test	eax, eax
	je	SHORT $LN10@GetToken

; 1043 :         return( get_number( token, p ) );

	mov	rdx, rbx
	mov	rcx, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 1062 : }

	add	rsp, 40					; 00000028H
	jmp	get_number
$LN10@GetToken:

; 1044 :     } else if( is_valid_id_start( *p->input ) ) {

	mov	rax, QWORD PTR [rbx]
	movsx	ecx, BYTE PTR [rax]
	call	isalpha
	test	eax, eax
	jne	$LN7@GetToken
	mov	rcx, QWORD PTR [rbx]
	movzx	eax, BYTE PTR [rcx]
	cmp	al, 95					; 0000005fH
	je	$LN7@GetToken
	cmp	al, 64					; 00000040H
	je	$LN7@GetToken
	cmp	al, 36					; 00000024H
	je	$LN7@GetToken
	cmp	al, 63					; 0000003fH
	je	$LN7@GetToken

; 1046 :     } else if( *p->input == '.' &&
; 1047 : #if DOTNAMEX /* allow dots within identifiers */
; 1048 :               ( is_valid_id_char(*(p->input+1)) || *(p->input+1) == '.' ) &&
; 1049 : #else
; 1050 :               is_valid_id_char(*(p->input+1)) &&
; 1051 : #endif
; 1052 :               /* v2.11: member last_token has been removed */
; 1053 :               //( p->last_token != T_REG &&  p->last_token != T_CL_BRACKET && p->last_token != T_CL_SQ_BRACKET && p->last_token != T_ID ) ) {
; 1054 :               ( p->index == 0 || ( token[-1].token != T_REG && token[-1].token != T_CL_BRACKET && token[-1].token != T_CL_SQ_BRACKET && token[-1].token != T_ID ) ) ) {

	cmp	al, 46					; 0000002eH
	jne	SHORT $LN5@GetToken
	movsx	ecx, BYTE PTR [rcx+1]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN4@GetToken
	mov	rax, QWORD PTR [rbx]
	movzx	ecx, BYTE PTR [rax+1]
	cmp	cl, 95					; 0000005fH
	je	SHORT $LN4@GetToken
	cmp	cl, 64					; 00000040H
	je	SHORT $LN4@GetToken
	cmp	cl, 36					; 00000024H
	je	SHORT $LN4@GetToken
	cmp	cl, 63					; 0000003fH
	jne	SHORT $LN5@GetToken
$LN4@GetToken:
	cmp	DWORD PTR [rbx+24], 0
	je	SHORT $LN7@GetToken
	movzx	eax, BYTE PTR [rdi-32]
	cmp	al, 2
	je	SHORT $LN5@GetToken
	cmp	al, 41					; 00000029H
	je	SHORT $LN5@GetToken
	cmp	al, 93					; 0000005dH
	je	SHORT $LN5@GetToken
	cmp	al, 8

; 1055 :         return( get_id( token, p ) );

	jne	SHORT $LN7@GetToken
$LN5@GetToken:

; 1056 : #if BACKQUOTES
; 1057 :     } else if( *p->input == '`' && Options.strict_masm_compat == FALSE ) {

	mov	rax, QWORD PTR [rbx]
	cmp	BYTE PTR [rax], 96			; 00000060H
	jne	SHORT $LN1@GetToken
	cmp	BYTE PTR Options+136, 0
	jne	SHORT $LN1@GetToken

; 1058 :         return( get_id_in_backquotes( token, p ) );

	mov	rdx, rbx
	mov	rcx, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 1062 : }

	add	rsp, 40					; 00000028H
	jmp	get_id_in_backquotes
$LN1@GetToken:

; 1059 : #endif
; 1060 :     }
; 1061 :     return( get_special_symbol( token, p ) );

	mov	rdx, rbx
	mov	rcx, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 1062 : }

	add	rsp, 40					; 00000028H
	jmp	get_special_symbol
$LN7@GetToken:

; 1045 :         return( get_id( token, p ) );

	mov	rdx, rbx
	mov	rcx, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 1062 : }

	add	rsp, 40					; 00000028H
	jmp	get_id
GetToken ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$StartComment DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$StartComment DD @imagerel(StartComment#)
	DD	@imagerel(StartComment#+115)
	DD	@imagerel($unwind$StartComment#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
p$ = 48
StartComment PROC NEAR

; 1068 : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1069 :     while ( isspace( *p ) ) p++;

	movsx	ecx, BYTE PTR [rcx]
	call	isspace
	test	eax, eax
	je	SHORT $LN3@StartComme
	npad	11
$LL4@StartComme:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL4@StartComme
$LN3@StartComme:

; 1070 :     if ( *p == NULLC ) {

	movzx	eax, BYTE PTR [rbx]
	test	al, al
	jne	SHORT $LN2@StartComme

; 1071 :         EmitError( COMMENT_DELIMITER_EXPECTED );

	mov	ecx, 98					; 00000062H

; 1076 :         ModuleInfo.inside_comment = NULLC;
; 1077 :     return;
; 1078 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitError
$LN2@StartComme:

; 1072 :         return;
; 1073 :     }
; 1074 :     ModuleInfo.inside_comment = *p++;

	lea	rcx, QWORD PTR [rbx+1]

; 1075 :     if( strchr( p, ModuleInfo.inside_comment ) )

	movzx	edx, al
	mov	BYTE PTR ModuleInfo+407, al
	call	strchr
	movzx	ecx, BYTE PTR ModuleInfo+407
	xor	edx, edx
	test	rax, rax
	cmovne	ecx, edx
	mov	BYTE PTR ModuleInfo+407, cl

; 1076 :         ModuleInfo.inside_comment = NULLC;
; 1077 :     return;
; 1078 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
StartComment ENDP
_TEXT	ENDS
PUBLIC	Tokenize
EXTRN	CurrIfState:DWORD
EXTRN	conditional_assembly_prepare:NEAR
EXTRN	UseSavedState:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	commentbuffer:QWORD
EXTRN	token_stringbuf:QWORD
xdata	SEGMENT
$unwind$Tokenize DD 0f2501H
	DD	09f425H
	DD	0ae421H
	DD	0bd41dH
	DD	0cc419H
	DD	0106415H
	DD	0f5411H
	DD	0e340dH
	DD	0c207H
xdata	ENDS
pdata	SEGMENT
$pdata$Tokenize DD @imagerel($LN114#)
	DD	@imagerel($LN114#+142)
	DD	@imagerel($unwind$Tokenize#)
pdata	ENDS
xdata	SEGMENT
$chain$7$Tokenize DD 020821H
	DD	0117408H
	DD	@imagerel($LN114#)
	DD	@imagerel($LN114#+142)
	DD	@imagerel($unwind$Tokenize#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$Tokenize DD @imagerel($LN114#+142)
	DD	@imagerel($LN114#+1170)
	DD	@imagerel($chain$7$Tokenize#)
pdata	ENDS
xdata	SEGMENT
$chain$8$Tokenize DD 021H
	DD	@imagerel($LN114#)
	DD	@imagerel($LN114#+142)
	DD	@imagerel($unwind$Tokenize#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$Tokenize DD @imagerel($LN114#+1170)
	DD	@imagerel($LN114#+1248)
	DD	@imagerel($chain$8$Tokenize#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
p$ = 32
line$ = 112
start$ = 120
tokenarray$ = 128
flags$ = 136
Tokenize PROC NEAR

; 1089 : {

$LN114:
	mov	rax, rsp
	sub	rsp, 104				; 00000068H

; 1090 :     int                         rc;
; 1091 :     struct line_status          p;
; 1092 : 
; 1093 :     p.input = line;
; 1094 :     p.start = line;
; 1095 :     p.index = start;
; 1096 :     //p.last_token = T_FINAL; /* v2.11: last_token is obsolete */
; 1097 :     p.flags = flags;
; 1098 :     p.flags2 = 0;
; 1099 :     p.flags3 = 0;
; 1100 :     if ( p.index == 0 ) {

	test	edx, edx
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-16], r13
	mov	QWORD PTR [rax-24], r14
	mov	QWORD PTR [rax-32], r15
	mov	r12, r8
	mov	r15d, edx
	mov	r14d, r9d
	mov	r13, rcx
	mov	rbx, rcx
	mov	QWORD PTR [rax-72], rcx
	mov	QWORD PTR [rax-56], rcx
	mov	esi, edx
	mov	DWORD PTR [rax-48], edx
	mov	BYTE PTR [rax-44], r9b
	mov	BYTE PTR [rax-43], 0
	mov	BYTE PTR [rax-42], 0
	jne	SHORT $LN32@Tokenize

; 1101 : #ifdef DEBUG_OUT
; 1102 :         cnttok0++;
; 1103 : #endif
; 1104 :         /* v2.06: these flags are now initialized on a higher level */
; 1105 :         //ModuleInfo.line_flags = 0;
; 1106 :         p.output = token_stringbuf;

	mov	rbp, QWORD PTR token_stringbuf
	mov	QWORD PTR [rax-64], rbp

; 1107 :         if( ModuleInfo.inside_comment ) {

	movzx	eax, BYTE PTR ModuleInfo+407
	test	al, al
	je	SHORT $LN91@Tokenize

; 1108 :             DebugMsg1(("COMMENT active, delim is >%c<, line is >%s<\n", ModuleInfo.inside_comment, line));
; 1109 :             if( strchr( line, ModuleInfo.inside_comment ) != NULL ) {

	movzx	edx, al
	call	strchr
	test	rax, rax
	je	$skipline$5927

; 1110 :                 DebugMsg1(("COMMENT mode exited\n"));
; 1111 :                 ModuleInfo.inside_comment = NULLC;

	mov	BYTE PTR ModuleInfo+407, sil

; 1112 :             }
; 1113 :             goto skipline;

	jmp	$skipline$5927
$LN32@Tokenize:

; 1114 :         }
; 1115 :         /* v2.08: expansion operator % at pos 0 is handled differently.
; 1116 :          */
; 1117 :         //while( isspace( *p.input )) p.input++;
; 1118 :         //if ( *p.input == '%' ) {
; 1119 :         //    *p.input++ = ' ';
; 1120 :         //    expansion = TRUE;
; 1121 :         //}
; 1122 :     } else {
; 1123 : #ifdef DEBUG_OUT
; 1124 :         cnttok1++;
; 1125 : #endif
; 1126 :         p.output = StringBufferEnd;

	mov	rbp, QWORD PTR ModuleInfo+488
	mov	QWORD PTR p$[rsp+8], rbp
$LN91@Tokenize:
	mov	QWORD PTR [rsp+136], rdi
	jmp	SHORT $LL28@Tokenize
	npad	8
$LL97@Tokenize:

; 1219 : #endif
; 1220 : 
; 1221 :     }

	mov	esi, DWORD PTR p$[rsp+24]
	mov	rbp, QWORD PTR p$[rsp+8]
	mov	rbx, QWORD PTR p$[rsp]
	npad	2
$LL28@Tokenize:
	movsx	ecx, BYTE PTR [rbx]
	call	isspace
	test	eax, eax
	je	SHORT $LN25@Tokenize
	npad	4
$LL26@Tokenize:

; 1127 :     }
; 1128 : 
; 1129 :     for( ;; ) {
; 1130 : 
; 1131 :         while( isspace( *p.input ) ) p.input++;

	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL26@Tokenize
	mov	QWORD PTR p$[rsp], rbx
$LN25@Tokenize:

; 1132 : 
; 1133 :         if ( *p.input == ';' && flags == TOK_DEFAULT ) {

	cmp	BYTE PTR [rbx], 59			; 0000003bH
	jne	SHORT $LN24@Tokenize
	test	r14d, r14d
	jne	SHORT $LN24@Tokenize

; 1134 :             while ( p.input > line && isspace( *(p.input-1) ) ) p.input--; /* skip */

	cmp	rbx, r13
	jbe	SHORT $LN22@Tokenize
	npad	12
$LL23@Tokenize:
	movsx	ecx, BYTE PTR [rbx-1]
	lea	rdi, QWORD PTR [rbx-1]
	call	isspace
	test	eax, eax
	je	SHORT $LN106@Tokenize
	cmp	rdi, r13
	mov	rbx, rdi
	ja	SHORT $LL23@Tokenize
$LN106@Tokenize:
	mov	QWORD PTR p$[rsp], rbx
$LN22@Tokenize:

; 1135 :             strcpy( commentbuffer, p.input );

	mov	rdx, QWORD PTR commentbuffer
	mov	rcx, rbx
	npad	8
$LL35@Tokenize:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL35@Tokenize

; 1136 :             ModuleInfo.CurrComment = commentbuffer;

	mov	rax, QWORD PTR commentbuffer
	mov	QWORD PTR ModuleInfo+472, rax

; 1137 :             *p.input = NULLC;

	mov	BYTE PTR [rbx], 0
$LN24@Tokenize:

; 1138 :         }
; 1139 : 
; 1140 :         tokenarray[p.index].tokpos = p.input;

	mov	edi, esi
	shl	rdi, 5
	add	rdi, r12
	mov	QWORD PTR [rdi+24], rbx

; 1141 :         if( *p.input == NULLC ) {

	cmp	BYTE PTR [rbx], 0
	jne	$LN21@Tokenize

; 1142 :             /* if a comma is last token, concat lines ... with some exceptions
; 1143 :              * v2.05: moved from PreprocessLine(). Moved because the
; 1144 :              * concatenation may be triggered by a comma AFTER expansion.
; 1145 :              */
; 1146 :             if ( p.index > 1 &&
; 1147 :                 tokenarray[p.index-1].token == T_COMMA
; 1148 : #if FASTPASS
; 1149 :                 && ( Parse_Pass == PASS_1 || UseSavedState == FALSE ) /* is it an already preprocessed line? */
; 1150 : #endif
; 1151 :                 && start == 0 ) {

	cmp	esi, 1
	jbe	$LN71@Tokenize
	lea	ecx, DWORD PTR [rsi-1]
	shl	rcx, 5
	cmp	BYTE PTR [rcx+r12], 44			; 0000002cH
	jne	$LN71@Tokenize
	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN19@Tokenize
	cmp	BYTE PTR UseSavedState, 0
	jne	$LN71@Tokenize
$LN19@Tokenize:
	test	r15d, r15d
	jne	$LN71@Tokenize

; 1152 :                 DebugMsg1(("Tokenize: calling IsMultiLine()\n" ));
; 1153 :                 if ( IsMultiLine( tokenarray ) ) {

	movzx	ecx, BYTE PTR [r12+32]
	cmp	cl, 3
	jne	SHORT $LN43@Tokenize
	cmp	DWORD PTR [r12+48], 448			; 000001c0H
	je	$LN71@Tokenize
$LN43@Tokenize:
	xor	eax, eax
	cmp	cl, 58					; 0000003aH
	mov	ecx, 2
	cmove	eax, ecx
	movsxd	rcx, eax
	shl	rcx, 5
	movzx	eax, BYTE PTR [rcx+r12]
	cmp	al, 8
	jne	SHORT $LN42@Tokenize
	mov	rcx, QWORD PTR [rcx+r12+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN39@Tokenize
	cmp	DWORD PTR [rax+40], 9
	jne	SHORT $LN39@Tokenize
	test	BYTE PTR [rax+52], 8
	je	$LN71@Tokenize
	jmp	SHORT $LN39@Tokenize
$LN42@Tokenize:
	cmp	al, 1
	je	$LN71@Tokenize
	cmp	al, 3
	jne	SHORT $LN39@Tokenize
	mov	eax, DWORD PTR [rcx+r12+16]
	cmp	eax, 446				; 000001beH
	je	$LN71@Tokenize
	cmp	eax, 402				; 00000192H
	je	$LN71@Tokenize
	cmp	eax, 391				; 00000187H
	je	$LN71@Tokenize
	cmp	eax, 393				; 00000189H
	je	$LN71@Tokenize
$LN39@Tokenize:

; 1154 :                     char *ptr = GetAlignedPointer( p.output, strlen( p.output ) );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbp
	repne scasb
	not	rcx
	lea	rdi, QWORD PTR [rcx+7]
	and	rdi, -8
	add	rdi, rbp

; 1155 :                     DebugMsg1(("Tokenize: IsMultiLine(%s)=TRUE\n", line ));
; 1156 :                     if ( GetTextLine( ptr ) ) {

	mov	rcx, rdi
	call	GetTextLine
	test	rax, rax
	je	$LN71@Tokenize

; 1157 :                         while ( isspace( *ptr ) ) ptr++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN15@Tokenize
	npad	1
$LL16@Tokenize:
	movsx	ecx, BYTE PTR [rdi+1]
	inc	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL16@Tokenize
$LN15@Tokenize:

; 1158 :                         if ( *ptr ) {

	cmp	BYTE PTR [rdi], 0
	je	$LN71@Tokenize

; 1159 :                             strcpy( p.input, ptr );

	mov	rcx, rbx
	sub	rcx, rdi
	npad	1
$LL36@Tokenize:
	movzx	eax, BYTE PTR [rdi]
	inc	rdi
	test	al, al
	mov	BYTE PTR [rcx+rdi-1], al
	jne	SHORT $LL36@Tokenize

; 1160 :                             if ( strlen( p.start ) >= MAX_LINE_LEN ) {

	mov	rdi, QWORD PTR p$[rsp+16]
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	cmp	rcx, 1024				; 00000400H
	jb	$LL28@Tokenize

; 1161 :                                 EmitError( LINE_TOO_LONG );

	lea	ecx, QWORD PTR [rax+61]
	call	EmitError

; 1162 :                                 p.index = start;

	xor	esi, esi

; 1163 :                                 break;

	jmp	$LN71@Tokenize
$LN21@Tokenize:

; 1164 :                             }
; 1165 :                             DebugMsg1(("Tokenize: line concatenation, line=%s\n", line ));
; 1166 :                             continue;
; 1167 :                         }
; 1168 :                     }
; 1169 :                 }
; 1170 :             }
; 1171 :             break;
; 1172 :         }
; 1173 :         tokenarray[p.index].string_ptr = p.output;

	mov	QWORD PTR [rdi+8], rbp

; 1174 :         rc = GetToken( &tokenarray[p.index], &p );

	movsx	ecx, BYTE PTR [rbx]
	call	isdigit
	test	eax, eax
	je	SHORT $LN55@Tokenize
	lea	rdx, QWORD PTR p$[rsp]
	mov	rcx, rdi
	call	get_number
	jmp	$LN56@Tokenize
$LN55@Tokenize:
	movsx	ecx, BYTE PTR [rbx]
	call	isalpha
	test	eax, eax
	jne	$LN52@Tokenize
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	$LN52@Tokenize
	cmp	al, 64					; 00000040H
	je	$LN52@Tokenize
	cmp	al, 36					; 00000024H
	je	SHORT $LN52@Tokenize
	cmp	al, 63					; 0000003fH
	je	SHORT $LN52@Tokenize
	cmp	al, 46					; 0000002eH
	jne	SHORT $LN50@Tokenize
	movsx	ecx, BYTE PTR [rbx+1]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN49@Tokenize
	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN49@Tokenize
	cmp	al, 64					; 00000040H
	je	SHORT $LN49@Tokenize
	cmp	al, 36					; 00000024H
	je	SHORT $LN49@Tokenize
	cmp	al, 63					; 0000003fH
	jne	SHORT $LN50@Tokenize
$LN49@Tokenize:
	test	esi, esi
	je	SHORT $LN48@Tokenize
	movzx	eax, BYTE PTR [rdi-32]
	cmp	al, 2
	je	SHORT $LN50@Tokenize
	cmp	al, 41					; 00000029H
	je	SHORT $LN50@Tokenize
	cmp	al, 93					; 0000005dH
	je	SHORT $LN50@Tokenize
	cmp	al, 8
	je	SHORT $LN50@Tokenize
$LN48@Tokenize:
	lea	rdx, QWORD PTR p$[rsp]
	mov	rcx, rdi
	call	get_id
	jmp	SHORT $LN56@Tokenize
$LN50@Tokenize:
	cmp	BYTE PTR [rbx], 96			; 00000060H
	jne	SHORT $LN46@Tokenize
	cmp	BYTE PTR Options+136, 0
	jne	SHORT $LN46@Tokenize
	lea	rdx, QWORD PTR p$[rsp]
	mov	rcx, rdi
	call	get_id_in_backquotes
	jmp	SHORT $LN56@Tokenize
$LN46@Tokenize:
	lea	rdx, QWORD PTR p$[rsp]
	mov	rcx, rdi
	call	get_special_symbol
	jmp	SHORT $LN56@Tokenize
$LN52@Tokenize:
	lea	rdx, QWORD PTR p$[rsp]
	mov	rcx, rdi
	call	get_id
$LN56@Tokenize:

; 1175 :         if ( rc == EMPTY )

	cmp	eax, -2
	je	$LL97@Tokenize

; 1176 :             continue;
; 1177 :         if ( rc == ERROR ) {

	cmp	eax, -1
	je	$LN68@Tokenize

; 1180 :         }
; 1181 :         /* v2.04: this has been moved here from condasm.c to
; 1182 :          * avoid problems with (conditional) listings. It also
; 1183 :          * avoids having to search for the first token twice.
; 1184 :          * Note: a conditional assembly directive within an
; 1185 :          *    inactive block and preceded by a label isn't detected!
; 1186 :          *    This is an exact copy of the Masm behavior, although
; 1187 :          *    it probably is just a bug!
; 1188 :          */
; 1189 :         if ( !(flags & TOK_RESCAN) ) {

	test	r14b, 1
	mov	esi, DWORD PTR p$[rsp+24]
	jne	SHORT $LN2@Tokenize

; 1190 :             if ( p.index == 0 || ( p.index == 2 && ( tokenarray[1].token == T_COLON || tokenarray[1].token == T_DBL_COLON) ) ) {

	test	esi, esi
	je	SHORT $LN7@Tokenize
	cmp	esi, 2
	jne	SHORT $LN2@Tokenize
	movzx	eax, BYTE PTR [r12+32]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN7@Tokenize
	cmp	al, 13
	jne	SHORT $LN2@Tokenize
$LN7@Tokenize:

; 1191 :                 if ( tokenarray[p.index].token == T_DIRECTIVE &&
; 1192 :                     tokenarray[p.index].bytval == DRT_CONDDIR ) {

	mov	rax, rsi
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 3
	jne	SHORT $LN6@Tokenize
	cmp	BYTE PTR [rax+r12+1], 0
	jne	SHORT $LN6@Tokenize

; 1193 :                     if ( tokenarray[p.index].tokval == T_COMMENT ) {

	mov	ecx, DWORD PTR [rax+r12+16]
	cmp	ecx, 363				; 0000016bH
	je	SHORT $LN69@Tokenize

; 1197 :                     }
; 1198 :                     conditional_assembly_prepare( tokenarray[p.index].tokval );

	call	conditional_assembly_prepare

; 1199 :                     if ( CurrIfState != BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, 0
	je	SHORT $LN2@Tokenize

; 1200 :                         p.index++;

	mov	rbp, QWORD PTR p$[rsp+8]
	inc	esi
	jmp	SHORT $LN71@Tokenize
$LN6@Tokenize:

; 1201 :                         break; /* p.index is 1 or 3 */
; 1202 :                     }
; 1203 :                 } else if( CurrIfState != BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, 0
	jne	SHORT $LN98@Tokenize
$LN2@Tokenize:

; 1204 :                     /* further processing skipped. p.index is 0 */
; 1205 :                     break;
; 1206 :                 }
; 1207 :             }
; 1208 :         }
; 1209 :         p.index++;

	inc	esi

; 1210 :         if( p.index >= MAX_TOKEN ) {

	cmp	esi, 256				; 00000100H
	mov	DWORD PTR p$[rsp+24], esi
	jae	SHORT $LN72@Tokenize

; 1214 :             goto skipline;
; 1215 :         }
; 1216 : 
; 1217 : #if TOKSTRALIGN
; 1218 :         p.output = GetAlignedPointer( token_stringbuf, p.output - token_stringbuf );

	mov	rbp, QWORD PTR p$[rsp+8]
	mov	rax, QWORD PTR token_stringbuf

; 1219 : #endif
; 1220 : 
; 1221 :     }

	mov	rbx, QWORD PTR p$[rsp]
	sub	rbp, rax
	add	rbp, 8
	and	rbp, -8
	add	rbp, rax
	mov	QWORD PTR p$[rsp+8], rbp
	jmp	$LL28@Tokenize
$LN68@Tokenize:

; 1178 :             p.index = start; /* skip this line */
; 1179 :             break;

	mov	rbp, QWORD PTR p$[rsp+8]
	mov	esi, r15d
	jmp	SHORT $LN71@Tokenize
$LN69@Tokenize:

; 1194 :                         DebugMsg1(("tokenize: COMMENT starting, delim is >%c<\n", ModuleInfo.inside_comment));
; 1195 :                         StartComment( p.input );

	mov	rcx, QWORD PTR p$[rsp]
	call	StartComment

; 1196 :                         break; /* p.index is 0 or 2 */

	mov	rbp, QWORD PTR p$[rsp+8]
	jmp	SHORT $LN71@Tokenize
$LN98@Tokenize:

; 1200 :                         p.index++;

	mov	rbp, QWORD PTR p$[rsp+8]
$LN71@Tokenize:

; 1222 : #if TOKSTRALIGN
; 1223 :     p.output = GetAlignedPointer( token_stringbuf, p.output - token_stringbuf );
; 1224 : #endif
; 1225 :     StringBufferEnd = p.output;

	mov	rax, QWORD PTR token_stringbuf
	sub	rbp, rax
	add	rbp, 8
	and	rbp, -8
	add	rbp, rax
	mov	QWORD PTR ModuleInfo+488, rbp
	jmp	SHORT $LN113@Tokenize
$LN72@Tokenize:

; 1211 :             DebugMsg1(("tokenize: token index %u >= MAX_TOKEN (=%u), line=>%s<\n", p.index, MAX_TOKEN, line ));
; 1212 :             EmitError( TOO_MANY_TOKENS );

	mov	ecx, 62					; 0000003eH
	call	EmitError

; 1213 :             p.index = start;

	mov	esi, r15d
$LN113@Tokenize:
	mov	rdi, QWORD PTR [rsp+136]
$skipline$5927:

; 1226 : skipline:
; 1227 :     tokenarray[p.index].token  = T_FINAL;
; 1228 :     tokenarray[p.index].bytval = p.flags3;

	movzx	ecx, BYTE PTR p$[rsp+30]
	mov	r15, QWORD PTR [rsp+72]
	mov	r14, QWORD PTR [rsp+80]
	mov	r13, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+112]
	mov	edx, esi

; 1229 :     tokenarray[p.index].string_ptr = "";

	lea	rax, OFFSET FLAT:$SG5968
	shl	rdx, 5
	mov	BYTE PTR [rdx+r12], 0
	mov	BYTE PTR [rdx+r12+1], cl
	mov	QWORD PTR [rdx+r12+8], rax
	mov	r12, QWORD PTR [rsp+96]

; 1230 :     return( p.index );

	mov	eax, esi
	mov	rsi, QWORD PTR [rsp+128]

; 1231 : }

	add	rsp, 104				; 00000068H
	ret	0
Tokenize ENDP
_TEXT	ENDS
END
