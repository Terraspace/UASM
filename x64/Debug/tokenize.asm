; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11300 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	cnttok0:DWORD
COMM	cnttok1:DWORD
_DATA	ENDS
CONST	SEGMENT
stokstr1 DW	028H
	DW	029H
	DW	02aH
	DW	02bH
	DW	02cH
	DW	02dH
	DW	02eH
	DW	02fH
stokstr2 DW	05bH
	DW	00H
	DW	05dH
CONST	ENDS
_DATA	SEGMENT
$SG11272 DB	'COMMENT active, delim is >%c<, line is >%s<', 0aH, 00H
	ORG $+3
$SG11274 DB	'COMMENT mode exited', 0aH, 00H
	ORG $+3
$SG11279 DB	'Tokenize: calling IsMultiLine()', 0aH, 00H
	ORG $+3
$SG10913 DB	'1to16', 00H
	ORG $+2
$SG11085 DB	'::', 00H
	ORG $+1
$SG11281 DB	'Tokenize: IsMultiLine(%s)=TRUE', 0aH, 00H
$SG11285 DB	'Tokenize: line concatenation, line=%s', 0aH, 00H
	ORG $+1
$SG11295 DB	'tokenize: COMMENT starting, delim is >%c<', 0aH, 00H
	ORG $+1
$SG11086 DB	':', 00H
	ORG $+2
$SG11299 DB	'tokenize: token index %u >= MAX_TOKEN (=%u), line=>%s<', 0aH
	DB	00H
$SG10904 DB	'1to2', 00H
	ORG $+3
$SG10907 DB	'1to4', 00H
	ORG $+3
$SG10910 DB	'1to8', 00H
	ORG $+3
$SG11053 DB	'Tokenize.get_string: comma concatenation: %s', 0aH, 00H
	ORG $+2
$SG11061 DB	'Tokenize.get_string: backslash concatenation: >%s<', 0aH
	DB	00H
$SG11089 DB	'OUT', 00H
$SG11091 DB	'%', 00H
	ORG $+2
$SG11103 DB	'=', 00H
	ORG $+2
$SG11106 DB	'=!<>&|', 0a6H, 00H
$SG11113 DB	'&', 00H
	ORG $+6
$SG11164 DB	'get_number: BAD_NUMBER (%s), radix=%u, base=%u, ptr=>%s<'
	DB	', digits_seen=%Xh', 0aH, 00H
	ORG $+1
$SG11199 DB	'?', 00H
	ORG $+2
$SG11215 DB	'get_id: error, unknown type in SpecialTable[%u]=%u', 0aH
	DB	00H
	ORG $+4
$SG11216 DB	'tokenize.c', 00H
_DATA	ENDS
PUBLIC	GetToken
PUBLIC	Tokenize
PUBLIC	get_broads
PUBLIC	get_decos
EXTRN	__imp_isalpha:PROC
EXTRN	__imp_isdigit:PROC
EXTRN	__imp_isspace:PROC
EXTRN	__imp_isalnum:PROC
EXTRN	memcpy:PROC
EXTRN	__imp_strchr:PROC
EXTRN	__imp__memicmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	SymFind:PROC
EXTRN	conditional_assembly_prepare:PROC
EXTRN	FindResWord:PROC
EXTRN	GetTextLine:PROC
EXTRN	InternalError:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	_RTC_UninitUse:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	InstrTable:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	optable_idx:BYTE
EXTRN	CurrIfState:DWORD
EXTRN	UseSavedState:BYTE
EXTRN	token_stringbuf:QWORD
EXTRN	commentbuffer:QWORD
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$GetToken DD imagerel $LN13
	DD	imagerel $LN13+494
	DD	imagerel $unwind$GetToken
$pdata$Tokenize DD imagerel $LN36
	DD	imagerel $LN36+1426
	DD	imagerel $unwind$Tokenize
$pdata$IsMultiLine DD imagerel IsMultiLine
	DD	imagerel IsMultiLine+391
	DD	imagerel $unwind$IsMultiLine
$pdata$get_broads DD imagerel $LN14
	DD	imagerel $LN14+368
	DD	imagerel $unwind$get_broads
$pdata$get_decos DD imagerel $LN25
	DD	imagerel $LN25+915
	DD	imagerel $unwind$get_decos
$pdata$get_float DD imagerel get_float
	DD	imagerel get_float+415
	DD	imagerel $unwind$get_float
$pdata$ConcatLine DD imagerel ConcatLine
	DD	imagerel ConcatLine+376
	DD	imagerel $unwind$ConcatLine
$pdata$get_string DD imagerel get_string
	DD	imagerel get_string+2265
	DD	imagerel $unwind$get_string
$pdata$get_special_symbol DD imagerel get_special_symbol
	DD	imagerel get_special_symbol+1633
	DD	imagerel $unwind$get_special_symbol
$pdata$get_number DD imagerel get_number
	DD	imagerel get_number+1652
	DD	imagerel $unwind$get_number
$pdata$get_id_in_backquotes DD imagerel get_id_in_backquotes
	DD	imagerel get_id_in_backquotes+290
	DD	imagerel $unwind$get_id_in_backquotes
$pdata$get_id DD imagerel get_id
	DD	imagerel get_id+1160
	DD	imagerel $unwind$get_id
$pdata$StartComment DD imagerel StartComment
	DD	imagerel StartComment+154
	DD	imagerel $unwind$StartComment
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
	ORG $+2
Tokenize$rtcName$0 DB 070H
	DB	00H
	ORG $+6
Tokenize$rtcVarDesc DD 038H
	DD	020H
	DQ	FLAT:Tokenize$rtcName$0
	ORG $+48
Tokenize$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:Tokenize$rtcVarDesc
get_number$rtcName$0 DB 064H
	DB	069H
	DB	067H
	DB	05fH
	DB	065H
	DB	06eH
	DB	064H
	DB	00H
CONST	ENDS
xdata	SEGMENT
$unwind$GetToken DD 022301H
	DD	0700b320fH
$unwind$Tokenize DD 022f01H
	DD	07014d218H
$unwind$IsMultiLine DD 021e01H
	DD	07006520aH
$unwind$get_broads DD 021e01H
	DD	07006520aH
$unwind$get_decos DD 021e01H
	DD	07006520aH
$unwind$get_float DD 022301H
	DD	0700b720fH
$unwind$ConcatLine DD 022c01H
	DD	070147218H
$unwind$get_string DD 022601H
	DD	0700bd20fH
$unwind$get_special_symbol DD 022301H
	DD	0700b720fH
$unwind$get_number DD 032901H
	DD	0120112H
	DD	0700bH
$unwind$get_id_in_backquotes DD 022301H
	DD	0700b520fH
$unwind$get_id DD 022301H
	DD	0700b720fH
$unwind$StartComment DD 021e01H
	DD	07006320aH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
p$ = 48
StartComment PROC

; 1061 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]
$LN2@StartComme:

; 1062 :     while ( isspace( *p ) ) p++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN3@StartComme
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN2@StartComme
$LN3@StartComme:

; 1063 :     if ( *p == NULLC ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN4@StartComme

; 1064 :         EmitError( COMMENT_DELIMITER_EXPECTED );

	mov	ecx, 98					; 00000062H
	call	EmitError

; 1065 :         return;

	jmp	SHORT $LN1@StartComme
$LN4@StartComme:

; 1066 :     }
; 1067 :     ModuleInfo.inside_comment = *p++;

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR ModuleInfo+407, al
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 1068 :     if( strchr( p, ModuleInfo.inside_comment ) )

	movzx	eax, BYTE PTR ModuleInfo+407
	mov	edx, eax
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp_strchr
	test	rax, rax
	je	SHORT $LN5@StartComme

; 1069 :         ModuleInfo.inside_comment = NULLC;

	mov	BYTE PTR ModuleInfo+407, 0
$LN5@StartComme:
$LN1@StartComme:

; 1070 :     return;
; 1071 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
StartComment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
src$ = 32
dst$ = 40
index$ = 48
size$ = 52
tv195 = 56
buf$ = 80
p$ = 88
get_id	PROC

; 848  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 849  :     //struct ReservedWord *resw;
; 850  :     char *src = p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR src$[rsp], rax

; 851  :     char *dst = p->output;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR dst$[rsp], rax
$LN30@get_id:
$LN29@get_id:
$LN28@get_id:
$LN27@get_id:
$LN4@get_id:

; 852  :     int  index;
; 853  :     unsigned size;
; 854  : 
; 855  : #if CONCATID || DOTNAMEX
; 856  : continue_scan:
; 857  : #endif
; 858  :     do {
; 859  :         *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 860  :     } while ( is_valid_id_char( *src ) );

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	SHORT $LN4@get_id
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN27@get_id
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN28@get_id
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN29@get_id
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN30@get_id

; 861  : #if CONCATID
; 862  :     /* v2.05: in case there's a backslash right behind
; 863  :      * the ID, check if a line concatenation is to occur.
; 864  :      * If yes, and the first char of the concatenated line
; 865  :      * is also a valid ID char, continue to scan the name.
; 866  :      * Problem: it's ok for EQU, but less good for other directives.
; 867  :      */
; 868  :     if ( *src == '\\' ) {
; 869  :         if ( ConcatLine( src, src - p->input, dst, p ) != EMPTY ) {
; 870  :             p->concat = TRUE;
; 871  :             if ( is_valid_id_char( *src ) )
; 872  :                 goto continue_scan;
; 873  :         }
; 874  :     }
; 875  : #endif
; 876  : #if DOTNAMEX
; 877  :     /* if the name starts with a dot or underscore, then accept dots
; 878  :      * within the name (though not as last char). OPTION DOTNAME
; 879  :      * must be on.
; 880  :      */
; 881  :     if ( *src == '.' && ModuleInfo.dotname &&
; 882  :         ( *(p->output) == '.' || *(p->output) == '_' ) &&
; 883  :         ( is_valid_id_char(*(src+1)) || *(src+1) == '.' ) )
; 884  :         goto continue_scan;
; 885  : #endif
; 886  :     /* v2.04: check added */
; 887  :     size = dst - p->output;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR dst$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR size$[rsp], eax

; 888  :     if ( size > MAX_ID_LEN ) {

	cmp	DWORD PTR size$[rsp], 247		; 000000f7H
	jbe	SHORT $LN9@get_id

; 889  :         EmitErr( IDENTIFIER_TOO_LONG );

	mov	ecx, 70					; 00000046H
	call	EmitErr

; 890  :         dst = p->output + MAX_ID_LEN;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 247				; 000000f7H
	mov	QWORD PTR dst$[rsp], rax
$LN9@get_id:

; 891  :     }
; 892  :     *dst++ = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 893  : 
; 894  :     /* now decide what to do with it */
; 895  : 
; 896  :     if( size == 1 && *p->output == '?' ) {

	cmp	DWORD PTR size$[rsp], 1
	jne	SHORT $LN10@get_id
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN10@get_id

; 897  :         p->input = src;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	QWORD PTR [rax], rcx

; 898  :         buf->token = T_QUESTION_MARK;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 63			; 0000003fH

; 899  :         buf->string_ptr = "?";

	mov	rax, QWORD PTR buf$[rsp]
	lea	rcx, OFFSET FLAT:$SG11199
	mov	QWORD PTR [rax+8], rcx

; 900  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_id
$LN10@get_id:

; 901  :     }
; 902  :     index = FindResWord( p->output, size );

	movzx	edx, BYTE PTR size$[rsp]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	FindResWord
	mov	DWORD PTR index$[rsp], eax

; 903  :     if( index == 0 ) {

	cmp	DWORD PTR index$[rsp], 0
	jne	$LN11@get_id

; 904  :         /* if ID begins with a DOT, check for OPTION DOTNAME.
; 905  :          * if not set, skip the token and return a T_DOT instead!
; 906  :          */
; 907  :         if ( *p->output == '.' && ModuleInfo.dotname == FALSE ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN12@get_id
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN12@get_id

; 908  :            buf->token = T_DOT;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH

; 909  :            buf->string_ptr = (char *)&stokstr1['.' - '('];

	mov	eax, 2
	imul	rax, rax, 6
	lea	rcx, OFFSET FLAT:stokstr1
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR buf$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 910  :            p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 911  :            return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_id
$LN12@get_id:

; 912  :         }
; 913  :         p->input = src;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	QWORD PTR [rax], rcx

; 914  :         p->output = dst;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 915  :         buf->token = T_ID;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 8

; 916  :         buf->idarg = 0;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 0

; 917  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_id
$LN11@get_id:

; 918  :     }
; 919  :     p->input = src;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	QWORD PTR [rax], rcx

; 920  :     p->output = dst;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 921  :     buf->tokval = index; /* is a enum instr_token value */

	mov	rax, QWORD PTR buf$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 922  :     /* v2.11: RWF_SPECIAL now obsolete */
; 923  :     //if ( ! ( ResWordTable[index].flags & RWF_SPECIAL ) ) {
; 924  :     if ( index >= SPECIAL_LAST ) {

	cmp	DWORD PTR index$[rsp], 450		; 000001c2H
	jl	$LN13@get_id

; 925  : 
; 926  :         //  DebugMsg(("found item >%s< in instruction table, rm=%X\n", buf->string_ptr, InstrTable[index].rm_byte));
; 927  : 
; 928  :         /* if -Zm is set, the following from the Masm docs is relevant:
; 929  :          *
; 930  :          * Reserved Keywords Dependent on CPU Mode with OPTION M510
; 931  :          *
; 932  :          * With OPTION M510, keywords and instructions not available in the
; 933  :          * current CPU mode (such as ENTER under .8086) are not treated as
; 934  :          * keywords. This also means the USE32, FLAT, FAR32, and NEAR32 segment
; 935  :          * types and the 80386/486 registers are not keywords with a processor
; 936  :          * selection less than .386.
; 937  :          * If you remove OPTION M510, any reserved word used as an identifier
; 938  :          * generates a syntax error. You can either rename the identifiers or
; 939  :          * use OPTION NOKEYWORD. For more information on OPTION NOKEYWORD, see
; 940  :          * OPTION NOKEYWORD, later in this appendix.
; 941  :          *
; 942  :          * The current implementation of this rule below is likely to be improved.
; 943  :          */
; 944  :         if ( ModuleInfo.m510 ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 6
	and	eax, 1
	test	eax, eax
	je	$LN14@get_id

; 945  :             /* checking the cpu won't give the expected results currently since
; 946  :              * some instructions in the table (i.e. MOV) start with a 386 variant!
; 947  :              */
; 948  :             index = IndexFromToken( buf->tokval );

	mov	rax, QWORD PTR buf$[rsp]
	mov	eax, DWORD PTR [rax+16]
	sub	eax, 450				; 000001c2H
	mov	eax, eax
	lea	rcx, OFFSET FLAT:optable_idx
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	DWORD PTR index$[rsp], eax

; 949  : #if 0 /* changed for v1.96 */
; 950  :             if (( InstrTable[index].cpu & P_EXT_MASK ) > ( ModuleInfo.curr_cpu & P_EXT_MASK )) {
; 951  : #else
; 952  :             if (( InstrTable[index].cpu & P_CPU_MASK ) > ( ModuleInfo.curr_cpu & P_CPU_MASK ) ||

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 10
	lea	rcx, OFFSET FLAT:InstrTable
	movzx	eax, WORD PTR [rcx+rax+6]
	and	eax, 240				; 000000f0H
	mov	ecx, DWORD PTR ModuleInfo+392
	and	ecx, 240				; 000000f0H
	cmp	eax, ecx
	jg	SHORT $LN16@get_id
	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 10
	lea	rcx, OFFSET FLAT:InstrTable
	movzx	eax, WORD PTR [rcx+rax+6]
	and	eax, 65280				; 0000ff00H
	mov	ecx, DWORD PTR ModuleInfo+392
	and	ecx, 65280				; 0000ff00H
	cmp	eax, ecx
	jle	SHORT $LN15@get_id
$LN16@get_id:

; 953  :                 ( InstrTable[index].cpu & P_EXT_MASK ) > ( ModuleInfo.curr_cpu & P_EXT_MASK )) {
; 954  : #endif
; 955  :                 buf->token = T_ID;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 8

; 956  :                 buf->idarg = 0;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 0

; 957  :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_id
$LN15@get_id:
$LN14@get_id:

; 958  :             }
; 959  :         }
; 960  :         buf->token = T_INSTRUCTION;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 1

; 961  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_id
$LN13@get_id:

; 962  :     }
; 963  :     index = buf->tokval;

	mov	rax, QWORD PTR buf$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR index$[rsp], eax

; 964  : 
; 965  :     /* for RWT_SPECIAL, field <bytval> contains further infos:
; 966  :      - RWT_REG:             register number (regnum)
; 967  :      - RWT_DIRECTIVE:       type of directive (dirtype)
; 968  :      - RWT_UNARY_OPERATOR:  operator precedence
; 969  :      - RWT_BINARY_OPERATOR: operator precedence
; 970  :      - RWT_STYPE:           memtype
; 971  :      - RWT_RES_ID:          for languages, LANG_xxx value
; 972  :                             for the rest, unused.
; 973  :      */
; 974  :     buf->bytval = SpecialTable[index].bytval;

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	rdx, QWORD PTR buf$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR [rdx+1], al

; 975  : 
; 976  :     switch ( SpecialTable[index].type ) {

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+11]
	mov	DWORD PTR tv195[rsp], eax
	mov	eax, DWORD PTR tv195[rsp]
	sub	eax, 2
	mov	DWORD PTR tv195[rsp], eax
	cmp	DWORD PTR tv195[rsp], 5
	ja	$LN25@get_id
	movsxd	rax, DWORD PTR tv195[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN31@get_id[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN17@get_id:

; 977  :     case RWT_REG:
; 978  :         buf->token = T_REG;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 2
$LN7@get_id:

; 979  : #if AVXSUPP 
; 980  :         /* Intercept here '{' for EVEX mask  {k1}{z} */
; 981  :         while ( isspace( *p->input )) p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN8@get_id
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN7@get_id
$LN8@get_id:

; 982  :         if (*p->input == '{'){

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN18@get_id

; 983  :           p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 984  :           get_decos( p ) ; // mask decorators

	mov	rcx, QWORD PTR p$[rsp]
	call	get_decos
$LN18@get_id:

; 985  :       }
; 986  : #endif        
; 987  :         break;

	jmp	$LN5@get_id
$LN19@get_id:

; 988  :     case RWT_DIRECTIVE:
; 989  :         buf->token = T_DIRECTIVE;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 3

; 990  :         if ( p->flags2 == 0 )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+29]
	test	eax, eax
	jne	SHORT $LN20@get_id

; 991  :             p->flags2 = SpecialTable[index].value;

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdx+29], al
$LN20@get_id:

; 992  :         break;

	jmp	SHORT $LN5@get_id
$LN21@get_id:

; 993  :     case RWT_UNARY_OP: /* OFFSET, LOW, HIGH, LOWWORD, HIGHWORD, SHORT, ... */
; 994  :         buf->token  = T_UNARY_OPERATOR;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 4

; 995  :         break;

	jmp	SHORT $LN5@get_id
$LN22@get_id:

; 996  :     case RWT_BINARY_OP: /* GE, GT, LE, LT, EQ, NE, MOD, PTR */
; 997  :         buf->token = T_BINARY_OPERATOR;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 5

; 998  :         break;

	jmp	SHORT $LN5@get_id
$LN23@get_id:

; 999  :     case RWT_STYPE:  /* BYTE, WORD, FAR, NEAR, FAR16, NEAR32 ... */
; 1000 :         buf->token = T_STYPE;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 6

; 1001 :         break;

	jmp	SHORT $LN5@get_id
$LN24@get_id:

; 1002 :     case RWT_RES_ID: /* DUP, ADDR, FLAT, VARARG, language types [, FRAME (64-bit)] */
; 1003 :         buf->token = T_RES_ID;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 7

; 1004 :         break;

	jmp	SHORT $LN5@get_id
$LN25@get_id:

; 1005 :     default: /* shouldn't happen */
; 1006 :         DebugMsg(("get_id: error, unknown type in SpecialTable[%u]=%u\n", index, SpecialTable[index].type ));

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+11]
	mov	r8d, eax
	mov	edx, DWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:$SG11215
	call	DoDebugMsg

; 1007 :         /**/myassert( 0 );

	mov	edx, 1007				; 000003efH
	lea	rcx, OFFSET FLAT:$SG11216
	call	InternalError

; 1008 :         buf->token = T_ID;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 8

; 1009 :         buf->idarg = 0;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 0
$LN5@get_id:

; 1010 :         break;
; 1011 :     }
; 1012 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@get_id:

; 1013 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
	npad	3
$LN31@get_id:
	DD	$LN17@get_id
	DD	$LN19@get_id
	DD	$LN21@get_id
	DD	$LN22@get_id
	DD	$LN23@get_id
	DD	$LN24@get_id
get_id	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
optr$ = 32
buf$ = 64
p$ = 72
get_id_in_backquotes PROC

; 823  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 824  :     char *optr = p->output;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR optr$[rsp], rax

; 825  :     buf->token = T_ID;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 8

; 826  :     buf->idarg = 0;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 0

; 827  : 
; 828  :     p->input++;         /* strip off the backquotes */

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
$LN2@get_id_in_:

; 829  :     for( ; *p->input != '`'; ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 96					; 00000060H
	je	SHORT $LN3@get_id_in_

; 830  :         if( *p->input == NULLC || *p->input == ';' ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN6@get_id_in_
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN5@get_id_in_
$LN6@get_id_in_:

; 831  :             *p->output = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax], 0

; 832  :             EmitErr( BACKQUOTE_MISSING, p->output );

	mov	rax, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 97					; 00000061H
	call	EmitErr

; 833  :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@get_id_in_
$LN5@get_id_in_:

; 834  :         }
; 835  :         *optr++ = *p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR optr$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR optr$[rsp]
	inc	rax
	mov	QWORD PTR optr$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 836  :     }

	jmp	$LN2@get_id_in_
$LN3@get_id_in_:

; 837  :     p->input++;         /* skip the terminating '`' */

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 838  :     *optr++ = NULLC;

	mov	rax, QWORD PTR optr$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR optr$[rsp]
	inc	rax
	mov	QWORD PTR optr$[rsp], rax

; 839  :     p->output = optr;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR optr$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 840  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@get_id_in_:

; 841  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
get_id_in_backquotes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
ptr$ = 48
dig_start$ = 56
dig_end$ = 64
base$ = 72
len$ = 76
digits_seen$ = 80
last_char$ = 84
tmp$2 = 88
max$3 = 96
$T4 = 97
tv78 = 100
tv286 = 104
tv129 = 108
tv297 = 112
tv148 = 116
tv173 = 120
tv323 = 124
tv184 = 128
tv195 = 132
tv335 = 136
buf$ = 160
p$ = 168
get_number PROC

; 666  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 144				; 00000090H
	mov	rdi, rsp
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+160]
	mov	BYTE PTR $T4[rsp], 0

; 667  :     char                *ptr = p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ptr$[rsp], rax

; 668  :     char                *dig_start;
; 669  :     char                *dig_end;
; 670  :     unsigned            base = 0;

	mov	DWORD PTR base$[rsp], 0

; 671  :     unsigned            len;
; 672  :     uint_32             digits_seen;
; 673  :     char                last_char;
; 674  : 
; 675  : #define VALID_BINARY    0x0003
; 676  : #define VALID_OCTAL     0x00ff
; 677  : #define VALID_DECIMAL   0x03ff
; 678  : #define OK_NUM( t )     ((digits_seen & ~VALID_##t) == 0)
; 679  : 
; 680  :     digits_seen = 0;

	mov	DWORD PTR digits_seen$[rsp], 0

; 681  : #if CHEXPREFIX
; 682  :     if( *ptr == '0' && (tolower( *(ptr+1) ) == 'x' ) ) {

	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN12@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN38@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 90					; 0000005aH
	jg	SHORT $LN38@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	or	eax, 32					; 00000020H
	mov	DWORD PTR tv78[rsp], eax
	jmp	SHORT $LN39@get_number
$LN38@get_number:
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	mov	DWORD PTR tv78[rsp], eax
$LN39@get_number:
	cmp	DWORD PTR tv78[rsp], 120		; 00000078H
	jne	SHORT $LN12@get_number

; 683  :         ptr += 2;

	mov	rax, QWORD PTR ptr$[rsp]
	add	rax, 2
	mov	QWORD PTR ptr$[rsp], rax

; 684  :         base = 16;

	mov	DWORD PTR base$[rsp], 16
$LN12@get_number:

; 685  :     }
; 686  : #endif
; 687  :     dig_start = ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR dig_start$[rsp], rax
	jmp	SHORT $LN4@get_number
$LN2@get_number:

; 688  :     for( ;; ptr++ ) {

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN4@get_number:

; 689  :         if (*ptr >= '0' && *ptr <= '9')

	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN13@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN13@get_number

; 690  :             digits_seen |= 1 << (*ptr - '0');

	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	ecx, 1
	mov	DWORD PTR tv286[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv286[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR digits_seen$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR digits_seen$[rsp], eax
	jmp	SHORT $LN14@get_number
$LN13@get_number:

; 691  :         else {
; 692  :             last_char = tolower( *ptr );

	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN40@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 90					; 0000005aH
	jg	SHORT $LN40@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	or	eax, 32					; 00000020H
	mov	DWORD PTR tv129[rsp], eax
	jmp	SHORT $LN41@get_number
$LN40@get_number:
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv129[rsp], eax
$LN41@get_number:
	movzx	eax, BYTE PTR tv129[rsp]
	mov	BYTE PTR last_char$[rsp], al

; 693  :             if ( last_char >= 'a' && last_char <= 'f' )

	movsx	eax, BYTE PTR last_char$[rsp]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN15@get_number
	movsx	eax, BYTE PTR last_char$[rsp]
	cmp	eax, 102				; 00000066H
	jg	SHORT $LN15@get_number

; 694  :                 digits_seen |= 1 << ( last_char + 10 - 'a' );

	movsx	eax, BYTE PTR last_char$[rsp]
	sub	eax, 87					; 00000057H
	mov	ecx, 1
	mov	DWORD PTR tv297[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv297[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR digits_seen$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR digits_seen$[rsp], eax
	jmp	SHORT $LN16@get_number
$LN15@get_number:

; 695  :             else
; 696  :                 break;

	jmp	SHORT $LN3@get_number
$LN16@get_number:
$LN14@get_number:

; 697  :         }
; 698  :     }

	jmp	$LN2@get_number
$LN3@get_number:

; 699  : 
; 700  :     /* note that a float MUST contain a dot.
; 701  :      * 1234e78 is NOT a valid float
; 702  :      */
; 703  :     if ( last_char == '.' )

	movsx	eax, BYTE PTR last_char$[rsp]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN17@get_number

; 704  :         return( get_float( buf, p ) );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	get_float
	jmp	$LN1@get_number
$LN17@get_number:

; 705  : 
; 706  : #if 0
; 707  :     /* v2.08: if suffix isn't followed by a non-id char, don't use it! */
; 708  :     if ( last_char && is_valid_id_char( *(ptr+1) ) ) {
; 709  :         last_char = NULLC;
; 710  :         while ( *(ptr-1) > '9' )
; 711  :             ptr--;
; 712  :         digits_seen &= 0x3FF;
; 713  : 
; 714  :     }
; 715  : #endif
; 716  : 
; 717  : #if CHEXPREFIX
; 718  :     if ( base != 0 ) {

	cmp	DWORD PTR base$[rsp], 0
	je	SHORT $LN18@get_number

; 719  :         dig_end = ptr;

	mov	BYTE PTR $T4[rsp], 1
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR dig_end$[rsp], rax

; 720  :         if ( digits_seen == 0 )

	cmp	DWORD PTR digits_seen$[rsp], 0
	jne	SHORT $LN20@get_number

; 721  :             base = 0;

	mov	DWORD PTR base$[rsp], 0
$LN20@get_number:

; 722  :     } else

	jmp	$LN19@get_number
$LN18@get_number:

; 723  : #endif
; 724  :     switch( last_char ) {

	movsx	eax, BYTE PTR last_char$[rsp]
	mov	DWORD PTR tv148[rsp], eax
	mov	eax, DWORD PTR tv148[rsp]
	sub	eax, 104				; 00000068H
	mov	DWORD PTR tv148[rsp], eax
	cmp	DWORD PTR tv148[rsp], 17
	ja	$LN29@get_number
	movsxd	rax, DWORD PTR tv148[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN51@get_number[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN21@get_number:

; 725  :     case 'r': /* a float with the "real number designator" */
; 726  :         buf->token = T_FLOAT;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 11

; 727  :         buf->floattype = 'r';

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 114			; 00000072H

; 728  :         ptr++;

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax

; 729  :         goto number_done;

	jmp	$number_done$52
$LN22@get_number:

; 730  :     case 'h':
; 731  :         base = 16;

	mov	DWORD PTR base$[rsp], 16

; 732  :         dig_end = ptr;

	mov	BYTE PTR $T4[rsp], 1
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR dig_end$[rsp], rax

; 733  :         ptr++;

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax

; 734  :         break;

	jmp	$LN5@get_number
$LN23@get_number:

; 735  :     //case 'b':
; 736  :     case 'y':
; 737  :         if( OK_NUM( BINARY ) ) {

	mov	eax, DWORD PTR digits_seen$[rsp]
	and	eax, -4					; fffffffcH
	test	eax, eax
	jne	SHORT $LN24@get_number

; 738  :             base = 2;

	mov	DWORD PTR base$[rsp], 2

; 739  :             dig_end = ptr;

	mov	BYTE PTR $T4[rsp], 1
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR dig_end$[rsp], rax

; 740  :             ptr++;

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN24@get_number:

; 741  :         }
; 742  :         break;

	jmp	$LN5@get_number
$LN25@get_number:

; 743  :     //case 'd':
; 744  :     case 't':
; 745  :         if( OK_NUM( DECIMAL ) ) {

	mov	eax, DWORD PTR digits_seen$[rsp]
	and	eax, -1024				; fffffc00H
	test	eax, eax
	jne	SHORT $LN26@get_number

; 746  :             base = 10;

	mov	DWORD PTR base$[rsp], 10

; 747  :             dig_end = ptr;

	mov	BYTE PTR $T4[rsp], 1
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR dig_end$[rsp], rax

; 748  :             ptr++;

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN26@get_number:

; 749  :         }
; 750  :         break;

	jmp	$LN5@get_number
$LN27@get_number:

; 751  :     case 'q':
; 752  :     case 'o':
; 753  :         if( OK_NUM( OCTAL ) ) {

	mov	eax, DWORD PTR digits_seen$[rsp]
	and	eax, -256				; ffffff00H
	test	eax, eax
	jne	SHORT $LN28@get_number

; 754  :             base = 8;

	mov	DWORD PTR base$[rsp], 8

; 755  :             dig_end = ptr;

	mov	BYTE PTR $T4[rsp], 1
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR dig_end$[rsp], rax

; 756  :             ptr++;

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN28@get_number:

; 757  :         }
; 758  :         break;

	jmp	$LN5@get_number
$LN29@get_number:

; 759  :     default:
; 760  :         last_char = tolower( *(ptr-1) );

	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN42@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 90					; 0000005aH
	jg	SHORT $LN42@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	or	eax, 32					; 00000020H
	mov	DWORD PTR tv173[rsp], eax
	jmp	SHORT $LN43@get_number
$LN42@get_number:
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	mov	DWORD PTR tv173[rsp], eax
$LN43@get_number:
	movzx	eax, BYTE PTR tv173[rsp]
	mov	BYTE PTR last_char$[rsp], al

; 761  :         if ( ( last_char == 'b' || last_char == 'd' ) && digits_seen >= ( 1UL << ModuleInfo.radix ) ) {

	movsx	eax, BYTE PTR last_char$[rsp]
	cmp	eax, 98					; 00000062H
	je	SHORT $LN31@get_number
	movsx	eax, BYTE PTR last_char$[rsp]
	cmp	eax, 100				; 00000064H
	jne	$LN30@get_number
$LN31@get_number:
	movzx	eax, BYTE PTR ModuleInfo+396
	mov	ecx, 1
	mov	DWORD PTR tv323[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv323[rsp]
	shl	eax, cl
	cmp	DWORD PTR digits_seen$[rsp], eax
	jb	$LN30@get_number

; 762  :             char *tmp = dig_start;

	mov	rax, QWORD PTR dig_start$[rsp]
	mov	QWORD PTR tmp$2[rsp], rax

; 763  :             char max = ( last_char == 'b' ? '1' : '9' );

	movsx	eax, BYTE PTR last_char$[rsp]
	cmp	eax, 98					; 00000062H
	jne	SHORT $LN44@get_number
	mov	DWORD PTR tv184[rsp], 49		; 00000031H
	jmp	SHORT $LN45@get_number
$LN44@get_number:
	mov	DWORD PTR tv184[rsp], 57		; 00000039H
$LN45@get_number:
	movzx	eax, BYTE PTR tv184[rsp]
	mov	BYTE PTR max$3[rsp], al

; 764  :             for ( dig_end = ptr-1; tmp < dig_end && *tmp <= max; tmp++ );

	mov	rax, QWORD PTR ptr$[rsp]
	dec	rax
	mov	BYTE PTR $T4[rsp], 1
	mov	QWORD PTR dig_end$[rsp], rax
	jmp	SHORT $LN9@get_number
$LN7@get_number:
	mov	rax, QWORD PTR tmp$2[rsp]
	inc	rax
	mov	QWORD PTR tmp$2[rsp], rax
$LN9@get_number:
	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN48@get_number
	lea	rcx, OFFSET FLAT:get_number$rtcName$0
	call	_RTC_UninitUse
$LN48@get_number:
	mov	rax, QWORD PTR dig_end$[rsp]
	cmp	QWORD PTR tmp$2[rsp], rax
	jae	SHORT $LN8@get_number
	mov	rax, QWORD PTR tmp$2[rsp]
	movsx	eax, BYTE PTR [rax]
	movsx	ecx, BYTE PTR max$3[rsp]
	cmp	eax, ecx
	jg	SHORT $LN8@get_number
	jmp	SHORT $LN7@get_number
$LN8@get_number:

; 765  :             if ( tmp == dig_end ) {

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN49@get_number
	lea	rcx, OFFSET FLAT:get_number$rtcName$0
	call	_RTC_UninitUse
$LN49@get_number:
	mov	rax, QWORD PTR dig_end$[rsp]
	cmp	QWORD PTR tmp$2[rsp], rax
	jne	SHORT $LN32@get_number

; 766  :                 base = ( last_char == 'b' ? 2 : 10 );

	movsx	eax, BYTE PTR last_char$[rsp]
	cmp	eax, 98					; 00000062H
	jne	SHORT $LN46@get_number
	mov	DWORD PTR tv195[rsp], 2
	jmp	SHORT $LN47@get_number
$LN46@get_number:
	mov	DWORD PTR tv195[rsp], 10
$LN47@get_number:
	mov	eax, DWORD PTR tv195[rsp]
	mov	DWORD PTR base$[rsp], eax

; 767  :                 break;

	jmp	SHORT $LN5@get_number
$LN32@get_number:
$LN30@get_number:

; 768  :             }
; 769  :         }
; 770  :         dig_end = ptr;

	mov	BYTE PTR $T4[rsp], 1
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR dig_end$[rsp], rax

; 771  : #if COCTALS
; 772  :         if( Options.allow_c_octals && *dig_start == '0' ) {
; 773  :             if( OK_NUM( OCTAL ) ) {
; 774  :                 base = 8;
; 775  :                 break;
; 776  :             }
; 777  :         }
; 778  : #endif
; 779  :         /* radix      max. digits_seen
; 780  :          -----------------------------------------------------------
; 781  :          2            3      2^2-1  (0,1)
; 782  :          8            255    2^8-1  (0,1,2,3,4,5,6,7)
; 783  :          10           1023   2^10-1 (0,1,2,3,4,5,6,7,8,9)
; 784  :          16           65535  2^16-1 (0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f)
; 785  :          */
; 786  :         if ( digits_seen < (1UL << ModuleInfo.radix) )

	movzx	eax, BYTE PTR ModuleInfo+396
	mov	ecx, 1
	mov	DWORD PTR tv335[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv335[rsp]
	shl	eax, cl
	cmp	DWORD PTR digits_seen$[rsp], eax
	jae	SHORT $LN33@get_number

; 787  :             base = ModuleInfo.radix;

	movzx	eax, BYTE PTR ModuleInfo+396
	mov	DWORD PTR base$[rsp], eax
$LN33@get_number:
$LN5@get_number:
$LN19@get_number:

; 788  :         break;
; 789  :     }
; 790  : 
; 791  : #if MASMNUMBER
; 792  :     /* Masm doesn't swallow alphanum chars which may follow the
; 793  :      * number!
; 794  :      */
; 795  :     if ( base != 0 ) {

	cmp	DWORD PTR base$[rsp], 0
	je	SHORT $LN34@get_number

; 796  : #else
; 797  :     if ( base != 0 && is_valid_id_char( *ptr ) == FALSE ) {
; 798  : #endif
; 799  :         buf->token = T_NUM;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 10

; 800  :         buf->numbase = base;

	mov	rax, QWORD PTR buf$[rsp]
	movzx	ecx, BYTE PTR base$[rsp]
	mov	BYTE PTR [rax+1], cl

; 801  :         buf->itemlen = dig_end - dig_start;

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN50@get_number
	lea	rcx, OFFSET FLAT:get_number$rtcName$0
	call	_RTC_UninitUse
$LN50@get_number:
	mov	rax, QWORD PTR dig_start$[rsp]
	mov	rcx, QWORD PTR dig_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 802  :         //DebugMsg(("get_number: inp=%s, value=%" I32_SPEC "X\n", p->input, buf->value64 ));
; 803  :     } else {

	jmp	$LN35@get_number
$LN34@get_number:

; 804  :         buf->token = T_BAD_NUM;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 12

; 805  :         DebugMsg(("get_number: BAD_NUMBER (%s), radix=%u, base=%u, ptr=>%s<, digits_seen=%Xh\n", dig_start, ModuleInfo.radix, base, ptr, digits_seen ));

	movzx	eax, BYTE PTR ModuleInfo+396
	mov	ecx, DWORD PTR digits_seen$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, DWORD PTR base$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR dig_start$[rsp]
	lea	rcx, OFFSET FLAT:$SG11164
	call	DoDebugMsg
$LN10@get_number:

; 806  :         /* swallow remainder of token */
; 807  :         while( is_valid_id_char( *ptr ) ) ++ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	SHORT $LN36@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN36@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN36@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN36@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN11@get_number
$LN36@get_number:
	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
	jmp	SHORT $LN10@get_number
$LN11@get_number:
$LN35@get_number:
$number_done$52:

; 808  :     }
; 809  : number_done:
; 810  :     len = ptr - p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR ptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR len$[rsp], eax

; 811  :     memcpy( p->output, p->input, len );

	mov	eax, DWORD PTR len$[rsp]
	mov	r8d, eax
	mov	rax, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy

; 812  : 
; 813  :     p->output += len;

	mov	eax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 814  :     *p->output++ = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 815  :     p->input = ptr;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 816  : 
; 817  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@get_number:

; 818  : }

	add	rsp, 144				; 00000090H
	pop	rdi
	ret	0
	npad	3
$LN51@get_number:
	DD	$LN22@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN27@get_number
	DD	$LN29@get_number
	DD	$LN27@get_number
	DD	$LN21@get_number
	DD	$LN29@get_number
	DD	$LN25@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN23@get_number
get_number ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
symbol$ = 32
c$ = 33
sym$1 = 48
tv67 = 56
buf$ = 80
p$ = 88
get_special_symbol PROC

; 504  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 505  :     char    symbol;
; 506  :     char    c;
; 507  :     int     i;
; 508  :     int  index;
; 509  : 
; 510  :     symbol = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR symbol$[rsp], al

; 511  :     switch( symbol ) {

	movsx	eax, BYTE PTR symbol$[rsp]
	mov	DWORD PTR tv67[rsp], eax
	mov	eax, DWORD PTR tv67[rsp]
	sub	eax, 37					; 00000025H
	mov	DWORD PTR tv67[rsp], eax
	cmp	DWORD PTR tv67[rsp], 56			; 00000038H
	ja	$LN23@get_specia
	movsxd	rax, DWORD PTR tv67[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN32@get_specia[rcx+rax]
	mov	eax, DWORD PTR $LN33@get_specia[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN6@get_specia:

; 512  :     case ':' : /* T_COLON binary operator (0x3A) */
; 513  :         p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 514  :         if ( *p->input == ':' ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN7@get_specia

; 515  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 516  :             buf->token = T_DBL_COLON;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 13

; 517  :             buf->string_ptr = "::";

	mov	rax, QWORD PTR buf$[rsp]
	lea	rcx, OFFSET FLAT:$SG11085
	mov	QWORD PTR [rax+8], rcx

; 518  :         } else {

	jmp	SHORT $LN8@get_specia
$LN7@get_specia:

; 519  :             buf->token = T_COLON;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 58			; 0000003aH

; 520  :             buf->string_ptr = ":";

	mov	rax, QWORD PTR buf$[rsp]
	lea	rcx, OFFSET FLAT:$SG11086
	mov	QWORD PTR [rax+8], rcx
$LN8@get_specia:

; 521  :         }
; 522  :         break;

	jmp	$LN2@get_specia
$LN9@get_specia:

; 523  :     case '%' : /* T_PERCENT (0x25) */
; 524  : #if PERCENT_OUT
; 525  :         /* %OUT directive? */
; 526  :         if ( ( _memicmp( p->input+1, "OUT", 3 ) == 0 ) && !is_valid_id_char( *(p->input+4) ) ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	r8d, 3
	lea	rdx, OFFSET FLAT:$SG11089
	mov	rcx, rax
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	$LN10@get_specia
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+4]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	$LN10@get_specia
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+4]
	cmp	eax, 95					; 0000005fH
	je	$LN10@get_specia
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+4]
	cmp	eax, 64					; 00000040H
	je	$LN10@get_specia
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+4]
	cmp	eax, 36					; 00000024H
	je	$LN10@get_specia
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+4]
	cmp	eax, 63					; 0000003fH
	je	$LN10@get_specia

; 527  :             buf->token = T_DIRECTIVE;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 3

; 528  :             buf->tokval = T_ECHO;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 441			; 000001b9H

; 529  :             buf->dirtype = DRT_ECHO;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 46			; 0000002eH

; 530  :             memcpy( p->output, p->input, 4 );

	mov	r8d, 4
	mov	rax, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy

; 531  :             p->input += 4;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 4
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 532  :             p->output += 4;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 4
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 533  :             *(p->output)++ = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 534  :             break;

	jmp	$LN2@get_specia
$LN10@get_specia:

; 535  :         }
; 536  : #endif
; 537  :         p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 538  :         if ( p->flags == TOK_DEFAULT && p->index == 0 ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+28]
	test	eax, eax
	jne	SHORT $LN11@get_specia
	mov	rax, QWORD PTR p$[rsp]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN11@get_specia

; 539  :             p->flags3 |= TF3_EXPANSION;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+30]
	or	eax, 2
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx+30], al

; 540  :             return( EMPTY );

	mov	eax, -2
	jmp	$LN1@get_specia
$LN11@get_specia:

; 541  :         }
; 542  :         buf->token = T_PERCENT;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 37			; 00000025H

; 543  :         buf->string_ptr = "%";

	mov	rax, QWORD PTR buf$[rsp]
	lea	rcx, OFFSET FLAT:$SG11091
	mov	QWORD PTR [rax+8], rcx

; 544  :         break;

	jmp	$LN2@get_specia
$LN12@get_specia:

; 545  :     case '(' : /* 0x28: T_OP_BRACKET operator - needs a matching ')' */
; 546  :         /* v2.11: reset c-expression flag if a macro function call is detected */
; 547  :         if ( ( p->flags2 & DF_CEXPR ) && p->index && (buf-1)->token == T_ID ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+29]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN13@get_specia
	mov	rax, QWORD PTR p$[rsp]
	cmp	DWORD PTR [rax+24], 0
	je	SHORT $LN13@get_specia
	mov	rax, QWORD PTR buf$[rsp]
	movzx	eax, BYTE PTR [rax-32]
	cmp	eax, 8
	jne	SHORT $LN13@get_specia

; 548  :             struct asym *sym = SymSearch( (buf-1)->string_ptr );

	mov	rax, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR [rax-24]
	call	SymFind
	mov	QWORD PTR sym$1[rsp], rax

; 549  :             if ( sym && ( sym->state == SYM_MACRO ) && sym->isfunc )

	cmp	QWORD PTR sym$1[rsp], 0
	je	SHORT $LN14@get_specia
	mov	rax, QWORD PTR sym$1[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN14@get_specia
	mov	rax, QWORD PTR sym$1[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@get_specia

; 550  :                 p->flags2 &= ~DF_CEXPR;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+29]
	and	eax, -2
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx+29], al
$LN14@get_specia:
$LN13@get_specia:
$LN15@get_specia:

; 551  :         }
; 552  :         /* no break */
; 553  :     case ')' : /* 0x29: T_CL_BRACKET */
; 554  :     case '*' : /* 0x2A: binary operator */
; 555  :     case '+' : /* 0x2B: unary|binary operator */
; 556  :     case ',' : /* 0x2C: T_COMMA */
; 557  :     case '-' : /* 0x2D: unary|binary operator */
; 558  :     case '.' : /* 0x2E: T_DOT binary operator */
; 559  :     case '/' : /* 0x2F: binary operator */
; 560  :         /* all of these are themselves a token */
; 561  :         p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 562  :         buf->token = symbol;

	mov	rax, QWORD PTR buf$[rsp]
	movzx	ecx, BYTE PTR symbol$[rsp]
	mov	BYTE PTR [rax], cl

; 563  :         buf->specval = 0; /* initialize, in case the token needs extra data */

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 0

; 564  :         /* v2.06: use constants for the token string */
; 565  :         buf->string_ptr = (char *)&stokstr1[symbol - '('];

	movsx	eax, BYTE PTR symbol$[rsp]
	sub	eax, 40					; 00000028H
	cdqe
	lea	rcx, OFFSET FLAT:stokstr1
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rcx, QWORD PTR buf$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 566  :         break;

	jmp	$LN2@get_specia
$LN16@get_specia:

; 567  :     case '[' : /* T_OP_SQ_BRACKET operator - needs a matching ']' (0x5B) */
; 568  :     case ']' : /* T_CL_SQ_BRACKET (0x5D) */
; 569  :         p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
$LN4@get_specia:

; 570  : #if AVXSUPP
; 571  :         while ( isspace( *p->input )) p->input++; 

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN5@get_specia
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN4@get_specia
$LN5@get_specia:

; 572  :         c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 573  : #endif
; 574  :         buf->token = symbol;

	mov	rax, QWORD PTR buf$[rsp]
	movzx	ecx, BYTE PTR symbol$[rsp]
	mov	BYTE PTR [rax], cl

; 575  :         /* v2.06: use constants for the token string */
; 576  :         buf->string_ptr = (char *)&stokstr2[symbol - '['];

	movsx	eax, BYTE PTR symbol$[rsp]
	sub	eax, 91					; 0000005bH
	cdqe
	lea	rcx, OFFSET FLAT:stokstr2
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rcx, QWORD PTR buf$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 577  : #if AVXSUPP
; 578  :         /* Intercept here '{' for EVEX mask or broadcast events 
; 579  :          * it could be {k1}, ]{k1}{z}, {1to2},{1to4},{1to8},{1to16}
; 580  :         */
; 581  :         if (c == '{')

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN17@get_specia

; 582  :         {
; 583  :           p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 584  :           if ((*p->input | 0x20) == 'k' || (*p->input | 0x20) == 'z')

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	or	eax, 32					; 00000020H
	cmp	eax, 107				; 0000006bH
	je	SHORT $LN20@get_specia
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	or	eax, 32					; 00000020H
	cmp	eax, 122				; 0000007aH
	jne	SHORT $LN18@get_specia
$LN20@get_specia:

; 585  :             get_decos( p ) ;    // mask decorators

	mov	rcx, QWORD PTR p$[rsp]
	call	get_decos
	jmp	SHORT $LN19@get_specia
$LN18@get_specia:

; 586  :           else
; 587  :             get_broads( p ) ;   // broadcast decorators

	mov	rcx, QWORD PTR p$[rsp]
	call	get_broads
$LN19@get_specia:
$LN17@get_specia:

; 588  :         }
; 589  : #endif
; 590  :         break;

	jmp	$LN2@get_specia
$LN21@get_specia:

; 591  :     case '=' : /* (0x3D) */
; 592  :         if ( *(p->input+1) != '=' ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN22@get_specia

; 593  :             buf->token = T_DIRECTIVE;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 3

; 594  :             buf->tokval = T_EQU;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 443			; 000001bbH

; 595  :             buf->dirtype = DRT_EQUALSGN; /* to make it differ from EQU directive */

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 48			; 00000030H

; 596  :             buf->string_ptr = "=";

	mov	rax, QWORD PTR buf$[rsp]
	lea	rcx, OFFSET FLAT:$SG11103
	mov	QWORD PTR [rax+8], rcx

; 597  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 598  :             break;

	jmp	$LN2@get_specia
$LN22@get_specia:
$LN23@get_specia:

; 599  :         }
; 600  :         /* fall through */
; 601  :     default:
; 602  :         /* detect C style operators.
; 603  :          * DF_CEXPR is set if .IF, .WHILE, .ELSEIF or .UNTIL
; 604  :          * has been detected in the current line.
; 605  :          * will catch: '!', '<', '>', '&', '==', '!=', '<=', '>=', '&&', '||'
; 606  :          * A single '|' will also be caught, although it isn't a valid
; 607  :          * operator - it will cause a 'operator expected' error msg later.
; 608  :          * the tokens are stored as one- or two-byte sized "strings".
; 609  :          */
; 610  :       if ( ( p->flags2 & DF_CEXPR ) && strchr( "=!<>&|", symbol ) ) {     //habran added ''

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+29]
	and	eax, 1
	test	eax, eax
	je	$LN24@get_specia
	movsx	eax, BYTE PTR symbol$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11106
	call	QWORD PTR __imp_strchr
	test	rax, rax
	je	$LN24@get_specia

; 611  :             *(p->output)++ = symbol;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	ecx, BYTE PTR symbol$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 612  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 613  :             buf->stringlen = 1;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 1

; 614  :             if ( symbol == '&' || symbol == '|' ) {

	movsx	eax, BYTE PTR symbol$[rsp]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN27@get_specia
	movsx	eax, BYTE PTR symbol$[rsp]
	cmp	eax, 124				; 0000007cH
	jne	SHORT $LN25@get_specia
$LN27@get_specia:

; 615  :                 if ( *p->input == symbol ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	movsx	ecx, BYTE PTR symbol$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN28@get_specia

; 616  :                     *(p->output)++ = symbol;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	ecx, BYTE PTR symbol$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 617  :                     p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 618  :                     buf->stringlen = 2;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 2
$LN28@get_specia:

; 619  :                 }

	jmp	SHORT $LN26@get_specia
$LN25@get_specia:

; 620  :             } else if ( *p->input == '=' ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 61					; 0000003dH
	jne	SHORT $LN29@get_specia

; 621  :                 *(p->output)++ = '=';

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax], 61			; 0000003dH
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 622  :                 p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 623  :                 buf->stringlen = 2;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 2
$LN29@get_specia:
$LN26@get_specia:

; 624  :             }
; 625  :             buf->token = T_STRING;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 9

; 626  :             buf->string_delim = NULLC;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 0

; 627  :             *(p->output)++ = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 628  :             break;

	jmp	SHORT $LN2@get_specia
$LN24@get_specia:

; 629  :         }
; 630  :         /* v2.08: ampersand is a special token */
; 631  :         if ( symbol == '&' ) {

	movsx	eax, BYTE PTR symbol$[rsp]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN30@get_specia

; 632  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 633  :             buf->token = '&';

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 38			; 00000026H

; 634  :             buf->string_ptr = "&";

	mov	rax, QWORD PTR buf$[rsp]
	lea	rcx, OFFSET FLAT:$SG11113
	mov	QWORD PTR [rax+8], rcx

; 635  :             break;

	jmp	SHORT $LN2@get_specia
$LN30@get_specia:

; 636  :         }
; 637  :         /* anything we don't recognise we will consider a string,
; 638  :          * delimited by space characters, commas, newlines or nulls
; 639  :          */
; 640  :         return( get_string( buf, p ) );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	get_string
	jmp	SHORT $LN1@get_specia
$LN2@get_specia:

; 641  :     }
; 642  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@get_specia:

; 643  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
	npad	1
$LN33@get_specia:
	DD	$LN9@get_specia
	DD	$LN12@get_specia
	DD	$LN15@get_specia
	DD	$LN6@get_specia
	DD	$LN21@get_specia
	DD	$LN16@get_specia
	DD	$LN23@get_specia
$LN32@get_specia:
	DB	0
	DB	6
	DB	6
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	6
	DB	5
get_special_symbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
symbol_o$ = 32
symbol_c$ = 33
c$ = 34
src$ = 40
dst$ = 48
count$ = 56
level$ = 60
delim$1 = 64
tdst$2 = 72
tsrc$3 = 80
tcount$4 = 88
tmp$5 = 96
tv67 = 104
tv94 = 108
buf$ = 128
p$ = 136
get_string PROC

; 309  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]

; 310  :     char    symbol_o;
; 311  :     char    symbol_c;
; 312  :     char    c;
; 313  :     char    *src = p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR src$[rsp], rax

; 314  :     char    *dst = p->output;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR dst$[rsp], rax

; 315  :     int     count = 0;

	mov	DWORD PTR count$[rsp], 0

; 316  :     int     level;
; 317  : 
; 318  :     symbol_o = *src;

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR symbol_o$[rsp], al

; 319  : 
; 320  :     switch( symbol_o ) {

	movzx	eax, BYTE PTR symbol_o$[rsp]
	mov	BYTE PTR tv67[rsp], al
	cmp	BYTE PTR tv67[rsp], 34			; 00000022H
	je	SHORT $LN19@get_string
	cmp	BYTE PTR tv67[rsp], 39			; 00000027H
	je	SHORT $LN19@get_string
	cmp	BYTE PTR tv67[rsp], 60			; 0000003cH
	je	$LN27@get_string
	cmp	BYTE PTR tv67[rsp], 123			; 0000007bH
	je	$LN25@get_string
	jmp	$LN51@get_string
$LN19@get_string:

; 321  :     case '"':
; 322  :     case '\'':
; 323  :         buf->string_delim = symbol_o;

	mov	rax, QWORD PTR buf$[rsp]
	movzx	ecx, BYTE PTR symbol_o$[rsp]
	mov	BYTE PTR [rax+1], cl

; 324  :         *dst++ = symbol_o;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR symbol_o$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 325  :         src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 326  :         for ( ; count < MAX_STRING_LEN; src++, count++ ) {

	jmp	SHORT $LN6@get_string
$LN4@get_string:
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
$LN6@get_string:
	cmp	DWORD PTR count$[rsp], 568		; 00000238H
	jge	$LN5@get_string

; 327  :             c = *src;

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 328  :             if( c == symbol_o ) { /* another quote? */

	movsx	eax, BYTE PTR c$[rsp]
	movsx	ecx, BYTE PTR symbol_o$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN20@get_string

; 329  :                 *dst++ = c; /* store it */

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 330  :                 src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 331  :                 if( *src != c )

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	movsx	ecx, BYTE PTR c$[rsp]
	cmp	eax, ecx
	je	SHORT $LN22@get_string

; 332  :                     break; /* exit loop */

	jmp	SHORT $LN5@get_string
$LN22@get_string:

; 333  :                 /* a pair of quotes inside the string is
; 334  :                  * handled as a single quote */
; 335  :             } else if( c == NULLC ) {

	jmp	SHORT $LN21@get_string
$LN20@get_string:
	movsx	eax, BYTE PTR c$[rsp]
	test	eax, eax
	jne	SHORT $LN23@get_string

; 336  :                 /* missing terminating quote, change to undelimited string */
; 337  :                 buf->string_delim = NULLC;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 0

; 338  :                 count++; /* count the first quote */

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax

; 339  :                 break;

	jmp	SHORT $LN5@get_string

; 340  :             } else {

	jmp	SHORT $LN24@get_string
$LN23@get_string:

; 341  :                 *dst++ = c;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
$LN24@get_string:
$LN21@get_string:

; 342  :             }
; 343  :         }

	jmp	$LN4@get_string
$LN5@get_string:

; 344  :         break;  /* end of string marker is the same */

	jmp	$LN2@get_string
$LN25@get_string:

; 345  :     case '{':
; 346  :         if ( p->flags & TOK_NOCURLBRACES )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+28]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN26@get_string

; 347  :             goto undelimited_string;

	jmp	$undelimited_string$62
$LN26@get_string:
$LN27@get_string:

; 348  :     case '<':
; 349  :         buf->string_delim = symbol_o;

	mov	rax, QWORD PTR buf$[rsp]
	movzx	ecx, BYTE PTR symbol_o$[rsp]
	mov	BYTE PTR [rax+1], cl

; 350  :         symbol_c = ( symbol_o == '<' ? '>' : '}' );

	movsx	eax, BYTE PTR symbol_o$[rsp]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN60@get_string
	mov	DWORD PTR tv94[rsp], 62			; 0000003eH
	jmp	SHORT $LN61@get_string
$LN60@get_string:
	mov	DWORD PTR tv94[rsp], 125		; 0000007dH
$LN61@get_string:
	movzx	eax, BYTE PTR tv94[rsp]
	mov	BYTE PTR symbol_c$[rsp], al

; 351  :         src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 352  :         for( level = 0; count < MAX_STRING_LEN; ) {

	mov	DWORD PTR level$[rsp], 0
$LN7@get_string:
	cmp	DWORD PTR count$[rsp], 568		; 00000238H
	jge	$LN8@get_string

; 353  :             c = *src;

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 354  :             if( c == symbol_o ) { /* < or { ? */

	movsx	eax, BYTE PTR c$[rsp]
	movsx	ecx, BYTE PTR symbol_o$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN28@get_string

; 355  :                 level++;

	mov	eax, DWORD PTR level$[rsp]
	inc	eax
	mov	DWORD PTR level$[rsp], eax

; 356  :                 *dst++ = c; src++;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 357  :                 count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
	jmp	$LN29@get_string
$LN28@get_string:

; 358  :             } else if( c == symbol_c ) { /* > or }? */

	movsx	eax, BYTE PTR c$[rsp]
	movsx	ecx, BYTE PTR symbol_c$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN30@get_string

; 359  :                 if( level ) {

	cmp	DWORD PTR level$[rsp], 0
	je	SHORT $LN32@get_string

; 360  :                     level--;

	mov	eax, DWORD PTR level$[rsp]
	dec	eax
	mov	DWORD PTR level$[rsp], eax

; 361  :                     *dst++ = c; src++;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 362  :                     count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax

; 363  :                 } else {

	jmp	SHORT $LN33@get_string
$LN32@get_string:

; 364  :                     /* store the string delimiter unless it is <> */
; 365  :                     /* v2.08: don't store delimiters for {}-literals */
; 366  :                     //if (symbol_o != '<')
; 367  :                     //    *dst++ = c;
; 368  :                     src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 369  :                     break; /* exit loop */

	jmp	$LN8@get_string
$LN33@get_string:

; 370  :                 }

	jmp	$LN31@get_string
$LN30@get_string:

; 371  : #if 1
; 372  :             /*
; 373  :              a " or ' inside a <>/{} string? Since it's not a must that
; 374  :              [double-]quotes are paired in a literal it must be done
; 375  :              directive-dependant!
; 376  :              see: IFIDN <">,<">
; 377  :              */
; 378  :             } else if( ( c == '"' || c == '\'' ) && ( p->flags2 & DF_STRPARM ) == 0 ) {

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN36@get_string
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 39					; 00000027H
	jne	$LN34@get_string
$LN36@get_string:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+29]
	and	eax, 2
	test	eax, eax
	jne	$LN34@get_string

; 379  :                 char delim = c;

	movzx	eax, BYTE PTR c$[rsp]
	mov	BYTE PTR delim$1[rsp], al

; 380  :                 char *tdst;
; 381  :                 char *tsrc;
; 382  :                 int tcount;
; 383  :                 *dst++ = c; src++;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 384  :                 count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax

; 385  :                 tdst = dst;

	mov	rax, QWORD PTR dst$[rsp]
	mov	QWORD PTR tdst$2[rsp], rax

; 386  :                 tsrc = src;

	mov	rax, QWORD PTR src$[rsp]
	mov	QWORD PTR tsrc$3[rsp], rax

; 387  :                 tcount = count;

	mov	eax, DWORD PTR count$[rsp]
	mov	DWORD PTR tcount$4[rsp], eax
$LN10@get_string:

; 388  :                 while (*src != delim && *src != NULLC && count < MAX_STRING_LEN-1 ) {

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	movsx	ecx, BYTE PTR delim$1[rsp]
	cmp	eax, ecx
	je	SHORT $LN11@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN11@get_string
	cmp	DWORD PTR count$[rsp], 567		; 00000237H
	jge	SHORT $LN11@get_string

; 389  :                     if ( symbol_o == '<' && *src == '!' && *(src+1) != NULLC )

	movsx	eax, BYTE PTR symbol_o$[rsp]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN37@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN37@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	je	SHORT $LN37@get_string

; 390  :                         src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN37@get_string:

; 391  :                     *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 392  :                     count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax

; 393  :                 }

	jmp	$LN10@get_string
$LN11@get_string:

; 394  :                 if ( *src == delim ) {

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	movsx	ecx, BYTE PTR delim$1[rsp]
	cmp	eax, ecx
	jne	SHORT $LN38@get_string

; 395  :                     *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 396  :                     count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax

; 397  :                     continue;

	jmp	$LN7@get_string

; 398  :                 } else {

	jmp	SHORT $LN39@get_string
$LN38@get_string:

; 399  :                     /* restore values */
; 400  :                     src = tsrc;

	mov	rax, QWORD PTR tsrc$3[rsp]
	mov	QWORD PTR src$[rsp], rax

; 401  :                     dst = tdst;

	mov	rax, QWORD PTR tdst$2[rsp]
	mov	QWORD PTR dst$[rsp], rax

; 402  :                     count = tcount;

	mov	eax, DWORD PTR tcount$4[rsp]
	mov	DWORD PTR count$[rsp], eax
$LN39@get_string:

; 403  :                 }

	jmp	$LN35@get_string
$LN34@get_string:

; 404  : #endif
; 405  :             } else if( c == '!' && symbol_o == '<' && *(src+1) ) {

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN40@get_string
	movsx	eax, BYTE PTR symbol_o$[rsp]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN40@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	je	SHORT $LN40@get_string

; 406  :                 /* handle literal-character operator '!'.
; 407  :                  * it makes the next char to enter the literal uninterpreted.
; 408  :                  */
; 409  :                 /* v2.09: don't store the '!' */
; 410  :                 //*dst++ = c; src++;
; 411  :                 //count++;
; 412  :                 //if ( count == MAX_STRING_LEN )
; 413  :                 //    break;
; 414  :                 src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 415  :                 *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 416  :                 count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
	jmp	$LN41@get_string
$LN40@get_string:

; 417  :             } else if( c == '\\' &&  ConcatLine( src, count, dst, p ) != EMPTY ) {

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN42@get_string
	mov	r9, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR dst$[rsp]
	mov	edx, DWORD PTR count$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	call	ConcatLine
	cmp	eax, -2
	je	SHORT $LN42@get_string

; 418  :                 p->flags3 |= TF3_ISCONCAT;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+30]
	or	eax, 1
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx+30], al
	jmp	$LN43@get_string
$LN42@get_string:

; 419  :             } else if( c == NULLC || ( c == ';' && symbol_o == '{' )) {

	movsx	eax, BYTE PTR c$[rsp]
	test	eax, eax
	je	SHORT $LN46@get_string
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 59					; 0000003bH
	jne	$LN44@get_string
	movsx	eax, BYTE PTR symbol_o$[rsp]
	cmp	eax, 123				; 0000007bH
	jne	$LN44@get_string
$LN46@get_string:

; 420  :                 if ( p->flags == TOK_DEFAULT && (( p->flags2 & DF_NOCONCAT ) == 0 ) ) { /* <{ */

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+28]
	test	eax, eax
	jne	$LN47@get_string
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+29]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	$LN47@get_string

; 421  :                     /* if last nonspace character was a comma
; 422  :                      * get next line and continue string scan
; 423  :                      */
; 424  :                     char *tmp = dst-1;

	mov	rax, QWORD PTR dst$[rsp]
	dec	rax
	mov	QWORD PTR tmp$5[rsp], rax
$LN12@get_string:

; 425  :                     while ( isspace(*tmp) ) tmp--;

	mov	rax, QWORD PTR tmp$5[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN13@get_string
	mov	rax, QWORD PTR tmp$5[rsp]
	dec	rax
	mov	QWORD PTR tmp$5[rsp], rax
	jmp	SHORT $LN12@get_string
$LN13@get_string:

; 426  :                     if ( *tmp == ',' ) {

	mov	rax, QWORD PTR tmp$5[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 44					; 0000002cH
	jne	$LN48@get_string

; 427  :                         DebugMsg1(("Tokenize.get_string: comma concatenation: %s\n", src ));

	mov	rdx, QWORD PTR src$[rsp]
	lea	rcx, OFFSET FLAT:$SG11053
	call	DoDebugMsg1

; 428  :                         tmp = GetAlignedPointer( p->output, strlen( p->output ) );

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strlen
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR p$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR tmp$5[rsp], rax

; 429  :                         if( GetTextLine( tmp ) ) {

	mov	rcx, QWORD PTR tmp$5[rsp]
	call	GetTextLine
	test	rax, rax
	je	SHORT $LN49@get_string
$LN14@get_string:

; 430  :                             /* skip leading spaces */
; 431  :                             while ( isspace( *tmp ) ) tmp++;

	mov	rax, QWORD PTR tmp$5[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN15@get_string
	mov	rax, QWORD PTR tmp$5[rsp]
	inc	rax
	mov	QWORD PTR tmp$5[rsp], rax
	jmp	SHORT $LN14@get_string
$LN15@get_string:

; 432  :                             /* this size check isn't fool-proved yet */
; 433  :                             if ( strlen( tmp ) + count >= MAX_LINE_LEN ) {

	mov	rcx, QWORD PTR tmp$5[rsp]
	call	strlen
	movsxd	rcx, DWORD PTR count$[rsp]
	add	rax, rcx
	cmp	rax, 600				; 00000258H
	jb	SHORT $LN50@get_string

; 434  :                                 EmitError( LINE_TOO_LONG );

	mov	ecx, 61					; 0000003dH
	call	EmitError

; 435  :                                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@get_string
$LN50@get_string:

; 436  :                             }
; 437  :                             strcpy( src, tmp );

	mov	rdx, QWORD PTR tmp$5[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	call	strcpy

; 438  :                             continue;

	jmp	$LN7@get_string
$LN49@get_string:
$LN48@get_string:
$LN47@get_string:

; 439  :                         }
; 440  :                     }
; 441  :                 }
; 442  :                 src = p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR src$[rsp], rax

; 443  :                 dst = p->output;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR dst$[rsp], rax

; 444  :                 *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 445  :                 count = 1;

	mov	DWORD PTR count$[rsp], 1

; 446  :                 goto undelimited_string;

	jmp	SHORT $undelimited_string$62

; 447  :             } else {

	jmp	SHORT $LN45@get_string
$LN44@get_string:

; 448  :                 *dst++ = c; src++;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 449  :                 count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
$LN45@get_string:
$LN43@get_string:
$LN41@get_string:
$LN35@get_string:
$LN31@get_string:
$LN29@get_string:

; 450  :             }
; 451  :         }

	jmp	$LN7@get_string
$LN8@get_string:

; 452  :         break;

	jmp	$LN2@get_string
$LN51@get_string:
$undelimited_string$62:

; 453  :     default:
; 454  :         undelimited_string:
; 455  :         buf->string_delim = NULLC;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 0
$LN16@get_string:

; 456  :         /* this is an undelimited string,
; 457  :          * so just copy it until we hit something that looks like the end.
; 458  :          * this format is used by the INCLUDE directive, but may also
; 459  :          * occur inside the string macros!
; 460  :          */
; 461  :         /* v2.05: also stop if a ')' is found - see literal2.asm regression test */
; 462  :         //for( count = 0 ; count < MAX_STRING_LEN && *src != NULLC && !isspace( *src ) && *src != ',' && *src != ';'; ) {
; 463  :         for( ; count < MAX_STRING_LEN &&
; 464  :             /* v2.08: stop also at < and % */
; 465  :             //*src != NULLC && !isspace( *src ) && *src != ',' && *src != ';' && *src != ')'; ) {
; 466  :             //*src && !isspace( *src ) && *src != ',' && *src != ')' && *src != '<' && *src != '%'; ) {
; 467  :             *src && !isspace( *src ) && *src != ',' && *src != ')' && *src != '%'; ) {

	cmp	DWORD PTR count$[rsp], 568		; 00000238H
	jge	$LN17@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN17@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	jne	$LN17@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 44					; 0000002cH
	je	$LN17@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 41					; 00000029H
	je	$LN17@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	je	$LN17@get_string

; 468  :             if ( *src == ';' && p->flags == TOK_DEFAULT )

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN52@get_string
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+28]
	test	eax, eax
	jne	SHORT $LN52@get_string

; 469  :                 break;

	jmp	$LN17@get_string
$LN52@get_string:

; 470  :             /* v2.11: handle '\' also for expanded lines */
; 471  :             //if (  *src == '\\' && !( p->flags & TOK_NOCURLBRACES ) ) {
; 472  :             if (  *src == '\\' && ( p->flags == TOK_DEFAULT || ( p->flags & TOK_LINE ) ) ) {

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 92					; 0000005cH
	jne	$LN53@get_string
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+28]
	test	eax, eax
	je	SHORT $LN54@get_string
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+28]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN53@get_string
$LN54@get_string:

; 473  :                 if ( ConcatLine( src, count, dst, p ) != EMPTY ) {

	mov	r9, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR dst$[rsp]
	mov	edx, DWORD PTR count$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	call	ConcatLine
	cmp	eax, -2
	je	SHORT $LN55@get_string

; 474  :                     DebugMsg1(("Tokenize.get_string: backslash concatenation: >%s<\n", src ));

	mov	rdx, QWORD PTR src$[rsp]
	lea	rcx, OFFSET FLAT:$SG11061
	call	DoDebugMsg1

; 475  :                     p->flags3 |= TF3_ISCONCAT;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+30]
	or	eax, 1
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx+30], al

; 476  :                     if ( count )

	cmp	DWORD PTR count$[rsp], 0
	je	SHORT $LN56@get_string

; 477  :                         continue;

	jmp	$LN16@get_string
$LN56@get_string:

; 478  :                     return( EMPTY );

	mov	eax, -2
	jmp	$LN1@get_string
$LN55@get_string:
$LN53@get_string:

; 479  :                 }
; 480  :             }
; 481  :             /* v2.08: handle '!' operator */
; 482  :             if ( *src == '!' && *(src+1) && count < MAX_STRING_LEN - 1 )

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN57@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	je	SHORT $LN57@get_string
	cmp	DWORD PTR count$[rsp], 567		; 00000237H
	jge	SHORT $LN57@get_string

; 483  :                 *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN57@get_string:

; 484  :             *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 485  :             count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax

; 486  :         }

	jmp	$LN16@get_string
$LN17@get_string:
$LN2@get_string:

; 487  :         break;
; 488  :     }
; 489  : 
; 490  :     if ( count == MAX_STRING_LEN ) {

	cmp	DWORD PTR count$[rsp], 568		; 00000238H
	jne	SHORT $LN58@get_string

; 491  :         EmitError( STRING_OR_TEXT_LITERAL_TOO_LONG );

	mov	ecx, 155				; 0000009bH
	call	EmitError

; 492  :         return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@get_string
$LN58@get_string:

; 493  :     }
; 494  :     *dst++ = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 495  :     buf->token = T_STRING;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 9

; 496  :     buf->stringlen = count;

	mov	rax, QWORD PTR buf$[rsp]
	mov	ecx, DWORD PTR count$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 497  :     p->input = src;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	QWORD PTR [rax], rcx

; 498  :     p->output = dst;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 499  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@get_string:

; 500  : }

	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
get_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
p$ = 32
max$ = 40
buffer$1 = 48
src$ = 80
cnt$ = 88
out$ = 96
ls$ = 104
ConcatLine PROC

; 280  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 281  :     char *p = src+1;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN2@ConcatLine:

; 282  :     int max;
; 283  : 
; 284  :     while ( isspace(*p) ) p++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN3@ConcatLine
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN2@ConcatLine
$LN3@ConcatLine:

; 285  :     if ( *p == NULLC || *p == ';' ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN7@ConcatLine
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 59					; 0000003bH
	jne	$LN6@ConcatLine
$LN7@ConcatLine:

; 286  :         //char *buffer = GetAlignedPointer( out, strlen( out ) );
; 287  :         char *buffer = out;

	mov	rax, QWORD PTR out$[rsp]
	mov	QWORD PTR buffer$1[rsp], rax

; 288  :         if( GetTextLine( buffer ) ) {

	mov	rcx, QWORD PTR buffer$1[rsp]
	call	GetTextLine
	test	rax, rax
	je	$LN8@ConcatLine

; 289  :             p = buffer;

	mov	rax, QWORD PTR buffer$1[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN4@ConcatLine:

; 290  :             /* skip leading spaces */
; 291  :             while ( isspace( *p ) ) p++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN5@ConcatLine
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN4@ConcatLine
$LN5@ConcatLine:

; 292  :             max = strlen( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	DWORD PTR max$[rsp], eax

; 293  :             if ( cnt == 0 )

	cmp	DWORD PTR cnt$[rsp], 0
	jne	SHORT $LN9@ConcatLine

; 294  :                 *src++ = ' ';

	mov	rax, QWORD PTR src$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN9@ConcatLine:

; 295  :             if ( ( src - ls->start ) + max >= MAX_LINE_LEN ) {

	mov	rax, QWORD PTR ls$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR src$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR max$[rsp]
	add	rax, rcx
	cmp	rax, 600				; 00000258H
	jl	SHORT $LN10@ConcatLine

; 296  :                 EmitError( LINE_TOO_LONG );

	mov	ecx, 61					; 0000003dH
	call	EmitError

; 297  :                 max = MAX_LINE_LEN - ( src - ls->start + 1 );

	mov	rax, QWORD PTR ls$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR src$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	inc	rax
	mov	ecx, 600				; 00000258H
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR max$[rsp], eax

; 298  :                 *(p+max) = NULLC;

	movsxd	rax, DWORD PTR max$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx+rax], 0
$LN10@ConcatLine:

; 299  :             }
; 300  :             memcpy( src, p, max+1 );

	mov	eax, DWORD PTR max$[rsp]
	inc	eax
	cdqe
	mov	r8, rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	call	memcpy

; 301  :             return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@ConcatLine
$LN8@ConcatLine:
$LN6@ConcatLine:

; 302  :         }
; 303  :     }
; 304  :     return( EMPTY );

	mov	eax, -2
$LN1@ConcatLine:

; 305  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ConcatLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
got_decimal$ = 32
got_e$ = 33
ptr$ = 40
c$1 = 48
tv83 = 52
buf$ = 80
p$ = 88
get_float PROC

; 238  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 239  :     /* valid floats look like:  (int)[.(int)][e(int)]
; 240  :      * Masm also allows hex format, terminated by 'r' (3F800000r)
; 241  :      */
; 242  : 
; 243  :     char    got_decimal = FALSE;

	mov	BYTE PTR got_decimal$[rsp], 0

; 244  :     char    got_e = FALSE;

	mov	BYTE PTR got_e$[rsp], 0

; 245  :     char    *ptr = p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ptr$[rsp], rax

; 246  : 
; 247  :     for( ; *ptr != NULLC; ptr++ ) {

	jmp	SHORT $LN4@get_float
$LN2@get_float:
	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN4@get_float:
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@get_float

; 248  :         char c = *ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$1[rsp], al

; 249  :         if( isdigit( c ) ) {

	movsx	eax, BYTE PTR c$1[rsp]
	mov	ecx, eax
	call	QWORD PTR __imp_isdigit
	test	eax, eax
	je	SHORT $LN5@get_float
	jmp	$LN6@get_float
$LN5@get_float:

; 250  :             ;
; 251  :         } else if ( c == '.' && got_decimal == FALSE ) {

	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN7@get_float
	movsx	eax, BYTE PTR got_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN7@get_float

; 252  :             got_decimal = TRUE;

	mov	BYTE PTR got_decimal$[rsp], 1
	jmp	SHORT $LN8@get_float
$LN7@get_float:

; 253  :         } else if ( tolower( c ) == 'e' && got_e == FALSE ) {

	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN14@get_float
	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 90					; 0000005aH
	jg	SHORT $LN14@get_float
	movsx	eax, BYTE PTR c$1[rsp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR tv83[rsp], eax
	jmp	SHORT $LN15@get_float
$LN14@get_float:
	movsx	eax, BYTE PTR c$1[rsp]
	mov	DWORD PTR tv83[rsp], eax
$LN15@get_float:
	cmp	DWORD PTR tv83[rsp], 101		; 00000065H
	jne	SHORT $LN9@get_float
	movsx	eax, BYTE PTR got_e$[rsp]
	test	eax, eax
	jne	SHORT $LN9@get_float

; 254  :             got_e = TRUE;

	mov	BYTE PTR got_e$[rsp], 1

; 255  :             /* accept e+2 / e-4 /etc. */
; 256  :             if ( *(ptr+1) == '+' || *(ptr+1) == '-' )

	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN12@get_float
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN11@get_float
$LN12@get_float:

; 257  :                 ptr++;

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN11@get_float:

; 258  :             /* it's accepted if there's no digit behind 'e' */
; 259  :             //if ( !isdigit( *(ptr+1) ) )
; 260  :             //    break;
; 261  :         } else

	jmp	SHORT $LN10@get_float
$LN9@get_float:

; 262  :             break;

	jmp	SHORT $LN3@get_float
$LN10@get_float:
$LN8@get_float:
$LN6@get_float:

; 263  :     }

	jmp	$LN2@get_float
$LN3@get_float:

; 264  : 
; 265  :     buf->token = T_FLOAT;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 11

; 266  :     buf->floattype = NULLC;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 0

; 267  :     memcpy( p->output, p->input, ptr - p->input );

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR ptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	rax, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy

; 268  :     p->output += ( ptr - p->input );

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR ptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR p$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 269  :     *p->output++ = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 270  :     p->input = ptr;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 271  : 
; 272  :     /* the binary value isn't used currently */
; 273  :     //*((float *)(&buf->value)) = atof( buf->string_ptr );
; 274  : 
; 275  :     return( NOT_ERROR );

	xor	eax, eax

; 276  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
get_float ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
c$ = 32
p$ = 64
get_decos PROC

; 150  : void get_decos(struct line_status *p ){

$LN25:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 151  : /************************************************/
; 152  :     unsigned char c;
; 153  :           c = (*p->input | 0x20);

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	or	eax, 32					; 00000020H
	mov	BYTE PTR c$[rsp], al

; 154  :           p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 155  :           /* if first decorator is the z  */
; 156  :           if (c == 'z'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 122				; 0000007aH
	jne	$LN6@get_decos

; 157  :             decoflags |= 0x80; 

	movzx	eax, BYTE PTR decoflags
	bts	eax, 7
	mov	BYTE PTR decoflags, al

; 158  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 159  :             c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 160  :             if (c != '}'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 125				; 0000007dH
	je	SHORT $LN8@get_decos

; 161  :               EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15
	call	EmitError

; 162  :               return;

	jmp	$LN1@get_decos
$LN8@get_decos:

; 163  :             }
; 164  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
$LN2@get_decos:

; 165  :             while ( isspace( *p->input )) p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN3@get_decos
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN2@get_decos
$LN3@get_decos:

; 166  :             c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 167  :             if (c != '{'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN9@get_decos

; 168  :               EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError

; 169  :               return;

	jmp	$LN1@get_decos
$LN9@get_decos:

; 170  :             }
; 171  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 172  :             c = (*p->input | 0x20);

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	or	eax, 32					; 00000020H
	mov	BYTE PTR c$[rsp], al

; 173  :             if (c != 'k'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 107				; 0000006bH
	je	SHORT $LN10@get_decos

; 174  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15
	call	EmitError

; 175  :                 return;

	jmp	$LN1@get_decos

; 176  :             }else{

	jmp	$LN11@get_decos
$LN10@get_decos:

; 177  :               p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 178  :               c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 179  :               if (c > '7' || c < '1'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 55					; 00000037H
	jg	SHORT $LN13@get_decos
	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 49					; 00000031H
	jge	SHORT $LN12@get_decos
$LN13@get_decos:

; 180  :                 EmitError(WRONG_MASK_REGISTER_NUBER);

	mov	ecx, 16
	call	EmitError

; 181  :                 return;

	jmp	$LN1@get_decos
$LN12@get_decos:

; 182  :               }
; 183  :               decoflags |= (c & 0x7);

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 7
	movzx	ecx, BYTE PTR decoflags
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR decoflags, al

; 184  :               p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 185  :               c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 186  :               if (c != '}'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 125				; 0000007dH
	je	SHORT $LN14@get_decos

; 187  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15
	call	EmitError

; 188  :                 return;

	jmp	$LN1@get_decos
$LN14@get_decos:

; 189  :               }
; 190  :               p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
$LN11@get_decos:

; 191  :             }
; 192  :           }

	jmp	$LN7@get_decos
$LN6@get_decos:

; 193  :           /* if first decorator is the mask register */
; 194  :           else if (c == 'k'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 107				; 0000006bH
	jne	$LN15@get_decos

; 195  :           c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 196  :           if (c > '7' || c < '1'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 55					; 00000037H
	jg	SHORT $LN18@get_decos
	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 49					; 00000031H
	jge	SHORT $LN17@get_decos
$LN18@get_decos:

; 197  :             EmitError(WRONG_MASK_REGISTER_NUBER);

	mov	ecx, 16
	call	EmitError

; 198  :             return;

	jmp	$LN1@get_decos
$LN17@get_decos:

; 199  :           }
; 200  :           decoflags |= (c & 0x7);

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 7
	movzx	ecx, BYTE PTR decoflags
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR decoflags, al

; 201  :           p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 202  :           c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 203  :           if (c != '}'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 125				; 0000007dH
	je	SHORT $LN19@get_decos

; 204  :             EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15
	call	EmitError

; 205  :             return;

	jmp	$LN1@get_decos
$LN19@get_decos:

; 206  :           }
; 207  :           p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
$LN4@get_decos:

; 208  :           /* check if there is more decorators */
; 209  :           while ( isspace( *p->input )) p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN5@get_decos
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN4@get_decos
$LN5@get_decos:

; 210  :           c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 211  :           if (c == '{'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 123				; 0000007bH
	jne	$LN20@get_decos

; 212  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 213  :             c = (*p->input | 0x20);

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	or	eax, 32					; 00000020H
	mov	BYTE PTR c$[rsp], al

; 214  :             if (c == 'z'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 122				; 0000007aH
	jne	SHORT $LN21@get_decos

; 215  :               decoflags |= 0x80;

	movzx	eax, BYTE PTR decoflags
	bts	eax, 7
	mov	BYTE PTR decoflags, al

; 216  :               p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 217  :               c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 218  :               if (c != '}'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 125				; 0000007dH
	je	SHORT $LN23@get_decos

; 219  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15
	call	EmitError

; 220  :                 return;

	jmp	SHORT $LN1@get_decos
$LN23@get_decos:

; 221  :               }
; 222  :               p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 223  :             }

	jmp	SHORT $LN22@get_decos
$LN21@get_decos:

; 224  :             else {
; 225  :               EmitError(TO_MANY_DECORATORS);

	mov	ecx, 17
	call	EmitError

; 226  :               return;

	jmp	SHORT $LN1@get_decos
$LN22@get_decos:
$LN20@get_decos:

; 227  :             }
; 228  :           }
; 229  :         }

	jmp	SHORT $LN16@get_decos
$LN15@get_decos:

; 230  :         else {
; 231  :           EmitError(TO_MANY_DECORATORS);

	mov	ecx, 17
	call	EmitError
$LN16@get_decos:
$LN7@get_decos:
$LN1@get_decos:

; 232  :           return;
; 233  :         }
; 234  :       }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
get_decos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
tv140 = 32
tv141 = 36
p$ = 64
get_broads PROC

; 125  : void get_broads(struct line_status *p ){

$LN14:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 126  : /************************************************/          
; 127  :     if (_memicmp(p->input, "1to2", 4) == 0){

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG10904
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN2@get_broads

; 128  :       broadflags = 0x10;

	mov	BYTE PTR broadflags, 16

; 129  :       p->input += 4;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 4
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 130  :     }

	jmp	$LN3@get_broads
$LN2@get_broads:

; 131  :     else if (_memicmp(p->input, "1to4", 4) == 0){

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG10907
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN4@get_broads

; 132  :       broadflags = 0x20;

	mov	BYTE PTR broadflags, 32			; 00000020H

; 133  :       p->input += 4;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 4
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 134  :     }

	jmp	$LN5@get_broads
$LN4@get_broads:

; 135  :     else if (_memicmp(p->input, "1to8", 4) == 0){

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG10910
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN6@get_broads

; 136  :       broadflags = 0x30;

	mov	BYTE PTR broadflags, 48			; 00000030H

; 137  :       p->input += 4;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 4
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 138  :     }

	jmp	SHORT $LN7@get_broads
$LN6@get_broads:

; 139  :     else if (_memicmp(p->input, "1to16", 5) == 0){

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG10913
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN8@get_broads

; 140  :       broadflags = 0x40;

	mov	BYTE PTR broadflags, 64			; 00000040H

; 141  :       p->input += 5;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 5
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 142  :     }

	jmp	SHORT $LN9@get_broads
$LN8@get_broads:

; 143  :     else
; 144  :       EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN9@get_broads:
$LN7@get_broads:
$LN5@get_broads:
$LN3@get_broads:

; 145  :     if (*p->input++ != '}')

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv140[rsp], eax
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
	cmp	DWORD PTR tv140[rsp], 125		; 0000007dH
	je	SHORT $LN12@get_broads
	mov	DWORD PTR tv141[rsp], 1
	jmp	SHORT $LN13@get_broads
$LN12@get_broads:
	mov	DWORD PTR tv141[rsp], 0
$LN13@get_broads:
	cmp	DWORD PTR tv141[rsp], 0
	je	SHORT $LN10@get_broads

; 146  :       EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15
	call	EmitError
$LN10@get_broads:

; 147  : 
; 148  :   }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
get_broads ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
sym$ = 32
i$ = 40
tv78 = 44
tokenarray$ = 64
IsMultiLine PROC

; 98   : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 99   :     struct asym *sym;
; 100  :     int i;
; 101  : 
; 102  :     if ( tokenarray[1].token == T_DIRECTIVE && tokenarray[1].tokval == T_EQU )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN2@IsMultiLin
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 443		; 000001bbH
	jne	SHORT $LN2@IsMultiLin

; 103  :         return( FALSE );

	xor	al, al
	jmp	$LN1@IsMultiLin
$LN2@IsMultiLin:

; 104  :     i = ( tokenarray[1].token == T_COLON ? 2 : 0 );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN10@IsMultiLin
	mov	DWORD PTR tv78[rsp], 2
	jmp	SHORT $LN11@IsMultiLin
$LN10@IsMultiLin:
	mov	DWORD PTR tv78[rsp], 0
$LN11@IsMultiLin:
	mov	eax, DWORD PTR tv78[rsp]
	mov	DWORD PTR i$[rsp], eax

; 105  :     /* don't concat macros */
; 106  :     if ( tokenarray[i].token == T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN3@IsMultiLin

; 107  :         sym = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 108  :         if ( sym && ( sym->state == SYM_MACRO )
; 109  : #if VARARGML
; 110  :             && sym->mac_multiline == FALSE  /* v2.11: added */

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN5@IsMultiLin
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN5@IsMultiLin
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@IsMultiLin

; 111  : #endif
; 112  :            )
; 113  :             return( FALSE );

	xor	al, al
	jmp	$LN1@IsMultiLin
$LN5@IsMultiLin:

; 114  :     } else if ( tokenarray[i].token == T_INSTRUCTION ||

	jmp	$LN4@IsMultiLin
$LN3@IsMultiLin:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 1
	je	SHORT $LN7@IsMultiLin
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN6@IsMultiLin
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 441		; 000001b9H
	je	SHORT $LN8@IsMultiLin
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 397		; 0000018dH
	je	SHORT $LN8@IsMultiLin
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 386		; 00000182H
	je	SHORT $LN8@IsMultiLin
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 388		; 00000184H
	jne	SHORT $LN6@IsMultiLin
$LN8@IsMultiLin:
$LN7@IsMultiLin:

; 115  :                ( tokenarray[i].token == T_DIRECTIVE &&
; 116  :                ( tokenarray[i].tokval == T_ECHO ||
; 117  :                 tokenarray[i].tokval == T_INCLUDE ||
; 118  :                 tokenarray[i].tokval == T_FORC ||
; 119  :                 tokenarray[i].tokval == T_IRPC ) ) ) {
; 120  :         return( FALSE );

	xor	al, al
	jmp	SHORT $LN1@IsMultiLin
$LN6@IsMultiLin:
$LN4@IsMultiLin:

; 121  :     }
; 122  :     return( TRUE );

	mov	al, 1
$LN1@IsMultiLin:

; 123  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
IsMultiLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
rc$ = 32
p$ = 56
ptr$4 = 104
line$ = 128
start$ = 136
tokenarray$ = 144
flags$ = 152
Tokenize PROC

; 1082 : {

$LN36:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]

; 1083 :     int                         rc;
; 1084 :     struct line_status          p;
; 1085 : 
; 1086 :     p.input = line;

	mov	rax, QWORD PTR line$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 1087 :     p.start = line;

	mov	rax, QWORD PTR line$[rsp]
	mov	QWORD PTR p$[rsp+16], rax

; 1088 :     p.index = start;

	mov	eax, DWORD PTR start$[rsp]
	mov	DWORD PTR p$[rsp+24], eax

; 1089 :     //p.last_token = T_FINAL; /* v2.11: last_token is obsolete */
; 1090 :     p.flags = flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	BYTE PTR p$[rsp+28], al

; 1091 :     p.flags2 = 0;

	mov	BYTE PTR p$[rsp+29], 0

; 1092 :     p.flags3 = 0;

	mov	BYTE PTR p$[rsp+30], 0

; 1093 :     if ( p.index == 0 ) {

	cmp	DWORD PTR p$[rsp+24], 0
	jne	SHORT $LN11@Tokenize

; 1094 : #ifdef DEBUG_OUT
; 1095 :         cnttok0++;

	mov	eax, DWORD PTR cnttok0
	inc	eax
	mov	DWORD PTR cnttok0, eax

; 1096 : #endif
; 1097 :         /* v2.06: these flags are now initialized on a higher level */
; 1098 :         //ModuleInfo.line_flags = 0;
; 1099 :         p.output = token_stringbuf;

	mov	rax, QWORD PTR token_stringbuf
	mov	QWORD PTR p$[rsp+8], rax

; 1100 :         if( ModuleInfo.inside_comment ) {

	movzx	eax, BYTE PTR ModuleInfo+407
	test	eax, eax
	je	SHORT $LN13@Tokenize

; 1101 :             DebugMsg1(("COMMENT active, delim is >%c<, line is >%s<\n", ModuleInfo.inside_comment, line));

	movzx	eax, BYTE PTR ModuleInfo+407
	mov	r8, QWORD PTR line$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11272
	call	DoDebugMsg1

; 1102 :             if( strchr( line, ModuleInfo.inside_comment ) != NULL ) {

	movzx	eax, BYTE PTR ModuleInfo+407
	mov	edx, eax
	mov	rcx, QWORD PTR line$[rsp]
	call	QWORD PTR __imp_strchr
	test	rax, rax
	je	SHORT $LN14@Tokenize

; 1103 :                 DebugMsg1(("COMMENT mode exited\n"));

	lea	rcx, OFFSET FLAT:$SG11274
	call	DoDebugMsg1

; 1104 :                 ModuleInfo.inside_comment = NULLC;

	mov	BYTE PTR ModuleInfo+407, 0
$LN14@Tokenize:

; 1105 :             }
; 1106 :             goto skipline;

	jmp	$skipline$37
$LN13@Tokenize:

; 1107 :         }
; 1108 :         /* v2.08: expansion operator % at pos 0 is handled differently.
; 1109 :          */
; 1110 :         //while( isspace( *p.input )) p.input++;
; 1111 :         //if ( *p.input == '%' ) {
; 1112 :         //    *p.input++ = ' ';
; 1113 :         //    expansion = TRUE;
; 1114 :         //}
; 1115 :     } else {

	jmp	SHORT $LN12@Tokenize
$LN11@Tokenize:

; 1116 : #ifdef DEBUG_OUT
; 1117 :         cnttok1++;

	mov	eax, DWORD PTR cnttok1
	inc	eax
	mov	DWORD PTR cnttok1, eax

; 1118 : #endif
; 1119 :         p.output = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR p$[rsp+8], rax
$LN12@Tokenize:
$LN2@Tokenize:
$LN5@Tokenize:

; 1120 :     }
; 1121 : 
; 1122 :     for( ;; ) {
; 1123 : 
; 1124 :         while( isspace( *p.input ) ) p.input++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN6@Tokenize
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN5@Tokenize
$LN6@Tokenize:

; 1125 : 
; 1126 :         if ( *p.input == ';' && flags == TOK_DEFAULT ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN15@Tokenize
	cmp	DWORD PTR flags$[rsp], 0
	jne	SHORT $LN15@Tokenize
$LN7@Tokenize:

; 1127 :             while ( p.input > line && isspace( *(p.input-1) ) ) p.input--; /* skip */

	mov	rax, QWORD PTR line$[rsp]
	cmp	QWORD PTR p$[rsp], rax
	jbe	SHORT $LN8@Tokenize
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN8@Tokenize
	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN7@Tokenize
$LN8@Tokenize:

; 1128 :             strcpy( commentbuffer, p.input );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR commentbuffer
	call	strcpy

; 1129 :             ModuleInfo.CurrComment = commentbuffer;

	mov	rax, QWORD PTR commentbuffer
	mov	QWORD PTR ModuleInfo+472, rax

; 1130 :             *p.input = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0
$LN15@Tokenize:

; 1131 :         }
; 1132 : 
; 1133 :         tokenarray[p.index].tokpos = p.input;

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+rax+24], rdx

; 1134 :         if( *p.input == NULLC ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	$LN16@Tokenize

; 1135 :             /* if a comma is last token, concat lines ... with some exceptions
; 1136 :              * v2.05: moved from PreprocessLine(). Moved because the
; 1137 :              * concatenation may be triggered by a comma AFTER expansion.
; 1138 :              */
; 1139 :             if ( p.index > 1 &&
; 1140 :                 tokenarray[p.index-1].token == T_COMMA
; 1141 : #if FASTPASS
; 1142 :                 && ( Parse_Pass == PASS_1 || UseSavedState == FALSE ) /* is it an already preprocessed line? */
; 1143 : #endif
; 1144 :                 && start == 0 ) {

	cmp	DWORD PTR p$[rsp+24], 1
	jbe	$LN17@Tokenize
	mov	eax, DWORD PTR p$[rsp+24]
	dec	eax
	mov	eax, eax
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	$LN17@Tokenize
	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN18@Tokenize
	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	jne	$LN17@Tokenize
$LN18@Tokenize:
	cmp	DWORD PTR start$[rsp], 0
	jne	$LN17@Tokenize

; 1145 :                 DebugMsg1(("Tokenize: calling IsMultiLine()\n" ));

	lea	rcx, OFFSET FLAT:$SG11279
	call	DoDebugMsg1

; 1146 :                 if ( IsMultiLine( tokenarray ) ) {

	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	IsMultiLine
	movzx	eax, al
	test	eax, eax
	je	$LN19@Tokenize

; 1147 :                     char *ptr = GetAlignedPointer( p.output, strlen( p.output ) );

	mov	rcx, QWORD PTR p$[rsp+8]
	call	strlen
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR p$[rsp+8]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$4[rsp], rax

; 1148 :                     DebugMsg1(("Tokenize: IsMultiLine(%s)=TRUE\n", line ));

	mov	rdx, QWORD PTR line$[rsp]
	lea	rcx, OFFSET FLAT:$SG11281
	call	DoDebugMsg1

; 1149 :                     if ( GetTextLine( ptr ) ) {

	mov	rcx, QWORD PTR ptr$4[rsp]
	call	GetTextLine
	test	rax, rax
	je	$LN20@Tokenize
$LN9@Tokenize:

; 1150 :                         while ( isspace( *ptr ) ) ptr++;

	mov	rax, QWORD PTR ptr$4[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN10@Tokenize
	mov	rax, QWORD PTR ptr$4[rsp]
	inc	rax
	mov	QWORD PTR ptr$4[rsp], rax
	jmp	SHORT $LN9@Tokenize
$LN10@Tokenize:

; 1151 :                         if ( *ptr ) {

	mov	rax, QWORD PTR ptr$4[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN21@Tokenize

; 1152 :                             strcpy( p.input, ptr );

	mov	rdx, QWORD PTR ptr$4[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	strcpy

; 1153 :                             if ( strlen( p.start ) >= MAX_LINE_LEN ) {

	mov	rcx, QWORD PTR p$[rsp+16]
	call	strlen
	cmp	rax, 600				; 00000258H
	jb	SHORT $LN22@Tokenize

; 1154 :                                 EmitError( LINE_TOO_LONG );

	mov	ecx, 61					; 0000003dH
	call	EmitError

; 1155 :                                 p.index = start;

	mov	eax, DWORD PTR start$[rsp]
	mov	DWORD PTR p$[rsp+24], eax

; 1156 :                                 break;

	jmp	$LN3@Tokenize
$LN22@Tokenize:

; 1157 :                             }
; 1158 :                             DebugMsg1(("Tokenize: line concatenation, line=%s\n", line ));

	mov	rdx, QWORD PTR line$[rsp]
	lea	rcx, OFFSET FLAT:$SG11285
	call	DoDebugMsg1

; 1159 :                             continue;

	jmp	$LN2@Tokenize
$LN21@Tokenize:
$LN20@Tokenize:
$LN19@Tokenize:
$LN17@Tokenize:

; 1160 :                         }
; 1161 :                     }
; 1162 :                 }
; 1163 :             }
; 1164 :             break;

	jmp	$LN3@Tokenize
$LN16@Tokenize:

; 1165 :         }
; 1166 :         tokenarray[p.index].string_ptr = p.output;

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR p$[rsp+8]
	mov	QWORD PTR [rcx+rax+8], rdx

; 1167 :         rc = GetToken( &tokenarray[p.index], &p );

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR p$[rsp]
	mov	rcx, rax
	call	GetToken
	mov	DWORD PTR rc$[rsp], eax

; 1168 :         if ( rc == EMPTY )

	cmp	DWORD PTR rc$[rsp], -2
	jne	SHORT $LN23@Tokenize

; 1169 :             continue;

	jmp	$LN2@Tokenize
$LN23@Tokenize:

; 1170 :         if ( rc == ERROR ) {

	cmp	DWORD PTR rc$[rsp], -1
	jne	SHORT $LN24@Tokenize

; 1171 :             p.index = start; /* skip this line */

	mov	eax, DWORD PTR start$[rsp]
	mov	DWORD PTR p$[rsp+24], eax

; 1172 :             break;

	jmp	$LN3@Tokenize
$LN24@Tokenize:

; 1173 :         }
; 1174 :         /* v2.04: this has been moved here from condasm.c to
; 1175 :          * avoid problems with (conditional) listings. It also
; 1176 :          * avoids having to search for the first token twice.
; 1177 :          * Note: a conditional assembly directive within an
; 1178 :          *    inactive block and preceded by a label isn't detected!
; 1179 :          *    This is an exact copy of the Masm behavior, although
; 1180 :          *    it probably is just a bug!
; 1181 :          */
; 1182 :         if ( !(flags & TOK_RESCAN) ) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	jne	$LN25@Tokenize

; 1183 :             if ( p.index == 0 || ( p.index == 2 && ( tokenarray[1].token == T_COLON || tokenarray[1].token == T_DBL_COLON) ) ) {

	cmp	DWORD PTR p$[rsp+24], 0
	je	SHORT $LN27@Tokenize
	cmp	DWORD PTR p$[rsp+24], 2
	jne	$LN26@Tokenize
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN28@Tokenize
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 13
	jne	$LN26@Tokenize
$LN28@Tokenize:
$LN27@Tokenize:

; 1184 :                 if ( tokenarray[p.index].token == T_DIRECTIVE &&

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN29@Tokenize
	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	test	eax, eax
	jne	SHORT $LN29@Tokenize

; 1185 :                     tokenarray[p.index].bytval == DRT_CONDDIR ) {
; 1186 :                     if ( tokenarray[p.index].tokval == T_COMMENT ) {

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 358		; 00000166H
	jne	SHORT $LN31@Tokenize

; 1187 :                         DebugMsg1(("tokenize: COMMENT starting, delim is >%c<\n", ModuleInfo.inside_comment));

	movzx	eax, BYTE PTR ModuleInfo+407
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11295
	call	DoDebugMsg1

; 1188 :                         StartComment( p.input );

	mov	rcx, QWORD PTR p$[rsp]
	call	StartComment

; 1189 :                         break; /* p.index is 0 or 2 */

	jmp	$LN3@Tokenize
$LN31@Tokenize:

; 1190 :                     }
; 1191 :                     conditional_assembly_prepare( tokenarray[p.index].tokval );

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+16]
	call	conditional_assembly_prepare

; 1192 :                     if ( CurrIfState != BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, 0
	je	SHORT $LN32@Tokenize

; 1193 :                         p.index++;

	mov	eax, DWORD PTR p$[rsp+24]
	inc	eax
	mov	DWORD PTR p$[rsp+24], eax

; 1194 :                         break; /* p.index is 1 or 3 */

	jmp	$LN3@Tokenize
$LN32@Tokenize:

; 1195 :                     }

	jmp	SHORT $LN30@Tokenize
$LN29@Tokenize:

; 1196 :                 } else if( CurrIfState != BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, 0
	je	SHORT $LN33@Tokenize

; 1197 :                     /* further processing skipped. p.index is 0 */
; 1198 :                     break;

	jmp	SHORT $LN3@Tokenize
$LN33@Tokenize:
$LN30@Tokenize:
$LN26@Tokenize:
$LN25@Tokenize:

; 1199 :                 }
; 1200 :             }
; 1201 :         }
; 1202 :         p.index++;

	mov	eax, DWORD PTR p$[rsp+24]
	inc	eax
	mov	DWORD PTR p$[rsp+24], eax

; 1203 :         if( p.index >= MAX_TOKEN ) {

	cmp	DWORD PTR p$[rsp+24], 150		; 00000096H
	jb	SHORT $LN34@Tokenize

; 1204 :             DebugMsg1(("tokenize: token index %u >= MAX_TOKEN (=%u), line=>%s<\n", p.index, MAX_TOKEN, line ));

	mov	r9, QWORD PTR line$[rsp]
	mov	r8d, 150				; 00000096H
	mov	edx, DWORD PTR p$[rsp+24]
	lea	rcx, OFFSET FLAT:$SG11299
	call	DoDebugMsg1

; 1205 :             EmitError( TOO_MANY_TOKENS );

	mov	ecx, 62					; 0000003eH
	call	EmitError

; 1206 :             p.index = start;

	mov	eax, DWORD PTR start$[rsp]
	mov	DWORD PTR p$[rsp+24], eax

; 1207 :             goto skipline;

	jmp	SHORT $skipline$37
$LN34@Tokenize:

; 1208 :         }
; 1209 : 
; 1210 : #if TOKSTRALIGN
; 1211 :         p.output = GetAlignedPointer( token_stringbuf, p.output - token_stringbuf );

	mov	rax, QWORD PTR token_stringbuf
	mov	rcx, QWORD PTR p$[rsp+8]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR token_stringbuf
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp+8], rax

; 1212 : #endif
; 1213 : 
; 1214 :     }

	jmp	$LN2@Tokenize
$LN3@Tokenize:

; 1215 : #if TOKSTRALIGN
; 1216 :     p.output = GetAlignedPointer( token_stringbuf, p.output - token_stringbuf );

	mov	rax, QWORD PTR token_stringbuf
	mov	rcx, QWORD PTR p$[rsp+8]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR token_stringbuf
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp+8], rax

; 1217 : #endif
; 1218 :     StringBufferEnd = p.output;

	mov	rax, QWORD PTR p$[rsp+8]
	mov	QWORD PTR ModuleInfo+488, rax
$skipline$37:

; 1219 : skipline:
; 1220 :     tokenarray[p.index].token  = T_FINAL;

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 1221 :     tokenarray[p.index].bytval = p.flags3;

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	edx, BYTE PTR p$[rsp+30]
	mov	BYTE PTR [rcx+rax+1], dl

; 1222 :     tokenarray[p.index].string_ptr = "";

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	lea	rdx, OFFSET FLAT:$SG11300
	mov	QWORD PTR [rcx+rax+8], rdx

; 1223 :     return( p.index );

	mov	eax, DWORD PTR p$[rsp+24]

; 1224 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:Tokenize$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
Tokenize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
token$ = 48
p$ = 56
GetToken PROC

; 1034 : {

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 1035 :     if( isdigit( *p->input ) ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isdigit
	test	eax, eax
	je	SHORT $LN2@GetToken

; 1036 :         return( get_number( token, p ) );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR token$[rsp]
	call	get_number
	jmp	$LN1@GetToken
	jmp	$LN3@GetToken
$LN2@GetToken:

; 1037 :     } else if( is_valid_id_start( *p->input ) ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalpha
	test	eax, eax
	jne	SHORT $LN6@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN6@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN6@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN6@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN4@GetToken
$LN6@GetToken:

; 1038 :         return( get_id( token, p ) );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR token$[rsp]
	call	get_id
	jmp	$LN1@GetToken

; 1039 :     } else if( *p->input == '.' &&

	jmp	$LN5@GetToken
$LN4@GetToken:

; 1040 : #if DOTNAMEX /* allow dots within identifiers */
; 1041 :               ( is_valid_id_char(*(p->input+1)) || *(p->input+1) == '.' ) &&
; 1042 : #else
; 1043 :               is_valid_id_char(*(p->input+1)) &&

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	$LN7@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+1]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	SHORT $LN9@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN9@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN9@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN9@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN7@GetToken
$LN9@GetToken:
	mov	rax, QWORD PTR p$[rsp]
	cmp	DWORD PTR [rax+24], 0
	je	SHORT $LN10@GetToken
	mov	eax, 32					; 00000020H
	imul	rax, rax, -1
	mov	rcx, QWORD PTR token$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	je	SHORT $LN7@GetToken
	mov	eax, 32					; 00000020H
	imul	rax, rax, -1
	mov	rcx, QWORD PTR token$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN7@GetToken
	mov	eax, 32					; 00000020H
	imul	rax, rax, -1
	mov	rcx, QWORD PTR token$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN7@GetToken
	mov	eax, 32					; 00000020H
	imul	rax, rax, -1
	mov	rcx, QWORD PTR token$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN7@GetToken
$LN10@GetToken:

; 1044 : #endif
; 1045 :               /* v2.11: member last_token has been removed */
; 1046 :               //( p->last_token != T_REG &&  p->last_token != T_CL_BRACKET && p->last_token != T_CL_SQ_BRACKET && p->last_token != T_ID ) ) {
; 1047 :               ( p->index == 0 || ( token[-1].token != T_REG && token[-1].token != T_CL_BRACKET && token[-1].token != T_CL_SQ_BRACKET && token[-1].token != T_ID ) ) ) {
; 1048 :         return( get_id( token, p ) );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR token$[rsp]
	call	get_id
	jmp	SHORT $LN1@GetToken
	jmp	SHORT $LN8@GetToken
$LN7@GetToken:

; 1049 : #if BACKQUOTES
; 1050 :     } else if( *p->input == '`' && Options.strict_masm_compat == FALSE ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 96					; 00000060H
	jne	SHORT $LN11@GetToken
	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	jne	SHORT $LN11@GetToken

; 1051 :         return( get_id_in_backquotes( token, p ) );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR token$[rsp]
	call	get_id_in_backquotes
	jmp	SHORT $LN1@GetToken
$LN11@GetToken:
$LN8@GetToken:
$LN5@GetToken:
$LN3@GetToken:

; 1052 : #endif
; 1053 :     }
; 1054 :     return( get_special_symbol( token, p ) );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR token$[rsp]
	call	get_special_symbol
$LN1@GetToken:

; 1055 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
GetToken ENDP
_TEXT	ENDS
END
