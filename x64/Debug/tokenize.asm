; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11309 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	cnttok0:DWORD
COMM	cnttok1:DWORD
_DATA	ENDS
CONST	SEGMENT
stokstr1 DW	028H
	DW	029H
	DW	02aH
	DW	02bH
	DW	02cH
	DW	02dH
	DW	02eH
	DW	02fH
stokstr2 DW	05bH
	DW	00H
	DW	05dH
CONST	ENDS
_DATA	SEGMENT
$SG11281 DB	'COMMENT active, delim is >%c<, line is >%s<', 0aH, 00H
	ORG $+3
$SG11283 DB	'COMMENT mode exited', 0aH, 00H
	ORG $+3
$SG11288 DB	'Tokenize: calling IsMultiLine()', 0aH, 00H
	ORG $+3
$SG10921 DB	'1to16', 00H
	ORG $+2
$SG11094 DB	'::', 00H
	ORG $+1
$SG11290 DB	'Tokenize: IsMultiLine(%s)=TRUE', 0aH, 00H
$SG11294 DB	'Tokenize: line concatenation, line=%s', 0aH, 00H
	ORG $+1
$SG11304 DB	'tokenize: COMMENT starting, delim is >%c<', 0aH, 00H
	ORG $+1
$SG11095 DB	':', 00H
	ORG $+2
$SG11308 DB	'tokenize: token index %u >= MAX_TOKEN (=%u), line=>%s<', 0aH
	DB	00H
$SG10912 DB	'1to2', 00H
	ORG $+3
$SG10915 DB	'1to4', 00H
	ORG $+3
$SG10918 DB	'1to8', 00H
	ORG $+3
$SG11062 DB	'Tokenize.get_string: comma concatenation: %s', 0aH, 00H
	ORG $+2
$SG11070 DB	'Tokenize.get_string: backslash concatenation: >%s<', 0aH
	DB	00H
$SG11098 DB	'OUT', 00H
$SG11100 DB	'%', 00H
	ORG $+2
$SG11112 DB	'=', 00H
	ORG $+2
$SG11115 DB	'=!<>&|', 0a6H, 00H
$SG11122 DB	'&', 00H
	ORG $+6
$SG11173 DB	'get_number: BAD_NUMBER (%s), radix=%u, base=%u, ptr=>%s<'
	DB	', digits_seen=%Xh', 0aH, 00H
	ORG $+1
$SG11208 DB	'?', 00H
	ORG $+2
$SG11224 DB	'get_id: error, unknown type in SpecialTable[%u]=%u', 0aH
	DB	00H
	ORG $+4
$SG11225 DB	'tokenize.c', 00H
_DATA	ENDS
PUBLIC	GetToken
PUBLIC	Tokenize
PUBLIC	get_broads
PUBLIC	get_decos
EXTRN	__imp_isalpha:PROC
EXTRN	__imp_isdigit:PROC
EXTRN	__imp_isspace:PROC
EXTRN	__imp_isalnum:PROC
EXTRN	memcpy:PROC
EXTRN	__imp_strchr:PROC
EXTRN	__imp__memicmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	SymFind:PROC
EXTRN	conditional_assembly_prepare:PROC
EXTRN	FindResWord:PROC
EXTRN	GetTextLine:PROC
EXTRN	InternalError:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	_RTC_UninitUse:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	InstrTable:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	optable_idx:BYTE
EXTRN	CurrIfState:DWORD
EXTRN	UseSavedState:BYTE
EXTRN	token_stringbuf:QWORD
EXTRN	commentbuffer:QWORD
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$GetToken DD imagerel $LN13
	DD	imagerel $LN13+494
	DD	imagerel $unwind$GetToken
$pdata$Tokenize DD imagerel $LN36
	DD	imagerel $LN36+1426
	DD	imagerel $unwind$Tokenize
$pdata$IsMultiLine DD imagerel IsMultiLine
	DD	imagerel IsMultiLine+391
	DD	imagerel $unwind$IsMultiLine
$pdata$get_broads DD imagerel $LN15
	DD	imagerel $LN15+389
	DD	imagerel $unwind$get_broads
$pdata$get_decos DD imagerel $LN26
	DD	imagerel $LN26+936
	DD	imagerel $unwind$get_decos
$pdata$get_float DD imagerel get_float
	DD	imagerel get_float+415
	DD	imagerel $unwind$get_float
$pdata$ConcatLine DD imagerel ConcatLine
	DD	imagerel ConcatLine+376
	DD	imagerel $unwind$ConcatLine
$pdata$get_string DD imagerel get_string
	DD	imagerel get_string+2265
	DD	imagerel $unwind$get_string
$pdata$get_special_symbol DD imagerel get_special_symbol
	DD	imagerel get_special_symbol+1633
	DD	imagerel $unwind$get_special_symbol
$pdata$get_number DD imagerel get_number
	DD	imagerel get_number+1652
	DD	imagerel $unwind$get_number
$pdata$get_id_in_backquotes DD imagerel get_id_in_backquotes
	DD	imagerel get_id_in_backquotes+290
	DD	imagerel $unwind$get_id_in_backquotes
$pdata$get_id DD imagerel get_id
	DD	imagerel get_id+1160
	DD	imagerel $unwind$get_id
$pdata$StartComment DD imagerel StartComment
	DD	imagerel StartComment+154
	DD	imagerel $unwind$StartComment
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
CONST	SEGMENT
	ORG $+2
Tokenize$rtcName$0 DB 070H
	DB	00H
	ORG $+6
Tokenize$rtcVarDesc DD 038H
	DD	020H
	DQ	FLAT:Tokenize$rtcName$0
	ORG $+48
Tokenize$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:Tokenize$rtcVarDesc
get_number$rtcName$0 DB 064H
	DB	069H
	DB	067H
	DB	05fH
	DB	065H
	DB	06eH
	DB	064H
	DB	00H
CONST	ENDS
xdata	SEGMENT
$unwind$GetToken DD 022301H
	DD	0700b320fH
$unwind$Tokenize DD 022f01H
	DD	07014d218H
$unwind$IsMultiLine DD 021e01H
	DD	07006520aH
$unwind$get_broads DD 021e01H
	DD	07006520aH
$unwind$get_decos DD 021e01H
	DD	07006520aH
$unwind$get_float DD 022301H
	DD	0700b720fH
$unwind$ConcatLine DD 022c01H
	DD	070147218H
$unwind$get_string DD 022601H
	DD	0700bd20fH
$unwind$get_special_symbol DD 022301H
	DD	0700b720fH
$unwind$get_number DD 032901H
	DD	0120112H
	DD	0700bH
$unwind$get_id_in_backquotes DD 022301H
	DD	0700b520fH
$unwind$get_id DD 022301H
	DD	0700b720fH
$unwind$StartComment DD 021e01H
	DD	07006320aH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
p$ = 48
StartComment PROC

; 1068 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]
$LN2@StartComme:

; 1069 :     while ( isspace( *p ) ) p++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN3@StartComme
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN2@StartComme
$LN3@StartComme:

; 1070 :     if ( *p == NULLC ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN4@StartComme

; 1071 :         EmitError( COMMENT_DELIMITER_EXPECTED );

	mov	ecx, 99					; 00000063H
	call	EmitError

; 1072 :         return;

	jmp	SHORT $LN1@StartComme
$LN4@StartComme:

; 1073 :     }
; 1074 :     ModuleInfo.inside_comment = *p++;

	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR ModuleInfo+407, al
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 1075 :     if( strchr( p, ModuleInfo.inside_comment ) )

	movzx	eax, BYTE PTR ModuleInfo+407
	mov	edx, eax
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp_strchr
	test	rax, rax
	je	SHORT $LN5@StartComme

; 1076 :         ModuleInfo.inside_comment = NULLC;

	mov	BYTE PTR ModuleInfo+407, 0
$LN5@StartComme:
$LN1@StartComme:

; 1077 :     return;
; 1078 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
StartComment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
src$ = 32
dst$ = 40
index$ = 48
size$ = 52
tv195 = 56
buf$ = 80
p$ = 88
get_id	PROC

; 855  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 856  :     //struct ReservedWord *resw;
; 857  :     char *src = p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR src$[rsp], rax

; 858  :     char *dst = p->output;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR dst$[rsp], rax
$LN30@get_id:
$LN29@get_id:
$LN28@get_id:
$LN27@get_id:
$LN4@get_id:

; 859  :     int  index;
; 860  :     unsigned size;
; 861  : 
; 862  : #if CONCATID || DOTNAMEX
; 863  : continue_scan:
; 864  : #endif
; 865  :     do {
; 866  :         *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 867  :     } while ( is_valid_id_char( *src ) );

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	SHORT $LN4@get_id
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN27@get_id
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN28@get_id
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN29@get_id
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN30@get_id

; 868  : #if CONCATID
; 869  :     /* v2.05: in case there's a backslash right behind
; 870  :      * the ID, check if a line concatenation is to occur.
; 871  :      * If yes, and the first char of the concatenated line
; 872  :      * is also a valid ID char, continue to scan the name.
; 873  :      * Problem: it's ok for EQU, but less good for other directives.
; 874  :      */
; 875  :     if ( *src == '\\' ) {
; 876  :         if ( ConcatLine( src, src - p->input, dst, p ) != EMPTY ) {
; 877  :             p->concat = TRUE;
; 878  :             if ( is_valid_id_char( *src ) )
; 879  :                 goto continue_scan;
; 880  :         }
; 881  :     }
; 882  : #endif
; 883  : #if DOTNAMEX
; 884  :     /* if the name starts with a dot or underscore, then accept dots
; 885  :      * within the name (though not as last char). OPTION DOTNAME
; 886  :      * must be on.
; 887  :      */
; 888  :     if ( *src == '.' && ModuleInfo.dotname &&
; 889  :         ( *(p->output) == '.' || *(p->output) == '_' ) &&
; 890  :         ( is_valid_id_char(*(src+1)) || *(src+1) == '.' ) )
; 891  :         goto continue_scan;
; 892  : #endif
; 893  :     /* v2.04: check added */
; 894  :     size = dst - p->output;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR dst$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR size$[rsp], eax

; 895  :     if ( size > MAX_ID_LEN ) {

	cmp	DWORD PTR size$[rsp], 247		; 000000f7H
	jbe	SHORT $LN9@get_id

; 896  :         EmitErr( IDENTIFIER_TOO_LONG );

	mov	ecx, 71					; 00000047H
	call	EmitErr

; 897  :         dst = p->output + MAX_ID_LEN;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 247				; 000000f7H
	mov	QWORD PTR dst$[rsp], rax
$LN9@get_id:

; 898  :     }
; 899  :     *dst++ = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 900  : 
; 901  :     /* now decide what to do with it */
; 902  : 
; 903  :     if( size == 1 && *p->output == '?' ) {

	cmp	DWORD PTR size$[rsp], 1
	jne	SHORT $LN10@get_id
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN10@get_id

; 904  :         p->input = src;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	QWORD PTR [rax], rcx

; 905  :         buf->token = T_QUESTION_MARK;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 63			; 0000003fH

; 906  :         buf->string_ptr = "?";

	mov	rax, QWORD PTR buf$[rsp]
	lea	rcx, OFFSET FLAT:$SG11208
	mov	QWORD PTR [rax+8], rcx

; 907  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_id
$LN10@get_id:

; 908  :     }
; 909  :     index = FindResWord( p->output, size );

	movzx	edx, BYTE PTR size$[rsp]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	FindResWord
	mov	DWORD PTR index$[rsp], eax

; 910  :     if( index == 0 ) {

	cmp	DWORD PTR index$[rsp], 0
	jne	$LN11@get_id

; 911  :         /* if ID begins with a DOT, check for OPTION DOTNAME.
; 912  :          * if not set, skip the token and return a T_DOT instead!
; 913  :          */
; 914  :         if ( *p->output == '.' && ModuleInfo.dotname == FALSE ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN12@get_id
	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN12@get_id

; 915  :            buf->token = T_DOT;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH

; 916  :            buf->string_ptr = (char *)&stokstr1['.' - '('];

	mov	eax, 2
	imul	rax, rax, 6
	lea	rcx, OFFSET FLAT:stokstr1
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR buf$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 917  :            p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 918  :            return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_id
$LN12@get_id:

; 919  :         }
; 920  :         p->input = src;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	QWORD PTR [rax], rcx

; 921  :         p->output = dst;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 922  :         buf->token = T_ID;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 8

; 923  :         buf->idarg = 0;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 0

; 924  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_id
$LN11@get_id:

; 925  :     }
; 926  :     p->input = src;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	QWORD PTR [rax], rcx

; 927  :     p->output = dst;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 928  :     buf->tokval = index; /* is a enum instr_token value */

	mov	rax, QWORD PTR buf$[rsp]
	mov	ecx, DWORD PTR index$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 929  :     /* v2.11: RWF_SPECIAL now obsolete */
; 930  :     //if ( ! ( ResWordTable[index].flags & RWF_SPECIAL ) ) {
; 931  :     if ( index >= SPECIAL_LAST ) {

	cmp	DWORD PTR index$[rsp], 450		; 000001c2H
	jl	$LN13@get_id

; 932  : 
; 933  :         //  DebugMsg(("found item >%s< in instruction table, rm=%X\n", buf->string_ptr, InstrTable[index].rm_byte));
; 934  : 
; 935  :         /* if -Zm is set, the following from the Masm docs is relevant:
; 936  :          *
; 937  :          * Reserved Keywords Dependent on CPU Mode with OPTION M510
; 938  :          *
; 939  :          * With OPTION M510, keywords and instructions not available in the
; 940  :          * current CPU mode (such as ENTER under .8086) are not treated as
; 941  :          * keywords. This also means the USE32, FLAT, FAR32, and NEAR32 segment
; 942  :          * types and the 80386/486 registers are not keywords with a processor
; 943  :          * selection less than .386.
; 944  :          * If you remove OPTION M510, any reserved word used as an identifier
; 945  :          * generates a syntax error. You can either rename the identifiers or
; 946  :          * use OPTION NOKEYWORD. For more information on OPTION NOKEYWORD, see
; 947  :          * OPTION NOKEYWORD, later in this appendix.
; 948  :          *
; 949  :          * The current implementation of this rule below is likely to be improved.
; 950  :          */
; 951  :         if ( ModuleInfo.m510 ) {

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 6
	and	eax, 1
	test	eax, eax
	je	$LN14@get_id

; 952  :             /* checking the cpu won't give the expected results currently since
; 953  :              * some instructions in the table (i.e. MOV) start with a 386 variant!
; 954  :              */
; 955  :             index = IndexFromToken( buf->tokval );

	mov	rax, QWORD PTR buf$[rsp]
	mov	eax, DWORD PTR [rax+16]
	sub	eax, 450				; 000001c2H
	mov	eax, eax
	lea	rcx, OFFSET FLAT:optable_idx
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	DWORD PTR index$[rsp], eax

; 956  : #if 0 /* changed for v1.96 */
; 957  :             if (( InstrTable[index].cpu & P_EXT_MASK ) > ( ModuleInfo.curr_cpu & P_EXT_MASK )) {
; 958  : #else
; 959  :             if (( InstrTable[index].cpu & P_CPU_MASK ) > ( ModuleInfo.curr_cpu & P_CPU_MASK ) ||

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 14
	lea	rcx, OFFSET FLAT:InstrTable
	movzx	eax, WORD PTR [rcx+rax+10]
	and	eax, 240				; 000000f0H
	mov	ecx, DWORD PTR ModuleInfo+392
	and	ecx, 240				; 000000f0H
	cmp	eax, ecx
	jg	SHORT $LN16@get_id
	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 14
	lea	rcx, OFFSET FLAT:InstrTable
	movzx	eax, WORD PTR [rcx+rax+10]
	and	eax, 65280				; 0000ff00H
	mov	ecx, DWORD PTR ModuleInfo+392
	and	ecx, 65280				; 0000ff00H
	cmp	eax, ecx
	jle	SHORT $LN15@get_id
$LN16@get_id:

; 960  :                 ( InstrTable[index].cpu & P_EXT_MASK ) > ( ModuleInfo.curr_cpu & P_EXT_MASK )) {
; 961  : #endif
; 962  :                 buf->token = T_ID;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 8

; 963  :                 buf->idarg = 0;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 0

; 964  :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_id
$LN15@get_id:
$LN14@get_id:

; 965  :             }
; 966  :         }
; 967  :         buf->token = T_INSTRUCTION;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 1

; 968  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_id
$LN13@get_id:

; 969  :     }
; 970  :     index = buf->tokval;

	mov	rax, QWORD PTR buf$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR index$[rsp], eax

; 971  : 
; 972  :     /* for RWT_SPECIAL, field <bytval> contains further infos:
; 973  :      - RWT_REG:             register number (regnum)
; 974  :      - RWT_DIRECTIVE:       type of directive (dirtype)
; 975  :      - RWT_UNARY_OPERATOR:  operator precedence
; 976  :      - RWT_BINARY_OPERATOR: operator precedence
; 977  :      - RWT_STYPE:           memtype
; 978  :      - RWT_RES_ID:          for languages, LANG_xxx value
; 979  :                             for the rest, unused.
; 980  :      */
; 981  :     buf->bytval = SpecialTable[index].bytval;

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	rdx, QWORD PTR buf$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+10]
	mov	BYTE PTR [rdx+1], al

; 982  : 
; 983  :     switch ( SpecialTable[index].type ) {

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+11]
	mov	DWORD PTR tv195[rsp], eax
	mov	eax, DWORD PTR tv195[rsp]
	sub	eax, 2
	mov	DWORD PTR tv195[rsp], eax
	cmp	DWORD PTR tv195[rsp], 5
	ja	$LN25@get_id
	movsxd	rax, DWORD PTR tv195[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN31@get_id[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN17@get_id:

; 984  :     case RWT_REG:
; 985  :         buf->token = T_REG;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 2
$LN7@get_id:

; 986  : #if AVXSUPP 
; 987  :         /* Intercept here '{' for EVEX mask  {k1}{z} */
; 988  :         while ( isspace( *p->input )) p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN8@get_id
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN7@get_id
$LN8@get_id:

; 989  :         if (*p->input == '{'){

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN18@get_id

; 990  :           p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 991  :           get_decos( p ) ; // mask decorators

	mov	rcx, QWORD PTR p$[rsp]
	call	get_decos
$LN18@get_id:

; 992  :       }
; 993  : #endif        
; 994  :         break;

	jmp	$LN5@get_id
$LN19@get_id:

; 995  :     case RWT_DIRECTIVE:
; 996  :         buf->token = T_DIRECTIVE;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 3

; 997  :         if ( p->flags2 == 0 )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+29]
	test	eax, eax
	jne	SHORT $LN20@get_id

; 998  :             p->flags2 = SpecialTable[index].value;

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdx+29], al
$LN20@get_id:

; 999  :         break;

	jmp	SHORT $LN5@get_id
$LN21@get_id:

; 1000 :     case RWT_UNARY_OP: /* OFFSET, LOW, HIGH, LOWWORD, HIGHWORD, SHORT, ... */
; 1001 :         buf->token  = T_UNARY_OPERATOR;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 4

; 1002 :         break;

	jmp	SHORT $LN5@get_id
$LN22@get_id:

; 1003 :     case RWT_BINARY_OP: /* GE, GT, LE, LT, EQ, NE, MOD, PTR */
; 1004 :         buf->token = T_BINARY_OPERATOR;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 5

; 1005 :         break;

	jmp	SHORT $LN5@get_id
$LN23@get_id:

; 1006 :     case RWT_STYPE:  /* BYTE, WORD, FAR, NEAR, FAR16, NEAR32 ... */
; 1007 :         buf->token = T_STYPE;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 6

; 1008 :         break;

	jmp	SHORT $LN5@get_id
$LN24@get_id:

; 1009 :     case RWT_RES_ID: /* DUP, ADDR, FLAT, VARARG, language types [, FRAME (64-bit)] */
; 1010 :         buf->token = T_RES_ID;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 7

; 1011 :         break;

	jmp	SHORT $LN5@get_id
$LN25@get_id:

; 1012 :     default: /* shouldn't happen */
; 1013 :         DebugMsg(("get_id: error, unknown type in SpecialTable[%u]=%u\n", index, SpecialTable[index].type ));

	movsxd	rax, DWORD PTR index$[rsp]
	imul	rax, rax, 12
	lea	rcx, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rcx+rax+11]
	mov	r8d, eax
	mov	edx, DWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:$SG11224
	call	DoDebugMsg

; 1014 :         /**/myassert( 0 );

	mov	edx, 1014				; 000003f6H
	lea	rcx, OFFSET FLAT:$SG11225
	call	InternalError

; 1015 :         buf->token = T_ID;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 8

; 1016 :         buf->idarg = 0;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 0
$LN5@get_id:

; 1017 :         break;
; 1018 :     }
; 1019 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@get_id:

; 1020 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
	npad	3
$LN31@get_id:
	DD	$LN17@get_id
	DD	$LN19@get_id
	DD	$LN21@get_id
	DD	$LN22@get_id
	DD	$LN23@get_id
	DD	$LN24@get_id
get_id	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
optr$ = 32
buf$ = 64
p$ = 72
get_id_in_backquotes PROC

; 830  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 831  :     char *optr = p->output;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR optr$[rsp], rax

; 832  :     buf->token = T_ID;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 8

; 833  :     buf->idarg = 0;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 0

; 834  : 
; 835  :     p->input++;         /* strip off the backquotes */

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
$LN2@get_id_in_:

; 836  :     for( ; *p->input != '`'; ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 96					; 00000060H
	je	SHORT $LN3@get_id_in_

; 837  :         if( *p->input == NULLC || *p->input == ';' ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN6@get_id_in_
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN5@get_id_in_
$LN6@get_id_in_:

; 838  :             *p->output = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax], 0

; 839  :             EmitErr( BACKQUOTE_MISSING, p->output );

	mov	rax, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 98					; 00000062H
	call	EmitErr

; 840  :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@get_id_in_
$LN5@get_id_in_:

; 841  :         }
; 842  :         *optr++ = *p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR optr$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR optr$[rsp]
	inc	rax
	mov	QWORD PTR optr$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 843  :     }

	jmp	$LN2@get_id_in_
$LN3@get_id_in_:

; 844  :     p->input++;         /* skip the terminating '`' */

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 845  :     *optr++ = NULLC;

	mov	rax, QWORD PTR optr$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR optr$[rsp]
	inc	rax
	mov	QWORD PTR optr$[rsp], rax

; 846  :     p->output = optr;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR optr$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 847  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@get_id_in_:

; 848  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
get_id_in_backquotes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
ptr$ = 48
dig_start$ = 56
dig_end$ = 64
base$ = 72
len$ = 76
digits_seen$ = 80
last_char$ = 84
tmp$2 = 88
max$3 = 96
$T4 = 97
tv78 = 100
tv286 = 104
tv129 = 108
tv297 = 112
tv148 = 116
tv173 = 120
tv323 = 124
tv184 = 128
tv195 = 132
tv335 = 136
buf$ = 160
p$ = 168
get_number PROC

; 673  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 144				; 00000090H
	mov	rdi, rsp
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+160]
	mov	BYTE PTR $T4[rsp], 0

; 674  :     char                *ptr = p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ptr$[rsp], rax

; 675  :     char                *dig_start;
; 676  :     char                *dig_end;
; 677  :     unsigned            base = 0;

	mov	DWORD PTR base$[rsp], 0

; 678  :     unsigned            len;
; 679  :     uint_32             digits_seen;
; 680  :     char                last_char;
; 681  : 
; 682  : #define VALID_BINARY    0x0003
; 683  : #define VALID_OCTAL     0x00ff
; 684  : #define VALID_DECIMAL   0x03ff
; 685  : #define OK_NUM( t )     ((digits_seen & ~VALID_##t) == 0)
; 686  : 
; 687  :     digits_seen = 0;

	mov	DWORD PTR digits_seen$[rsp], 0

; 688  : #if CHEXPREFIX
; 689  :     if( *ptr == '0' && (tolower( *(ptr+1) ) == 'x' ) ) {

	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN12@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN38@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 90					; 0000005aH
	jg	SHORT $LN38@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	or	eax, 32					; 00000020H
	mov	DWORD PTR tv78[rsp], eax
	jmp	SHORT $LN39@get_number
$LN38@get_number:
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	mov	DWORD PTR tv78[rsp], eax
$LN39@get_number:
	cmp	DWORD PTR tv78[rsp], 120		; 00000078H
	jne	SHORT $LN12@get_number

; 690  :         ptr += 2;

	mov	rax, QWORD PTR ptr$[rsp]
	add	rax, 2
	mov	QWORD PTR ptr$[rsp], rax

; 691  :         base = 16;

	mov	DWORD PTR base$[rsp], 16
$LN12@get_number:

; 692  :     }
; 693  : #endif
; 694  :     dig_start = ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR dig_start$[rsp], rax
	jmp	SHORT $LN4@get_number
$LN2@get_number:

; 695  :     for( ;; ptr++ ) {

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN4@get_number:

; 696  :         if (*ptr >= '0' && *ptr <= '9')

	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN13@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN13@get_number

; 697  :             digits_seen |= 1 << (*ptr - '0');

	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	ecx, 1
	mov	DWORD PTR tv286[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv286[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR digits_seen$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR digits_seen$[rsp], eax
	jmp	SHORT $LN14@get_number
$LN13@get_number:

; 698  :         else {
; 699  :             last_char = tolower( *ptr );

	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN40@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 90					; 0000005aH
	jg	SHORT $LN40@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	or	eax, 32					; 00000020H
	mov	DWORD PTR tv129[rsp], eax
	jmp	SHORT $LN41@get_number
$LN40@get_number:
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv129[rsp], eax
$LN41@get_number:
	movzx	eax, BYTE PTR tv129[rsp]
	mov	BYTE PTR last_char$[rsp], al

; 700  :             if ( last_char >= 'a' && last_char <= 'f' )

	movsx	eax, BYTE PTR last_char$[rsp]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN15@get_number
	movsx	eax, BYTE PTR last_char$[rsp]
	cmp	eax, 102				; 00000066H
	jg	SHORT $LN15@get_number

; 701  :                 digits_seen |= 1 << ( last_char + 10 - 'a' );

	movsx	eax, BYTE PTR last_char$[rsp]
	sub	eax, 87					; 00000057H
	mov	ecx, 1
	mov	DWORD PTR tv297[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv297[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR digits_seen$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR digits_seen$[rsp], eax
	jmp	SHORT $LN16@get_number
$LN15@get_number:

; 702  :             else
; 703  :                 break;

	jmp	SHORT $LN3@get_number
$LN16@get_number:
$LN14@get_number:

; 704  :         }
; 705  :     }

	jmp	$LN2@get_number
$LN3@get_number:

; 706  : 
; 707  :     /* note that a float MUST contain a dot.
; 708  :      * 1234e78 is NOT a valid float
; 709  :      */
; 710  :     if ( last_char == '.' )

	movsx	eax, BYTE PTR last_char$[rsp]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN17@get_number

; 711  :         return( get_float( buf, p ) );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	get_float
	jmp	$LN1@get_number
$LN17@get_number:

; 712  : 
; 713  : #if 0
; 714  :     /* v2.08: if suffix isn't followed by a non-id char, don't use it! */
; 715  :     if ( last_char && is_valid_id_char( *(ptr+1) ) ) {
; 716  :         last_char = NULLC;
; 717  :         while ( *(ptr-1) > '9' )
; 718  :             ptr--;
; 719  :         digits_seen &= 0x3FF;
; 720  : 
; 721  :     }
; 722  : #endif
; 723  : 
; 724  : #if CHEXPREFIX
; 725  :     if ( base != 0 ) {

	cmp	DWORD PTR base$[rsp], 0
	je	SHORT $LN18@get_number

; 726  :         dig_end = ptr;

	mov	BYTE PTR $T4[rsp], 1
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR dig_end$[rsp], rax

; 727  :         if ( digits_seen == 0 )

	cmp	DWORD PTR digits_seen$[rsp], 0
	jne	SHORT $LN20@get_number

; 728  :             base = 0;

	mov	DWORD PTR base$[rsp], 0
$LN20@get_number:

; 729  :     } else

	jmp	$LN19@get_number
$LN18@get_number:

; 730  : #endif
; 731  :     switch( last_char ) {

	movsx	eax, BYTE PTR last_char$[rsp]
	mov	DWORD PTR tv148[rsp], eax
	mov	eax, DWORD PTR tv148[rsp]
	sub	eax, 104				; 00000068H
	mov	DWORD PTR tv148[rsp], eax
	cmp	DWORD PTR tv148[rsp], 17
	ja	$LN29@get_number
	movsxd	rax, DWORD PTR tv148[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN51@get_number[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN21@get_number:

; 732  :     case 'r': /* a float with the "real number designator" */
; 733  :         buf->token = T_FLOAT;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 11

; 734  :         buf->floattype = 'r';

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 114			; 00000072H

; 735  :         ptr++;

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax

; 736  :         goto number_done;

	jmp	$number_done$52
$LN22@get_number:

; 737  :     case 'h':
; 738  :         base = 16;

	mov	DWORD PTR base$[rsp], 16

; 739  :         dig_end = ptr;

	mov	BYTE PTR $T4[rsp], 1
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR dig_end$[rsp], rax

; 740  :         ptr++;

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax

; 741  :         break;

	jmp	$LN5@get_number
$LN23@get_number:

; 742  :     //case 'b':
; 743  :     case 'y':
; 744  :         if( OK_NUM( BINARY ) ) {

	mov	eax, DWORD PTR digits_seen$[rsp]
	and	eax, -4					; fffffffcH
	test	eax, eax
	jne	SHORT $LN24@get_number

; 745  :             base = 2;

	mov	DWORD PTR base$[rsp], 2

; 746  :             dig_end = ptr;

	mov	BYTE PTR $T4[rsp], 1
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR dig_end$[rsp], rax

; 747  :             ptr++;

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN24@get_number:

; 748  :         }
; 749  :         break;

	jmp	$LN5@get_number
$LN25@get_number:

; 750  :     //case 'd':
; 751  :     case 't':
; 752  :         if( OK_NUM( DECIMAL ) ) {

	mov	eax, DWORD PTR digits_seen$[rsp]
	and	eax, -1024				; fffffc00H
	test	eax, eax
	jne	SHORT $LN26@get_number

; 753  :             base = 10;

	mov	DWORD PTR base$[rsp], 10

; 754  :             dig_end = ptr;

	mov	BYTE PTR $T4[rsp], 1
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR dig_end$[rsp], rax

; 755  :             ptr++;

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN26@get_number:

; 756  :         }
; 757  :         break;

	jmp	$LN5@get_number
$LN27@get_number:

; 758  :     case 'q':
; 759  :     case 'o':
; 760  :         if( OK_NUM( OCTAL ) ) {

	mov	eax, DWORD PTR digits_seen$[rsp]
	and	eax, -256				; ffffff00H
	test	eax, eax
	jne	SHORT $LN28@get_number

; 761  :             base = 8;

	mov	DWORD PTR base$[rsp], 8

; 762  :             dig_end = ptr;

	mov	BYTE PTR $T4[rsp], 1
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR dig_end$[rsp], rax

; 763  :             ptr++;

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN28@get_number:

; 764  :         }
; 765  :         break;

	jmp	$LN5@get_number
$LN29@get_number:

; 766  :     default:
; 767  :         last_char = tolower( *(ptr-1) );

	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN42@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	cmp	eax, 90					; 0000005aH
	jg	SHORT $LN42@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	or	eax, 32					; 00000020H
	mov	DWORD PTR tv173[rsp], eax
	jmp	SHORT $LN43@get_number
$LN42@get_number:
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	mov	DWORD PTR tv173[rsp], eax
$LN43@get_number:
	movzx	eax, BYTE PTR tv173[rsp]
	mov	BYTE PTR last_char$[rsp], al

; 768  :         if ( ( last_char == 'b' || last_char == 'd' ) && digits_seen >= ( 1UL << ModuleInfo.radix ) ) {

	movsx	eax, BYTE PTR last_char$[rsp]
	cmp	eax, 98					; 00000062H
	je	SHORT $LN31@get_number
	movsx	eax, BYTE PTR last_char$[rsp]
	cmp	eax, 100				; 00000064H
	jne	$LN30@get_number
$LN31@get_number:
	movzx	eax, BYTE PTR ModuleInfo+396
	mov	ecx, 1
	mov	DWORD PTR tv323[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv323[rsp]
	shl	eax, cl
	cmp	DWORD PTR digits_seen$[rsp], eax
	jb	$LN30@get_number

; 769  :             char *tmp = dig_start;

	mov	rax, QWORD PTR dig_start$[rsp]
	mov	QWORD PTR tmp$2[rsp], rax

; 770  :             char max = ( last_char == 'b' ? '1' : '9' );

	movsx	eax, BYTE PTR last_char$[rsp]
	cmp	eax, 98					; 00000062H
	jne	SHORT $LN44@get_number
	mov	DWORD PTR tv184[rsp], 49		; 00000031H
	jmp	SHORT $LN45@get_number
$LN44@get_number:
	mov	DWORD PTR tv184[rsp], 57		; 00000039H
$LN45@get_number:
	movzx	eax, BYTE PTR tv184[rsp]
	mov	BYTE PTR max$3[rsp], al

; 771  :             for ( dig_end = ptr-1; tmp < dig_end && *tmp <= max; tmp++ );

	mov	rax, QWORD PTR ptr$[rsp]
	dec	rax
	mov	BYTE PTR $T4[rsp], 1
	mov	QWORD PTR dig_end$[rsp], rax
	jmp	SHORT $LN9@get_number
$LN7@get_number:
	mov	rax, QWORD PTR tmp$2[rsp]
	inc	rax
	mov	QWORD PTR tmp$2[rsp], rax
$LN9@get_number:
	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN48@get_number
	lea	rcx, OFFSET FLAT:get_number$rtcName$0
	call	_RTC_UninitUse
$LN48@get_number:
	mov	rax, QWORD PTR dig_end$[rsp]
	cmp	QWORD PTR tmp$2[rsp], rax
	jae	SHORT $LN8@get_number
	mov	rax, QWORD PTR tmp$2[rsp]
	movsx	eax, BYTE PTR [rax]
	movsx	ecx, BYTE PTR max$3[rsp]
	cmp	eax, ecx
	jg	SHORT $LN8@get_number
	jmp	SHORT $LN7@get_number
$LN8@get_number:

; 772  :             if ( tmp == dig_end ) {

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN49@get_number
	lea	rcx, OFFSET FLAT:get_number$rtcName$0
	call	_RTC_UninitUse
$LN49@get_number:
	mov	rax, QWORD PTR dig_end$[rsp]
	cmp	QWORD PTR tmp$2[rsp], rax
	jne	SHORT $LN32@get_number

; 773  :                 base = ( last_char == 'b' ? 2 : 10 );

	movsx	eax, BYTE PTR last_char$[rsp]
	cmp	eax, 98					; 00000062H
	jne	SHORT $LN46@get_number
	mov	DWORD PTR tv195[rsp], 2
	jmp	SHORT $LN47@get_number
$LN46@get_number:
	mov	DWORD PTR tv195[rsp], 10
$LN47@get_number:
	mov	eax, DWORD PTR tv195[rsp]
	mov	DWORD PTR base$[rsp], eax

; 774  :                 break;

	jmp	SHORT $LN5@get_number
$LN32@get_number:
$LN30@get_number:

; 775  :             }
; 776  :         }
; 777  :         dig_end = ptr;

	mov	BYTE PTR $T4[rsp], 1
	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR dig_end$[rsp], rax

; 778  : #if COCTALS
; 779  :         if( Options.allow_c_octals && *dig_start == '0' ) {
; 780  :             if( OK_NUM( OCTAL ) ) {
; 781  :                 base = 8;
; 782  :                 break;
; 783  :             }
; 784  :         }
; 785  : #endif
; 786  :         /* radix      max. digits_seen
; 787  :          -----------------------------------------------------------
; 788  :          2            3      2^2-1  (0,1)
; 789  :          8            255    2^8-1  (0,1,2,3,4,5,6,7)
; 790  :          10           1023   2^10-1 (0,1,2,3,4,5,6,7,8,9)
; 791  :          16           65535  2^16-1 (0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f)
; 792  :          */
; 793  :         if ( digits_seen < (1UL << ModuleInfo.radix) )

	movzx	eax, BYTE PTR ModuleInfo+396
	mov	ecx, 1
	mov	DWORD PTR tv335[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv335[rsp]
	shl	eax, cl
	cmp	DWORD PTR digits_seen$[rsp], eax
	jae	SHORT $LN33@get_number

; 794  :             base = ModuleInfo.radix;

	movzx	eax, BYTE PTR ModuleInfo+396
	mov	DWORD PTR base$[rsp], eax
$LN33@get_number:
$LN5@get_number:
$LN19@get_number:

; 795  :         break;
; 796  :     }
; 797  : 
; 798  : #if MASMNUMBER
; 799  :     /* Masm doesn't swallow alphanum chars which may follow the
; 800  :      * number!
; 801  :      */
; 802  :     if ( base != 0 ) {

	cmp	DWORD PTR base$[rsp], 0
	je	SHORT $LN34@get_number

; 803  : #else
; 804  :     if ( base != 0 && is_valid_id_char( *ptr ) == FALSE ) {
; 805  : #endif
; 806  :         buf->token = T_NUM;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 10

; 807  :         buf->numbase = base;

	mov	rax, QWORD PTR buf$[rsp]
	movzx	ecx, BYTE PTR base$[rsp]
	mov	BYTE PTR [rax+1], cl

; 808  :         buf->itemlen = dig_end - dig_start;

	cmp	BYTE PTR $T4[rsp], 0
	jne	SHORT $LN50@get_number
	lea	rcx, OFFSET FLAT:get_number$rtcName$0
	call	_RTC_UninitUse
$LN50@get_number:
	mov	rax, QWORD PTR dig_start$[rsp]
	mov	rcx, QWORD PTR dig_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 809  :         //DebugMsg(("get_number: inp=%s, value=%" I32_SPEC "X\n", p->input, buf->value64 ));
; 810  :     } else {

	jmp	$LN35@get_number
$LN34@get_number:

; 811  :         buf->token = T_BAD_NUM;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 12

; 812  :         DebugMsg(("get_number: BAD_NUMBER (%s), radix=%u, base=%u, ptr=>%s<, digits_seen=%Xh\n", dig_start, ModuleInfo.radix, base, ptr, digits_seen ));

	movzx	eax, BYTE PTR ModuleInfo+396
	mov	ecx, DWORD PTR digits_seen$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, DWORD PTR base$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR dig_start$[rsp]
	lea	rcx, OFFSET FLAT:$SG11173
	call	DoDebugMsg
$LN10@get_number:

; 813  :         /* swallow remainder of token */
; 814  :         while( is_valid_id_char( *ptr ) ) ++ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	SHORT $LN36@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN36@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN36@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN36@get_number
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN11@get_number
$LN36@get_number:
	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
	jmp	SHORT $LN10@get_number
$LN11@get_number:
$LN35@get_number:
$number_done$52:

; 815  :     }
; 816  : number_done:
; 817  :     len = ptr - p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR ptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR len$[rsp], eax

; 818  :     memcpy( p->output, p->input, len );

	mov	eax, DWORD PTR len$[rsp]
	mov	r8d, eax
	mov	rax, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy

; 819  : 
; 820  :     p->output += len;

	mov	eax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 821  :     *p->output++ = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 822  :     p->input = ptr;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 823  : 
; 824  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@get_number:

; 825  : }

	add	rsp, 144				; 00000090H
	pop	rdi
	ret	0
	npad	3
$LN51@get_number:
	DD	$LN22@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN27@get_number
	DD	$LN29@get_number
	DD	$LN27@get_number
	DD	$LN21@get_number
	DD	$LN29@get_number
	DD	$LN25@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN23@get_number
get_number ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
symbol$ = 32
c$ = 33
sym$1 = 48
tv67 = 56
buf$ = 80
p$ = 88
get_special_symbol PROC

; 511  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 512  :     char    symbol;
; 513  :     char    c;
; 514  :     int     i;
; 515  :     int  index;
; 516  : 
; 517  :     symbol = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR symbol$[rsp], al

; 518  :     switch( symbol ) {

	movsx	eax, BYTE PTR symbol$[rsp]
	mov	DWORD PTR tv67[rsp], eax
	mov	eax, DWORD PTR tv67[rsp]
	sub	eax, 37					; 00000025H
	mov	DWORD PTR tv67[rsp], eax
	cmp	DWORD PTR tv67[rsp], 56			; 00000038H
	ja	$LN23@get_specia
	movsxd	rax, DWORD PTR tv67[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN32@get_specia[rcx+rax]
	mov	eax, DWORD PTR $LN33@get_specia[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN6@get_specia:

; 519  :     case ':' : /* T_COLON binary operator (0x3A) */
; 520  :         p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 521  :         if ( *p->input == ':' ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN7@get_specia

; 522  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 523  :             buf->token = T_DBL_COLON;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 13

; 524  :             buf->string_ptr = "::";

	mov	rax, QWORD PTR buf$[rsp]
	lea	rcx, OFFSET FLAT:$SG11094
	mov	QWORD PTR [rax+8], rcx

; 525  :         } else {

	jmp	SHORT $LN8@get_specia
$LN7@get_specia:

; 526  :             buf->token = T_COLON;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 58			; 0000003aH

; 527  :             buf->string_ptr = ":";

	mov	rax, QWORD PTR buf$[rsp]
	lea	rcx, OFFSET FLAT:$SG11095
	mov	QWORD PTR [rax+8], rcx
$LN8@get_specia:

; 528  :         }
; 529  :         break;

	jmp	$LN2@get_specia
$LN9@get_specia:

; 530  :     case '%' : /* T_PERCENT (0x25) */
; 531  : #if PERCENT_OUT
; 532  :         /* %OUT directive? */
; 533  :         if ( ( _memicmp( p->input+1, "OUT", 3 ) == 0 ) && !is_valid_id_char( *(p->input+4) ) ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	r8d, 3
	lea	rdx, OFFSET FLAT:$SG11098
	mov	rcx, rax
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	$LN10@get_specia
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+4]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	$LN10@get_specia
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+4]
	cmp	eax, 95					; 0000005fH
	je	$LN10@get_specia
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+4]
	cmp	eax, 64					; 00000040H
	je	$LN10@get_specia
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+4]
	cmp	eax, 36					; 00000024H
	je	$LN10@get_specia
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+4]
	cmp	eax, 63					; 0000003fH
	je	$LN10@get_specia

; 534  :             buf->token = T_DIRECTIVE;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 3

; 535  :             buf->tokval = T_ECHO;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 441			; 000001b9H

; 536  :             buf->dirtype = DRT_ECHO;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 46			; 0000002eH

; 537  :             memcpy( p->output, p->input, 4 );

	mov	r8d, 4
	mov	rax, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy

; 538  :             p->input += 4;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 4
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 539  :             p->output += 4;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 4
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 540  :             *(p->output)++ = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 541  :             break;

	jmp	$LN2@get_specia
$LN10@get_specia:

; 542  :         }
; 543  : #endif
; 544  :         p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 545  :         if ( p->flags == TOK_DEFAULT && p->index == 0 ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+28]
	test	eax, eax
	jne	SHORT $LN11@get_specia
	mov	rax, QWORD PTR p$[rsp]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN11@get_specia

; 546  :             p->flags3 |= TF3_EXPANSION;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+30]
	or	eax, 2
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx+30], al

; 547  :             return( EMPTY );

	mov	eax, -2
	jmp	$LN1@get_specia
$LN11@get_specia:

; 548  :         }
; 549  :         buf->token = T_PERCENT;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 37			; 00000025H

; 550  :         buf->string_ptr = "%";

	mov	rax, QWORD PTR buf$[rsp]
	lea	rcx, OFFSET FLAT:$SG11100
	mov	QWORD PTR [rax+8], rcx

; 551  :         break;

	jmp	$LN2@get_specia
$LN12@get_specia:

; 552  :     case '(' : /* 0x28: T_OP_BRACKET operator - needs a matching ')' */
; 553  :         /* v2.11: reset c-expression flag if a macro function call is detected */
; 554  :         if ( ( p->flags2 & DF_CEXPR ) && p->index && (buf-1)->token == T_ID ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+29]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN13@get_specia
	mov	rax, QWORD PTR p$[rsp]
	cmp	DWORD PTR [rax+24], 0
	je	SHORT $LN13@get_specia
	mov	rax, QWORD PTR buf$[rsp]
	movzx	eax, BYTE PTR [rax-32]
	cmp	eax, 8
	jne	SHORT $LN13@get_specia

; 555  :             struct asym *sym = SymSearch( (buf-1)->string_ptr );

	mov	rax, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR [rax-24]
	call	SymFind
	mov	QWORD PTR sym$1[rsp], rax

; 556  :             if ( sym && ( sym->state == SYM_MACRO ) && sym->isfunc )

	cmp	QWORD PTR sym$1[rsp], 0
	je	SHORT $LN14@get_specia
	mov	rax, QWORD PTR sym$1[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN14@get_specia
	mov	rax, QWORD PTR sym$1[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@get_specia

; 557  :                 p->flags2 &= ~DF_CEXPR;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+29]
	and	eax, -2
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx+29], al
$LN14@get_specia:
$LN13@get_specia:
$LN15@get_specia:

; 558  :         }
; 559  :         /* no break */
; 560  :     case ')' : /* 0x29: T_CL_BRACKET */
; 561  :     case '*' : /* 0x2A: binary operator */
; 562  :     case '+' : /* 0x2B: unary|binary operator */
; 563  :     case ',' : /* 0x2C: T_COMMA */
; 564  :     case '-' : /* 0x2D: unary|binary operator */
; 565  :     case '.' : /* 0x2E: T_DOT binary operator */
; 566  :     case '/' : /* 0x2F: binary operator */
; 567  :         /* all of these are themselves a token */
; 568  :         p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 569  :         buf->token = symbol;

	mov	rax, QWORD PTR buf$[rsp]
	movzx	ecx, BYTE PTR symbol$[rsp]
	mov	BYTE PTR [rax], cl

; 570  :         buf->specval = 0; /* initialize, in case the token needs extra data */

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 0

; 571  :         /* v2.06: use constants for the token string */
; 572  :         buf->string_ptr = (char *)&stokstr1[symbol - '('];

	movsx	eax, BYTE PTR symbol$[rsp]
	sub	eax, 40					; 00000028H
	cdqe
	lea	rcx, OFFSET FLAT:stokstr1
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rcx, QWORD PTR buf$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 573  :         break;

	jmp	$LN2@get_specia
$LN16@get_specia:

; 574  :     case '[' : /* T_OP_SQ_BRACKET operator - needs a matching ']' (0x5B) */
; 575  :     case ']' : /* T_CL_SQ_BRACKET (0x5D) */
; 576  :         p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
$LN4@get_specia:

; 577  : #if AVXSUPP
; 578  :         while ( isspace( *p->input )) p->input++; 

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN5@get_specia
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN4@get_specia
$LN5@get_specia:

; 579  :         c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 580  : #endif
; 581  :         buf->token = symbol;

	mov	rax, QWORD PTR buf$[rsp]
	movzx	ecx, BYTE PTR symbol$[rsp]
	mov	BYTE PTR [rax], cl

; 582  :         /* v2.06: use constants for the token string */
; 583  :         buf->string_ptr = (char *)&stokstr2[symbol - '['];

	movsx	eax, BYTE PTR symbol$[rsp]
	sub	eax, 91					; 0000005bH
	cdqe
	lea	rcx, OFFSET FLAT:stokstr2
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rcx, QWORD PTR buf$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 584  : #if AVXSUPP
; 585  :         /* Intercept here '{' for EVEX mask or broadcast events 
; 586  :          * it could be {k1}, ]{k1}{z}, {1to2},{1to4},{1to8},{1to16}
; 587  :         */
; 588  :         if (c == '{')

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN17@get_specia

; 589  :         {
; 590  :           p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 591  :           if ((*p->input | 0x20) == 'k' || (*p->input | 0x20) == 'z')

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	or	eax, 32					; 00000020H
	cmp	eax, 107				; 0000006bH
	je	SHORT $LN20@get_specia
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	or	eax, 32					; 00000020H
	cmp	eax, 122				; 0000007aH
	jne	SHORT $LN18@get_specia
$LN20@get_specia:

; 592  :             get_decos( p ) ;    // mask decorators

	mov	rcx, QWORD PTR p$[rsp]
	call	get_decos
	jmp	SHORT $LN19@get_specia
$LN18@get_specia:

; 593  :           else
; 594  :             get_broads( p ) ;   // broadcast decorators

	mov	rcx, QWORD PTR p$[rsp]
	call	get_broads
$LN19@get_specia:
$LN17@get_specia:

; 595  :         }
; 596  : #endif
; 597  :         break;

	jmp	$LN2@get_specia
$LN21@get_specia:

; 598  :     case '=' : /* (0x3D) */
; 599  :         if ( *(p->input+1) != '=' ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN22@get_specia

; 600  :             buf->token = T_DIRECTIVE;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 3

; 601  :             buf->tokval = T_EQU;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 443			; 000001bbH

; 602  :             buf->dirtype = DRT_EQUALSGN; /* to make it differ from EQU directive */

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 48			; 00000030H

; 603  :             buf->string_ptr = "=";

	mov	rax, QWORD PTR buf$[rsp]
	lea	rcx, OFFSET FLAT:$SG11112
	mov	QWORD PTR [rax+8], rcx

; 604  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 605  :             break;

	jmp	$LN2@get_specia
$LN22@get_specia:
$LN23@get_specia:

; 606  :         }
; 607  :         /* fall through */
; 608  :     default:
; 609  :         /* detect C style operators.
; 610  :          * DF_CEXPR is set if .IF, .WHILE, .ELSEIF or .UNTIL
; 611  :          * has been detected in the current line.
; 612  :          * will catch: '!', '<', '>', '&', '==', '!=', '<=', '>=', '&&', '||'
; 613  :          * A single '|' will also be caught, although it isn't a valid
; 614  :          * operator - it will cause a 'operator expected' error msg later.
; 615  :          * the tokens are stored as one- or two-byte sized "strings".
; 616  :          */
; 617  :       if ( ( p->flags2 & DF_CEXPR ) && strchr( "=!<>&|", symbol ) ) {     //habran added ''

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+29]
	and	eax, 1
	test	eax, eax
	je	$LN24@get_specia
	movsx	eax, BYTE PTR symbol$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11115
	call	QWORD PTR __imp_strchr
	test	rax, rax
	je	$LN24@get_specia

; 618  :             *(p->output)++ = symbol;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	ecx, BYTE PTR symbol$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 619  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 620  :             buf->stringlen = 1;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 1

; 621  :             if ( symbol == '&' || symbol == '|' ) {

	movsx	eax, BYTE PTR symbol$[rsp]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN27@get_specia
	movsx	eax, BYTE PTR symbol$[rsp]
	cmp	eax, 124				; 0000007cH
	jne	SHORT $LN25@get_specia
$LN27@get_specia:

; 622  :                 if ( *p->input == symbol ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	movsx	ecx, BYTE PTR symbol$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN28@get_specia

; 623  :                     *(p->output)++ = symbol;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	ecx, BYTE PTR symbol$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 624  :                     p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 625  :                     buf->stringlen = 2;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 2
$LN28@get_specia:

; 626  :                 }

	jmp	SHORT $LN26@get_specia
$LN25@get_specia:

; 627  :             } else if ( *p->input == '=' ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 61					; 0000003dH
	jne	SHORT $LN29@get_specia

; 628  :                 *(p->output)++ = '=';

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax], 61			; 0000003dH
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 629  :                 p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 630  :                 buf->stringlen = 2;

	mov	rax, QWORD PTR buf$[rsp]
	mov	DWORD PTR [rax+16], 2
$LN29@get_specia:
$LN26@get_specia:

; 631  :             }
; 632  :             buf->token = T_STRING;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 9

; 633  :             buf->string_delim = NULLC;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 0

; 634  :             *(p->output)++ = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 635  :             break;

	jmp	SHORT $LN2@get_specia
$LN24@get_specia:

; 636  :         }
; 637  :         /* v2.08: ampersand is a special token */
; 638  :         if ( symbol == '&' ) {

	movsx	eax, BYTE PTR symbol$[rsp]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN30@get_specia

; 639  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 640  :             buf->token = '&';

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 38			; 00000026H

; 641  :             buf->string_ptr = "&";

	mov	rax, QWORD PTR buf$[rsp]
	lea	rcx, OFFSET FLAT:$SG11122
	mov	QWORD PTR [rax+8], rcx

; 642  :             break;

	jmp	SHORT $LN2@get_specia
$LN30@get_specia:

; 643  :         }
; 644  :         /* anything we don't recognise we will consider a string,
; 645  :          * delimited by space characters, commas, newlines or nulls
; 646  :          */
; 647  :         return( get_string( buf, p ) );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	get_string
	jmp	SHORT $LN1@get_specia
$LN2@get_specia:

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@get_specia:

; 650  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
	npad	1
$LN33@get_specia:
	DD	$LN9@get_specia
	DD	$LN12@get_specia
	DD	$LN15@get_specia
	DD	$LN6@get_specia
	DD	$LN21@get_specia
	DD	$LN16@get_specia
	DD	$LN23@get_specia
$LN32@get_specia:
	DB	0
	DB	6
	DB	6
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	6
	DB	5
get_special_symbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
symbol_o$ = 32
symbol_c$ = 33
c$ = 34
src$ = 40
dst$ = 48
count$ = 56
level$ = 60
delim$1 = 64
tdst$2 = 72
tsrc$3 = 80
tcount$4 = 88
tmp$5 = 96
tv67 = 104
tv94 = 108
buf$ = 128
p$ = 136
get_string PROC

; 316  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]

; 317  :     char    symbol_o;
; 318  :     char    symbol_c;
; 319  :     char    c;
; 320  :     char    *src = p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR src$[rsp], rax

; 321  :     char    *dst = p->output;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR dst$[rsp], rax

; 322  :     int     count = 0;

	mov	DWORD PTR count$[rsp], 0

; 323  :     int     level;
; 324  : 
; 325  :     symbol_o = *src;

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR symbol_o$[rsp], al

; 326  : 
; 327  :     switch( symbol_o ) {

	movzx	eax, BYTE PTR symbol_o$[rsp]
	mov	BYTE PTR tv67[rsp], al
	cmp	BYTE PTR tv67[rsp], 34			; 00000022H
	je	SHORT $LN19@get_string
	cmp	BYTE PTR tv67[rsp], 39			; 00000027H
	je	SHORT $LN19@get_string
	cmp	BYTE PTR tv67[rsp], 60			; 0000003cH
	je	$LN27@get_string
	cmp	BYTE PTR tv67[rsp], 123			; 0000007bH
	je	$LN25@get_string
	jmp	$LN51@get_string
$LN19@get_string:

; 328  :     case '"':
; 329  :     case '\'':
; 330  :         buf->string_delim = symbol_o;

	mov	rax, QWORD PTR buf$[rsp]
	movzx	ecx, BYTE PTR symbol_o$[rsp]
	mov	BYTE PTR [rax+1], cl

; 331  :         *dst++ = symbol_o;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR symbol_o$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 332  :         src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 333  :         for ( ; count < MAX_STRING_LEN; src++, count++ ) {

	jmp	SHORT $LN6@get_string
$LN4@get_string:
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
$LN6@get_string:
	cmp	DWORD PTR count$[rsp], 568		; 00000238H
	jge	$LN5@get_string

; 334  :             c = *src;

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 335  :             if( c == symbol_o ) { /* another quote? */

	movsx	eax, BYTE PTR c$[rsp]
	movsx	ecx, BYTE PTR symbol_o$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN20@get_string

; 336  :                 *dst++ = c; /* store it */

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 337  :                 src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 338  :                 if( *src != c )

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	movsx	ecx, BYTE PTR c$[rsp]
	cmp	eax, ecx
	je	SHORT $LN22@get_string

; 339  :                     break; /* exit loop */

	jmp	SHORT $LN5@get_string
$LN22@get_string:

; 340  :                 /* a pair of quotes inside the string is
; 341  :                  * handled as a single quote */
; 342  :             } else if( c == NULLC ) {

	jmp	SHORT $LN21@get_string
$LN20@get_string:
	movsx	eax, BYTE PTR c$[rsp]
	test	eax, eax
	jne	SHORT $LN23@get_string

; 343  :                 /* missing terminating quote, change to undelimited string */
; 344  :                 buf->string_delim = NULLC;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 0

; 345  :                 count++; /* count the first quote */

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax

; 346  :                 break;

	jmp	SHORT $LN5@get_string

; 347  :             } else {

	jmp	SHORT $LN24@get_string
$LN23@get_string:

; 348  :                 *dst++ = c;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
$LN24@get_string:
$LN21@get_string:

; 349  :             }
; 350  :         }

	jmp	$LN4@get_string
$LN5@get_string:

; 351  :         break;  /* end of string marker is the same */

	jmp	$LN2@get_string
$LN25@get_string:

; 352  :     case '{':
; 353  :         if ( p->flags & TOK_NOCURLBRACES )

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+28]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN26@get_string

; 354  :             goto undelimited_string;

	jmp	$undelimited_string$62
$LN26@get_string:
$LN27@get_string:

; 355  :     case '<':
; 356  :         buf->string_delim = symbol_o;

	mov	rax, QWORD PTR buf$[rsp]
	movzx	ecx, BYTE PTR symbol_o$[rsp]
	mov	BYTE PTR [rax+1], cl

; 357  :         symbol_c = ( symbol_o == '<' ? '>' : '}' );

	movsx	eax, BYTE PTR symbol_o$[rsp]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN60@get_string
	mov	DWORD PTR tv94[rsp], 62			; 0000003eH
	jmp	SHORT $LN61@get_string
$LN60@get_string:
	mov	DWORD PTR tv94[rsp], 125		; 0000007dH
$LN61@get_string:
	movzx	eax, BYTE PTR tv94[rsp]
	mov	BYTE PTR symbol_c$[rsp], al

; 358  :         src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 359  :         for( level = 0; count < MAX_STRING_LEN; ) {

	mov	DWORD PTR level$[rsp], 0
$LN7@get_string:
	cmp	DWORD PTR count$[rsp], 568		; 00000238H
	jge	$LN8@get_string

; 360  :             c = *src;

	mov	rax, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 361  :             if( c == symbol_o ) { /* < or { ? */

	movsx	eax, BYTE PTR c$[rsp]
	movsx	ecx, BYTE PTR symbol_o$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN28@get_string

; 362  :                 level++;

	mov	eax, DWORD PTR level$[rsp]
	inc	eax
	mov	DWORD PTR level$[rsp], eax

; 363  :                 *dst++ = c; src++;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 364  :                 count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
	jmp	$LN29@get_string
$LN28@get_string:

; 365  :             } else if( c == symbol_c ) { /* > or }? */

	movsx	eax, BYTE PTR c$[rsp]
	movsx	ecx, BYTE PTR symbol_c$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN30@get_string

; 366  :                 if( level ) {

	cmp	DWORD PTR level$[rsp], 0
	je	SHORT $LN32@get_string

; 367  :                     level--;

	mov	eax, DWORD PTR level$[rsp]
	dec	eax
	mov	DWORD PTR level$[rsp], eax

; 368  :                     *dst++ = c; src++;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 369  :                     count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax

; 370  :                 } else {

	jmp	SHORT $LN33@get_string
$LN32@get_string:

; 371  :                     /* store the string delimiter unless it is <> */
; 372  :                     /* v2.08: don't store delimiters for {}-literals */
; 373  :                     //if (symbol_o != '<')
; 374  :                     //    *dst++ = c;
; 375  :                     src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 376  :                     break; /* exit loop */

	jmp	$LN8@get_string
$LN33@get_string:

; 377  :                 }

	jmp	$LN31@get_string
$LN30@get_string:

; 378  : #if 1
; 379  :             /*
; 380  :              a " or ' inside a <>/{} string? Since it's not a must that
; 381  :              [double-]quotes are paired in a literal it must be done
; 382  :              directive-dependant!
; 383  :              see: IFIDN <">,<">
; 384  :              */
; 385  :             } else if( ( c == '"' || c == '\'' ) && ( p->flags2 & DF_STRPARM ) == 0 ) {

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN36@get_string
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 39					; 00000027H
	jne	$LN34@get_string
$LN36@get_string:
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+29]
	and	eax, 2
	test	eax, eax
	jne	$LN34@get_string

; 386  :                 char delim = c;

	movzx	eax, BYTE PTR c$[rsp]
	mov	BYTE PTR delim$1[rsp], al

; 387  :                 char *tdst;
; 388  :                 char *tsrc;
; 389  :                 int tcount;
; 390  :                 *dst++ = c; src++;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 391  :                 count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax

; 392  :                 tdst = dst;

	mov	rax, QWORD PTR dst$[rsp]
	mov	QWORD PTR tdst$2[rsp], rax

; 393  :                 tsrc = src;

	mov	rax, QWORD PTR src$[rsp]
	mov	QWORD PTR tsrc$3[rsp], rax

; 394  :                 tcount = count;

	mov	eax, DWORD PTR count$[rsp]
	mov	DWORD PTR tcount$4[rsp], eax
$LN10@get_string:

; 395  :                 while (*src != delim && *src != NULLC && count < MAX_STRING_LEN-1 ) {

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	movsx	ecx, BYTE PTR delim$1[rsp]
	cmp	eax, ecx
	je	SHORT $LN11@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN11@get_string
	cmp	DWORD PTR count$[rsp], 567		; 00000237H
	jge	SHORT $LN11@get_string

; 396  :                     if ( symbol_o == '<' && *src == '!' && *(src+1) != NULLC )

	movsx	eax, BYTE PTR symbol_o$[rsp]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN37@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN37@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	je	SHORT $LN37@get_string

; 397  :                         src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN37@get_string:

; 398  :                     *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 399  :                     count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax

; 400  :                 }

	jmp	$LN10@get_string
$LN11@get_string:

; 401  :                 if ( *src == delim ) {

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	movsx	ecx, BYTE PTR delim$1[rsp]
	cmp	eax, ecx
	jne	SHORT $LN38@get_string

; 402  :                     *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 403  :                     count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax

; 404  :                     continue;

	jmp	$LN7@get_string

; 405  :                 } else {

	jmp	SHORT $LN39@get_string
$LN38@get_string:

; 406  :                     /* restore values */
; 407  :                     src = tsrc;

	mov	rax, QWORD PTR tsrc$3[rsp]
	mov	QWORD PTR src$[rsp], rax

; 408  :                     dst = tdst;

	mov	rax, QWORD PTR tdst$2[rsp]
	mov	QWORD PTR dst$[rsp], rax

; 409  :                     count = tcount;

	mov	eax, DWORD PTR tcount$4[rsp]
	mov	DWORD PTR count$[rsp], eax
$LN39@get_string:

; 410  :                 }

	jmp	$LN35@get_string
$LN34@get_string:

; 411  : #endif
; 412  :             } else if( c == '!' && symbol_o == '<' && *(src+1) ) {

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN40@get_string
	movsx	eax, BYTE PTR symbol_o$[rsp]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN40@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	je	SHORT $LN40@get_string

; 413  :                 /* handle literal-character operator '!'.
; 414  :                  * it makes the next char to enter the literal uninterpreted.
; 415  :                  */
; 416  :                 /* v2.09: don't store the '!' */
; 417  :                 //*dst++ = c; src++;
; 418  :                 //count++;
; 419  :                 //if ( count == MAX_STRING_LEN )
; 420  :                 //    break;
; 421  :                 src++;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 422  :                 *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 423  :                 count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
	jmp	$LN41@get_string
$LN40@get_string:

; 424  :             } else if( c == '\\' &&  ConcatLine( src, count, dst, p ) != EMPTY ) {

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN42@get_string
	mov	r9, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR dst$[rsp]
	mov	edx, DWORD PTR count$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	call	ConcatLine
	cmp	eax, -2
	je	SHORT $LN42@get_string

; 425  :                 p->flags3 |= TF3_ISCONCAT;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+30]
	or	eax, 1
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx+30], al
	jmp	$LN43@get_string
$LN42@get_string:

; 426  :             } else if( c == NULLC || ( c == ';' && symbol_o == '{' )) {

	movsx	eax, BYTE PTR c$[rsp]
	test	eax, eax
	je	SHORT $LN46@get_string
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 59					; 0000003bH
	jne	$LN44@get_string
	movsx	eax, BYTE PTR symbol_o$[rsp]
	cmp	eax, 123				; 0000007bH
	jne	$LN44@get_string
$LN46@get_string:

; 427  :                 if ( p->flags == TOK_DEFAULT && (( p->flags2 & DF_NOCONCAT ) == 0 ) ) { /* <{ */

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+28]
	test	eax, eax
	jne	$LN47@get_string
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+29]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	$LN47@get_string

; 428  :                     /* if last nonspace character was a comma
; 429  :                      * get next line and continue string scan
; 430  :                      */
; 431  :                     char *tmp = dst-1;

	mov	rax, QWORD PTR dst$[rsp]
	dec	rax
	mov	QWORD PTR tmp$5[rsp], rax
$LN12@get_string:

; 432  :                     while ( isspace(*tmp) ) tmp--;

	mov	rax, QWORD PTR tmp$5[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN13@get_string
	mov	rax, QWORD PTR tmp$5[rsp]
	dec	rax
	mov	QWORD PTR tmp$5[rsp], rax
	jmp	SHORT $LN12@get_string
$LN13@get_string:

; 433  :                     if ( *tmp == ',' ) {

	mov	rax, QWORD PTR tmp$5[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 44					; 0000002cH
	jne	$LN48@get_string

; 434  :                         DebugMsg1(("Tokenize.get_string: comma concatenation: %s\n", src ));

	mov	rdx, QWORD PTR src$[rsp]
	lea	rcx, OFFSET FLAT:$SG11062
	call	DoDebugMsg1

; 435  :                         tmp = GetAlignedPointer( p->output, strlen( p->output ) );

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	strlen
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR p$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR tmp$5[rsp], rax

; 436  :                         if( GetTextLine( tmp ) ) {

	mov	rcx, QWORD PTR tmp$5[rsp]
	call	GetTextLine
	test	rax, rax
	je	SHORT $LN49@get_string
$LN14@get_string:

; 437  :                             /* skip leading spaces */
; 438  :                             while ( isspace( *tmp ) ) tmp++;

	mov	rax, QWORD PTR tmp$5[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN15@get_string
	mov	rax, QWORD PTR tmp$5[rsp]
	inc	rax
	mov	QWORD PTR tmp$5[rsp], rax
	jmp	SHORT $LN14@get_string
$LN15@get_string:

; 439  :                             /* this size check isn't fool-proved yet */
; 440  :                             if ( strlen( tmp ) + count >= MAX_LINE_LEN ) {

	mov	rcx, QWORD PTR tmp$5[rsp]
	call	strlen
	movsxd	rcx, DWORD PTR count$[rsp]
	add	rax, rcx
	cmp	rax, 600				; 00000258H
	jb	SHORT $LN50@get_string

; 441  :                                 EmitError( LINE_TOO_LONG );

	mov	ecx, 62					; 0000003eH
	call	EmitError

; 442  :                                 return( ERROR );

	mov	eax, -1
	jmp	$LN1@get_string
$LN50@get_string:

; 443  :                             }
; 444  :                             strcpy( src, tmp );

	mov	rdx, QWORD PTR tmp$5[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	call	strcpy

; 445  :                             continue;

	jmp	$LN7@get_string
$LN49@get_string:
$LN48@get_string:
$LN47@get_string:

; 446  :                         }
; 447  :                     }
; 448  :                 }
; 449  :                 src = p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR src$[rsp], rax

; 450  :                 dst = p->output;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR dst$[rsp], rax

; 451  :                 *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 452  :                 count = 1;

	mov	DWORD PTR count$[rsp], 1

; 453  :                 goto undelimited_string;

	jmp	SHORT $undelimited_string$62

; 454  :             } else {

	jmp	SHORT $LN45@get_string
$LN44@get_string:

; 455  :                 *dst++ = c; src++;

	mov	rax, QWORD PTR dst$[rsp]
	movzx	ecx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 456  :                 count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
$LN45@get_string:
$LN43@get_string:
$LN41@get_string:
$LN35@get_string:
$LN31@get_string:
$LN29@get_string:

; 457  :             }
; 458  :         }

	jmp	$LN7@get_string
$LN8@get_string:

; 459  :         break;

	jmp	$LN2@get_string
$LN51@get_string:
$undelimited_string$62:

; 460  :     default:
; 461  :         undelimited_string:
; 462  :         buf->string_delim = NULLC;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 0
$LN16@get_string:

; 463  :         /* this is an undelimited string,
; 464  :          * so just copy it until we hit something that looks like the end.
; 465  :          * this format is used by the INCLUDE directive, but may also
; 466  :          * occur inside the string macros!
; 467  :          */
; 468  :         /* v2.05: also stop if a ')' is found - see literal2.asm regression test */
; 469  :         //for( count = 0 ; count < MAX_STRING_LEN && *src != NULLC && !isspace( *src ) && *src != ',' && *src != ';'; ) {
; 470  :         for( ; count < MAX_STRING_LEN &&
; 471  :             /* v2.08: stop also at < and % */
; 472  :             //*src != NULLC && !isspace( *src ) && *src != ',' && *src != ';' && *src != ')'; ) {
; 473  :             //*src && !isspace( *src ) && *src != ',' && *src != ')' && *src != '<' && *src != '%'; ) {
; 474  :             *src && !isspace( *src ) && *src != ',' && *src != ')' && *src != '%'; ) {

	cmp	DWORD PTR count$[rsp], 568		; 00000238H
	jge	$LN17@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN17@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	jne	$LN17@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 44					; 0000002cH
	je	$LN17@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 41					; 00000029H
	je	$LN17@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	je	$LN17@get_string

; 475  :             if ( *src == ';' && p->flags == TOK_DEFAULT )

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN52@get_string
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+28]
	test	eax, eax
	jne	SHORT $LN52@get_string

; 476  :                 break;

	jmp	$LN17@get_string
$LN52@get_string:

; 477  :             /* v2.11: handle '\' also for expanded lines */
; 478  :             //if (  *src == '\\' && !( p->flags & TOK_NOCURLBRACES ) ) {
; 479  :             if (  *src == '\\' && ( p->flags == TOK_DEFAULT || ( p->flags & TOK_LINE ) ) ) {

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 92					; 0000005cH
	jne	$LN53@get_string
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+28]
	test	eax, eax
	je	SHORT $LN54@get_string
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+28]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN53@get_string
$LN54@get_string:

; 480  :                 if ( ConcatLine( src, count, dst, p ) != EMPTY ) {

	mov	r9, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR dst$[rsp]
	mov	edx, DWORD PTR count$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	call	ConcatLine
	cmp	eax, -2
	je	SHORT $LN55@get_string

; 481  :                     DebugMsg1(("Tokenize.get_string: backslash concatenation: >%s<\n", src ));

	mov	rdx, QWORD PTR src$[rsp]
	lea	rcx, OFFSET FLAT:$SG11070
	call	DoDebugMsg1

; 482  :                     p->flags3 |= TF3_ISCONCAT;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax+30]
	or	eax, 1
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx+30], al

; 483  :                     if ( count )

	cmp	DWORD PTR count$[rsp], 0
	je	SHORT $LN56@get_string

; 484  :                         continue;

	jmp	$LN16@get_string
$LN56@get_string:

; 485  :                     return( EMPTY );

	mov	eax, -2
	jmp	$LN1@get_string
$LN55@get_string:
$LN53@get_string:

; 486  :                 }
; 487  :             }
; 488  :             /* v2.08: handle '!' operator */
; 489  :             if ( *src == '!' && *(src+1) && count < MAX_STRING_LEN - 1 )

	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN57@get_string
	mov	rax, QWORD PTR src$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	je	SHORT $LN57@get_string
	cmp	DWORD PTR count$[rsp], 567		; 00000237H
	jge	SHORT $LN57@get_string

; 490  :                 *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN57@get_string:

; 491  :             *dst++ = *src++;

	mov	rax, QWORD PTR dst$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax

; 492  :             count++;

	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax

; 493  :         }

	jmp	$LN16@get_string
$LN17@get_string:
$LN2@get_string:

; 494  :         break;
; 495  :     }
; 496  : 
; 497  :     if ( count == MAX_STRING_LEN ) {

	cmp	DWORD PTR count$[rsp], 568		; 00000238H
	jne	SHORT $LN58@get_string

; 498  :         EmitError( STRING_OR_TEXT_LITERAL_TOO_LONG );

	mov	ecx, 156				; 0000009cH
	call	EmitError

; 499  :         return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN1@get_string
$LN58@get_string:

; 500  :     }
; 501  :     *dst++ = NULLC;

	mov	rax, QWORD PTR dst$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR dst$[rsp]
	inc	rax
	mov	QWORD PTR dst$[rsp], rax

; 502  :     buf->token = T_STRING;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 9

; 503  :     buf->stringlen = count;

	mov	rax, QWORD PTR buf$[rsp]
	mov	ecx, DWORD PTR count$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 504  :     p->input = src;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	QWORD PTR [rax], rcx

; 505  :     p->output = dst;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR dst$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 506  :     return( NOT_ERROR );

	xor	eax, eax
$LN1@get_string:

; 507  : }

	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
get_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
p$ = 32
max$ = 40
buffer$1 = 48
src$ = 80
cnt$ = 88
out$ = 96
ls$ = 104
ConcatLine PROC

; 287  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 288  :     char *p = src+1;

	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN2@ConcatLine:

; 289  :     int max;
; 290  : 
; 291  :     while ( isspace(*p) ) p++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN3@ConcatLine
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN2@ConcatLine
$LN3@ConcatLine:

; 292  :     if ( *p == NULLC || *p == ';' ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN7@ConcatLine
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 59					; 0000003bH
	jne	$LN6@ConcatLine
$LN7@ConcatLine:

; 293  :         //char *buffer = GetAlignedPointer( out, strlen( out ) );
; 294  :         char *buffer = out;

	mov	rax, QWORD PTR out$[rsp]
	mov	QWORD PTR buffer$1[rsp], rax

; 295  :         if( GetTextLine( buffer ) ) {

	mov	rcx, QWORD PTR buffer$1[rsp]
	call	GetTextLine
	test	rax, rax
	je	$LN8@ConcatLine

; 296  :             p = buffer;

	mov	rax, QWORD PTR buffer$1[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN4@ConcatLine:

; 297  :             /* skip leading spaces */
; 298  :             while ( isspace( *p ) ) p++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN5@ConcatLine
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN4@ConcatLine
$LN5@ConcatLine:

; 299  :             max = strlen( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	strlen
	mov	DWORD PTR max$[rsp], eax

; 300  :             if ( cnt == 0 )

	cmp	DWORD PTR cnt$[rsp], 0
	jne	SHORT $LN9@ConcatLine

; 301  :                 *src++ = ' ';

	mov	rax, QWORD PTR src$[rsp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR src$[rsp]
	inc	rax
	mov	QWORD PTR src$[rsp], rax
$LN9@ConcatLine:

; 302  :             if ( ( src - ls->start ) + max >= MAX_LINE_LEN ) {

	mov	rax, QWORD PTR ls$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR src$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR max$[rsp]
	add	rax, rcx
	cmp	rax, 600				; 00000258H
	jl	SHORT $LN10@ConcatLine

; 303  :                 EmitError( LINE_TOO_LONG );

	mov	ecx, 62					; 0000003eH
	call	EmitError

; 304  :                 max = MAX_LINE_LEN - ( src - ls->start + 1 );

	mov	rax, QWORD PTR ls$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR src$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	inc	rax
	mov	ecx, 600				; 00000258H
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR max$[rsp], eax

; 305  :                 *(p+max) = NULLC;

	movsxd	rax, DWORD PTR max$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx+rax], 0
$LN10@ConcatLine:

; 306  :             }
; 307  :             memcpy( src, p, max+1 );

	mov	eax, DWORD PTR max$[rsp]
	inc	eax
	cdqe
	mov	r8, rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	call	memcpy

; 308  :             return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@ConcatLine
$LN8@ConcatLine:
$LN6@ConcatLine:

; 309  :         }
; 310  :     }
; 311  :     return( EMPTY );

	mov	eax, -2
$LN1@ConcatLine:

; 312  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
ConcatLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
got_decimal$ = 32
got_e$ = 33
ptr$ = 40
c$1 = 48
tv83 = 52
buf$ = 80
p$ = 88
get_float PROC

; 245  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 246  :     /* valid floats look like:  (int)[.(int)][e(int)]
; 247  :      * Masm also allows hex format, terminated by 'r' (3F800000r)
; 248  :      */
; 249  : 
; 250  :     char    got_decimal = FALSE;

	mov	BYTE PTR got_decimal$[rsp], 0

; 251  :     char    got_e = FALSE;

	mov	BYTE PTR got_e$[rsp], 0

; 252  :     char    *ptr = p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR ptr$[rsp], rax

; 253  : 
; 254  :     for( ; *ptr != NULLC; ptr++ ) {

	jmp	SHORT $LN4@get_float
$LN2@get_float:
	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN4@get_float:
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@get_float

; 255  :         char c = *ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$1[rsp], al

; 256  :         if( isdigit( c ) ) {

	movsx	eax, BYTE PTR c$1[rsp]
	mov	ecx, eax
	call	QWORD PTR __imp_isdigit
	test	eax, eax
	je	SHORT $LN5@get_float
	jmp	$LN6@get_float
$LN5@get_float:

; 257  :             ;
; 258  :         } else if ( c == '.' && got_decimal == FALSE ) {

	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN7@get_float
	movsx	eax, BYTE PTR got_decimal$[rsp]
	test	eax, eax
	jne	SHORT $LN7@get_float

; 259  :             got_decimal = TRUE;

	mov	BYTE PTR got_decimal$[rsp], 1
	jmp	SHORT $LN8@get_float
$LN7@get_float:

; 260  :         } else if ( tolower( c ) == 'e' && got_e == FALSE ) {

	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN14@get_float
	movsx	eax, BYTE PTR c$1[rsp]
	cmp	eax, 90					; 0000005aH
	jg	SHORT $LN14@get_float
	movsx	eax, BYTE PTR c$1[rsp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR tv83[rsp], eax
	jmp	SHORT $LN15@get_float
$LN14@get_float:
	movsx	eax, BYTE PTR c$1[rsp]
	mov	DWORD PTR tv83[rsp], eax
$LN15@get_float:
	cmp	DWORD PTR tv83[rsp], 101		; 00000065H
	jne	SHORT $LN9@get_float
	movsx	eax, BYTE PTR got_e$[rsp]
	test	eax, eax
	jne	SHORT $LN9@get_float

; 261  :             got_e = TRUE;

	mov	BYTE PTR got_e$[rsp], 1

; 262  :             /* accept e+2 / e-4 /etc. */
; 263  :             if ( *(ptr+1) == '+' || *(ptr+1) == '-' )

	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN12@get_float
	mov	rax, QWORD PTR ptr$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN11@get_float
$LN12@get_float:

; 264  :                 ptr++;

	mov	rax, QWORD PTR ptr$[rsp]
	inc	rax
	mov	QWORD PTR ptr$[rsp], rax
$LN11@get_float:

; 265  :             /* it's accepted if there's no digit behind 'e' */
; 266  :             //if ( !isdigit( *(ptr+1) ) )
; 267  :             //    break;
; 268  :         } else

	jmp	SHORT $LN10@get_float
$LN9@get_float:

; 269  :             break;

	jmp	SHORT $LN3@get_float
$LN10@get_float:
$LN8@get_float:
$LN6@get_float:

; 270  :     }

	jmp	$LN2@get_float
$LN3@get_float:

; 271  : 
; 272  :     buf->token = T_FLOAT;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax], 11

; 273  :     buf->floattype = NULLC;

	mov	rax, QWORD PTR buf$[rsp]
	mov	BYTE PTR [rax+1], 0

; 274  :     memcpy( p->output, p->input, ptr - p->input );

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR ptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	rax, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy

; 275  :     p->output += ( ptr - p->input );

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR ptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR p$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 276  :     *p->output++ = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 277  :     p->input = ptr;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 278  : 
; 279  :     /* the binary value isn't used currently */
; 280  :     //*((float *)(&buf->value)) = atof( buf->string_ptr );
; 281  : 
; 282  :     return( NOT_ERROR );

	xor	eax, eax

; 283  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
get_float ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
c$ = 32
p$ = 64
get_decos PROC

; 155  : void get_decos(struct line_status *p) {

$LN26:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 156  : 			/************************************************/
; 157  : 			unsigned char c;
; 158  : 			if (!evex)

	movzx	eax, BYTE PTR evex
	test	eax, eax
	jne	SHORT $LN6@get_decos

; 159  : 				EmitError(UNAUTHORISED_USE_OF_EVEX_ENCODING);

	mov	ecx, 23
	call	EmitError
$LN6@get_decos:

; 160  : 			c = (*p->input | 0x20);

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	or	eax, 32					; 00000020H
	mov	BYTE PTR c$[rsp], al

; 161  : 			p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 162  : 			/* if first decorator is the z  */
; 163  : 			if (c == 'z'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 122				; 0000007aH
	jne	$LN7@get_decos

; 164  :             decoflags |= 0x80; 

	movzx	eax, BYTE PTR decoflags
	bts	eax, 7
	mov	BYTE PTR decoflags, al

; 165  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 166  :             c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 167  :             if (c != '}'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 125				; 0000007dH
	je	SHORT $LN9@get_decos

; 168  :               EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15
	call	EmitError

; 169  :               return;

	jmp	$LN1@get_decos
$LN9@get_decos:

; 170  :             }
; 171  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
$LN2@get_decos:

; 172  :             while ( isspace( *p->input )) p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN3@get_decos
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN2@get_decos
$LN3@get_decos:

; 173  :             c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 174  :             if (c != '{'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN10@get_decos

; 175  :               EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError

; 176  :               return;

	jmp	$LN1@get_decos
$LN10@get_decos:

; 177  :             }
; 178  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 179  :             c = (*p->input | 0x20);

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	or	eax, 32					; 00000020H
	mov	BYTE PTR c$[rsp], al

; 180  :             if (c != 'k'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 107				; 0000006bH
	je	SHORT $LN11@get_decos

; 181  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15
	call	EmitError

; 182  :                 return;

	jmp	$LN1@get_decos

; 183  :             }else{

	jmp	$LN12@get_decos
$LN11@get_decos:

; 184  :               p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 185  :               c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 186  :               if (c > '7' || c < '1'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 55					; 00000037H
	jg	SHORT $LN14@get_decos
	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 49					; 00000031H
	jge	SHORT $LN13@get_decos
$LN14@get_decos:

; 187  :                 EmitError(WRONG_MASK_REGISTER_NUBER);

	mov	ecx, 16
	call	EmitError

; 188  :                 return;

	jmp	$LN1@get_decos
$LN13@get_decos:

; 189  :               }
; 190  :               decoflags |= (c & 0x7);

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 7
	movzx	ecx, BYTE PTR decoflags
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR decoflags, al

; 191  :               p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 192  :               c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 193  :               if (c != '}'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 125				; 0000007dH
	je	SHORT $LN15@get_decos

; 194  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15
	call	EmitError

; 195  :                 return;

	jmp	$LN1@get_decos
$LN15@get_decos:

; 196  :               }
; 197  :               p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
$LN12@get_decos:

; 198  :             }
; 199  :           }

	jmp	$LN8@get_decos
$LN7@get_decos:

; 200  :           /* if first decorator is the mask register */
; 201  :           else if (c == 'k'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 107				; 0000006bH
	jne	$LN16@get_decos

; 202  :           c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 203  :           if (c > '7' || c < '1'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 55					; 00000037H
	jg	SHORT $LN19@get_decos
	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 49					; 00000031H
	jge	SHORT $LN18@get_decos
$LN19@get_decos:

; 204  :             EmitError(WRONG_MASK_REGISTER_NUBER);

	mov	ecx, 16
	call	EmitError

; 205  :             return;

	jmp	$LN1@get_decos
$LN18@get_decos:

; 206  :           }
; 207  :           decoflags |= (c & 0x7);

	movzx	eax, BYTE PTR c$[rsp]
	and	eax, 7
	movzx	ecx, BYTE PTR decoflags
	or	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR decoflags, al

; 208  :           p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 209  :           c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 210  :           if (c != '}'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 125				; 0000007dH
	je	SHORT $LN20@get_decos

; 211  :             EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15
	call	EmitError

; 212  :             return;

	jmp	$LN1@get_decos
$LN20@get_decos:

; 213  :           }
; 214  :           p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
$LN4@get_decos:

; 215  :           /* check if there is more decorators */
; 216  :           while ( isspace( *p->input )) p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN5@get_decos
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN4@get_decos
$LN5@get_decos:

; 217  :           c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 218  :           if (c == '{'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 123				; 0000007bH
	jne	$LN21@get_decos

; 219  :             p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 220  :             c = (*p->input | 0x20);

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	or	eax, 32					; 00000020H
	mov	BYTE PTR c$[rsp], al

; 221  :             if (c == 'z'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 122				; 0000007aH
	jne	SHORT $LN22@get_decos

; 222  :               decoflags |= 0x80;

	movzx	eax, BYTE PTR decoflags
	bts	eax, 7
	mov	BYTE PTR decoflags, al

; 223  :               p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 224  :               c = *p->input;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$[rsp], al

; 225  :               if (c != '}'){

	movzx	eax, BYTE PTR c$[rsp]
	cmp	eax, 125				; 0000007dH
	je	SHORT $LN24@get_decos

; 226  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15
	call	EmitError

; 227  :                 return;

	jmp	SHORT $LN1@get_decos
$LN24@get_decos:

; 228  :               }
; 229  :               p->input++;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 230  :             }

	jmp	SHORT $LN23@get_decos
$LN22@get_decos:

; 231  :             else {
; 232  :               EmitError(TO_MANY_DECORATORS);

	mov	ecx, 17
	call	EmitError

; 233  :               return;

	jmp	SHORT $LN1@get_decos
$LN23@get_decos:
$LN21@get_decos:

; 234  :             }
; 235  :           }
; 236  :         }

	jmp	SHORT $LN17@get_decos
$LN16@get_decos:

; 237  :         else {
; 238  :           EmitError(TO_MANY_DECORATORS);

	mov	ecx, 17
	call	EmitError
$LN17@get_decos:
$LN8@get_decos:
$LN1@get_decos:

; 239  :           return;
; 240  :         }
; 241  :       }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
get_decos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
tv143 = 32
tv144 = 36
p$ = 64
get_broads PROC

; 126  : void get_broads(struct line_status *p) {

$LN15:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 127  : 	/************************************************/
; 128  : 	if (!evex)

	movzx	eax, BYTE PTR evex
	test	eax, eax
	jne	SHORT $LN2@get_broads

; 129  : 		EmitError(UNAUTHORISED_USE_OF_EVEX_ENCODING);

	mov	ecx, 23
	call	EmitError
$LN2@get_broads:

; 130  : 
; 131  : 	if (_memicmp(p->input, "1to2", 4) == 0) {

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG10912
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN3@get_broads

; 132  : 		broadflags = 0x10;

	mov	BYTE PTR broadflags, 16

; 133  : 		p->input += 4;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 4
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 134  : 	}

	jmp	$LN4@get_broads
$LN3@get_broads:

; 135  : 	else if (_memicmp(p->input, "1to4", 4) == 0){

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG10915
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN5@get_broads

; 136  :       broadflags = 0x20;

	mov	BYTE PTR broadflags, 32			; 00000020H

; 137  :       p->input += 4;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 4
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 138  :     }

	jmp	$LN6@get_broads
$LN5@get_broads:

; 139  :     else if (_memicmp(p->input, "1to8", 4) == 0){

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:$SG10918
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN7@get_broads

; 140  :       broadflags = 0x30;

	mov	BYTE PTR broadflags, 48			; 00000030H

; 141  :       p->input += 4;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 4
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 142  :     }

	jmp	SHORT $LN8@get_broads
$LN7@get_broads:

; 143  :     else if (_memicmp(p->input, "1to16", 5) == 0){

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:$SG10921
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp__memicmp
	test	eax, eax
	jne	SHORT $LN9@get_broads

; 144  :       broadflags = 0x40;

	mov	BYTE PTR broadflags, 64			; 00000040H

; 145  :       p->input += 5;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 5
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 146  :     }

	jmp	SHORT $LN10@get_broads
$LN9@get_broads:

; 147  :     else
; 148  :       EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN10@get_broads:
$LN8@get_broads:
$LN6@get_broads:
$LN4@get_broads:

; 149  :     if (*p->input++ != '}')

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv143[rsp], eax
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax
	cmp	DWORD PTR tv143[rsp], 125		; 0000007dH
	je	SHORT $LN13@get_broads
	mov	DWORD PTR tv144[rsp], 1
	jmp	SHORT $LN14@get_broads
$LN13@get_broads:
	mov	DWORD PTR tv144[rsp], 0
$LN14@get_broads:
	cmp	DWORD PTR tv144[rsp], 0
	je	SHORT $LN11@get_broads

; 150  :       EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15
	call	EmitError
$LN11@get_broads:

; 151  : 
; 152  :   }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
get_broads ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
sym$ = 32
i$ = 40
tv78 = 44
tokenarray$ = 64
IsMultiLine PROC

; 98   : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 99   :     struct asym *sym;
; 100  :     int i;
; 101  : 
; 102  :     if ( tokenarray[1].token == T_DIRECTIVE && tokenarray[1].tokval == T_EQU )

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN2@IsMultiLin
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 443		; 000001bbH
	jne	SHORT $LN2@IsMultiLin

; 103  :         return( FALSE );

	xor	al, al
	jmp	$LN1@IsMultiLin
$LN2@IsMultiLin:

; 104  :     i = ( tokenarray[1].token == T_COLON ? 2 : 0 );

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN10@IsMultiLin
	mov	DWORD PTR tv78[rsp], 2
	jmp	SHORT $LN11@IsMultiLin
$LN10@IsMultiLin:
	mov	DWORD PTR tv78[rsp], 0
$LN11@IsMultiLin:
	mov	eax, DWORD PTR tv78[rsp]
	mov	DWORD PTR i$[rsp], eax

; 105  :     /* don't concat macros */
; 106  :     if ( tokenarray[i].token == T_ID ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	jne	SHORT $LN3@IsMultiLin

; 107  :         sym = SymSearch( tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+8]
	call	SymFind
	mov	QWORD PTR sym$[rsp], rax

; 108  :         if ( sym && ( sym->state == SYM_MACRO )
; 109  : #if VARARGML
; 110  :             && sym->mac_multiline == FALSE  /* v2.11: added */

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN5@IsMultiLin
	mov	rax, QWORD PTR sym$[rsp]
	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN5@IsMultiLin
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@IsMultiLin

; 111  : #endif
; 112  :            )
; 113  :             return( FALSE );

	xor	al, al
	jmp	$LN1@IsMultiLin
$LN5@IsMultiLin:

; 114  :     } else if ( tokenarray[i].token == T_INSTRUCTION ||

	jmp	$LN4@IsMultiLin
$LN3@IsMultiLin:
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 1
	je	SHORT $LN7@IsMultiLin
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	SHORT $LN6@IsMultiLin
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 441		; 000001b9H
	je	SHORT $LN8@IsMultiLin
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 397		; 0000018dH
	je	SHORT $LN8@IsMultiLin
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 386		; 00000182H
	je	SHORT $LN8@IsMultiLin
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 388		; 00000184H
	jne	SHORT $LN6@IsMultiLin
$LN8@IsMultiLin:
$LN7@IsMultiLin:

; 115  :                ( tokenarray[i].token == T_DIRECTIVE &&
; 116  :                ( tokenarray[i].tokval == T_ECHO ||
; 117  :                 tokenarray[i].tokval == T_INCLUDE ||
; 118  :                 tokenarray[i].tokval == T_FORC ||
; 119  :                 tokenarray[i].tokval == T_IRPC ) ) ) {
; 120  :         return( FALSE );

	xor	al, al
	jmp	SHORT $LN1@IsMultiLin
$LN6@IsMultiLin:
$LN4@IsMultiLin:

; 121  :     }
; 122  :     return( TRUE );

	mov	al, 1
$LN1@IsMultiLin:

; 123  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
IsMultiLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
rc$ = 32
p$ = 56
ptr$4 = 104
line$ = 128
start$ = 136
tokenarray$ = 144
flags$ = 152
Tokenize PROC

; 1089 : {

$LN36:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]

; 1090 :     int                         rc;
; 1091 :     struct line_status          p;
; 1092 : 
; 1093 :     p.input = line;

	mov	rax, QWORD PTR line$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 1094 :     p.start = line;

	mov	rax, QWORD PTR line$[rsp]
	mov	QWORD PTR p$[rsp+16], rax

; 1095 :     p.index = start;

	mov	eax, DWORD PTR start$[rsp]
	mov	DWORD PTR p$[rsp+24], eax

; 1096 :     //p.last_token = T_FINAL; /* v2.11: last_token is obsolete */
; 1097 :     p.flags = flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	BYTE PTR p$[rsp+28], al

; 1098 :     p.flags2 = 0;

	mov	BYTE PTR p$[rsp+29], 0

; 1099 :     p.flags3 = 0;

	mov	BYTE PTR p$[rsp+30], 0

; 1100 :     if ( p.index == 0 ) {

	cmp	DWORD PTR p$[rsp+24], 0
	jne	SHORT $LN11@Tokenize

; 1101 : #ifdef DEBUG_OUT
; 1102 :         cnttok0++;

	mov	eax, DWORD PTR cnttok0
	inc	eax
	mov	DWORD PTR cnttok0, eax

; 1103 : #endif
; 1104 :         /* v2.06: these flags are now initialized on a higher level */
; 1105 :         //ModuleInfo.line_flags = 0;
; 1106 :         p.output = token_stringbuf;

	mov	rax, QWORD PTR token_stringbuf
	mov	QWORD PTR p$[rsp+8], rax

; 1107 :         if( ModuleInfo.inside_comment ) {

	movzx	eax, BYTE PTR ModuleInfo+407
	test	eax, eax
	je	SHORT $LN13@Tokenize

; 1108 :             DebugMsg1(("COMMENT active, delim is >%c<, line is >%s<\n", ModuleInfo.inside_comment, line));

	movzx	eax, BYTE PTR ModuleInfo+407
	mov	r8, QWORD PTR line$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11281
	call	DoDebugMsg1

; 1109 :             if( strchr( line, ModuleInfo.inside_comment ) != NULL ) {

	movzx	eax, BYTE PTR ModuleInfo+407
	mov	edx, eax
	mov	rcx, QWORD PTR line$[rsp]
	call	QWORD PTR __imp_strchr
	test	rax, rax
	je	SHORT $LN14@Tokenize

; 1110 :                 DebugMsg1(("COMMENT mode exited\n"));

	lea	rcx, OFFSET FLAT:$SG11283
	call	DoDebugMsg1

; 1111 :                 ModuleInfo.inside_comment = NULLC;

	mov	BYTE PTR ModuleInfo+407, 0
$LN14@Tokenize:

; 1112 :             }
; 1113 :             goto skipline;

	jmp	$skipline$37
$LN13@Tokenize:

; 1114 :         }
; 1115 :         /* v2.08: expansion operator % at pos 0 is handled differently.
; 1116 :          */
; 1117 :         //while( isspace( *p.input )) p.input++;
; 1118 :         //if ( *p.input == '%' ) {
; 1119 :         //    *p.input++ = ' ';
; 1120 :         //    expansion = TRUE;
; 1121 :         //}
; 1122 :     } else {

	jmp	SHORT $LN12@Tokenize
$LN11@Tokenize:

; 1123 : #ifdef DEBUG_OUT
; 1124 :         cnttok1++;

	mov	eax, DWORD PTR cnttok1
	inc	eax
	mov	DWORD PTR cnttok1, eax

; 1125 : #endif
; 1126 :         p.output = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR p$[rsp+8], rax
$LN12@Tokenize:
$LN2@Tokenize:
$LN5@Tokenize:

; 1127 :     }
; 1128 : 
; 1129 :     for( ;; ) {
; 1130 : 
; 1131 :         while( isspace( *p.input ) ) p.input++;

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN6@Tokenize
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN5@Tokenize
$LN6@Tokenize:

; 1132 : 
; 1133 :         if ( *p.input == ';' && flags == TOK_DEFAULT ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN15@Tokenize
	cmp	DWORD PTR flags$[rsp], 0
	jne	SHORT $LN15@Tokenize
$LN7@Tokenize:

; 1134 :             while ( p.input > line && isspace( *(p.input-1) ) ) p.input--; /* skip */

	mov	rax, QWORD PTR line$[rsp]
	cmp	QWORD PTR p$[rsp], rax
	jbe	SHORT $LN8@Tokenize
	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax-1]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN8@Tokenize
	mov	rax, QWORD PTR p$[rsp]
	dec	rax
	mov	QWORD PTR p$[rsp], rax
	jmp	SHORT $LN7@Tokenize
$LN8@Tokenize:

; 1135 :             strcpy( commentbuffer, p.input );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR commentbuffer
	call	strcpy

; 1136 :             ModuleInfo.CurrComment = commentbuffer;

	mov	rax, QWORD PTR commentbuffer
	mov	QWORD PTR ModuleInfo+472, rax

; 1137 :             *p.input = NULLC;

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0
$LN15@Tokenize:

; 1138 :         }
; 1139 : 
; 1140 :         tokenarray[p.index].tokpos = p.input;

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx+rax+24], rdx

; 1141 :         if( *p.input == NULLC ) {

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	$LN16@Tokenize

; 1142 :             /* if a comma is last token, concat lines ... with some exceptions
; 1143 :              * v2.05: moved from PreprocessLine(). Moved because the
; 1144 :              * concatenation may be triggered by a comma AFTER expansion.
; 1145 :              */
; 1146 :             if ( p.index > 1 &&
; 1147 :                 tokenarray[p.index-1].token == T_COMMA
; 1148 : #if FASTPASS
; 1149 :                 && ( Parse_Pass == PASS_1 || UseSavedState == FALSE ) /* is it an already preprocessed line? */
; 1150 : #endif
; 1151 :                 && start == 0 ) {

	cmp	DWORD PTR p$[rsp+24], 1
	jbe	$LN17@Tokenize
	mov	eax, DWORD PTR p$[rsp+24]
	dec	eax
	mov	eax, eax
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	jne	$LN17@Tokenize
	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN18@Tokenize
	movzx	eax, BYTE PTR UseSavedState
	test	eax, eax
	jne	$LN17@Tokenize
$LN18@Tokenize:
	cmp	DWORD PTR start$[rsp], 0
	jne	$LN17@Tokenize

; 1152 :                 DebugMsg1(("Tokenize: calling IsMultiLine()\n" ));

	lea	rcx, OFFSET FLAT:$SG11288
	call	DoDebugMsg1

; 1153 :                 if ( IsMultiLine( tokenarray ) ) {

	mov	rcx, QWORD PTR tokenarray$[rsp]
	call	IsMultiLine
	movzx	eax, al
	test	eax, eax
	je	$LN19@Tokenize

; 1154 :                     char *ptr = GetAlignedPointer( p.output, strlen( p.output ) );

	mov	rcx, QWORD PTR p$[rsp+8]
	call	strlen
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR p$[rsp+8]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ptr$4[rsp], rax

; 1155 :                     DebugMsg1(("Tokenize: IsMultiLine(%s)=TRUE\n", line ));

	mov	rdx, QWORD PTR line$[rsp]
	lea	rcx, OFFSET FLAT:$SG11290
	call	DoDebugMsg1

; 1156 :                     if ( GetTextLine( ptr ) ) {

	mov	rcx, QWORD PTR ptr$4[rsp]
	call	GetTextLine
	test	rax, rax
	je	$LN20@Tokenize
$LN9@Tokenize:

; 1157 :                         while ( isspace( *ptr ) ) ptr++;

	mov	rax, QWORD PTR ptr$4[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN10@Tokenize
	mov	rax, QWORD PTR ptr$4[rsp]
	inc	rax
	mov	QWORD PTR ptr$4[rsp], rax
	jmp	SHORT $LN9@Tokenize
$LN10@Tokenize:

; 1158 :                         if ( *ptr ) {

	mov	rax, QWORD PTR ptr$4[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN21@Tokenize

; 1159 :                             strcpy( p.input, ptr );

	mov	rdx, QWORD PTR ptr$4[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	strcpy

; 1160 :                             if ( strlen( p.start ) >= MAX_LINE_LEN ) {

	mov	rcx, QWORD PTR p$[rsp+16]
	call	strlen
	cmp	rax, 600				; 00000258H
	jb	SHORT $LN22@Tokenize

; 1161 :                                 EmitError( LINE_TOO_LONG );

	mov	ecx, 62					; 0000003eH
	call	EmitError

; 1162 :                                 p.index = start;

	mov	eax, DWORD PTR start$[rsp]
	mov	DWORD PTR p$[rsp+24], eax

; 1163 :                                 break;

	jmp	$LN3@Tokenize
$LN22@Tokenize:

; 1164 :                             }
; 1165 :                             DebugMsg1(("Tokenize: line concatenation, line=%s\n", line ));

	mov	rdx, QWORD PTR line$[rsp]
	lea	rcx, OFFSET FLAT:$SG11294
	call	DoDebugMsg1

; 1166 :                             continue;

	jmp	$LN2@Tokenize
$LN21@Tokenize:
$LN20@Tokenize:
$LN19@Tokenize:
$LN17@Tokenize:

; 1167 :                         }
; 1168 :                     }
; 1169 :                 }
; 1170 :             }
; 1171 :             break;

	jmp	$LN3@Tokenize
$LN16@Tokenize:

; 1172 :         }
; 1173 :         tokenarray[p.index].string_ptr = p.output;

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR p$[rsp+8]
	mov	QWORD PTR [rcx+rax+8], rdx

; 1174 :         rc = GetToken( &tokenarray[p.index], &p );

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR p$[rsp]
	mov	rcx, rax
	call	GetToken
	mov	DWORD PTR rc$[rsp], eax

; 1175 :         if ( rc == EMPTY )

	cmp	DWORD PTR rc$[rsp], -2
	jne	SHORT $LN23@Tokenize

; 1176 :             continue;

	jmp	$LN2@Tokenize
$LN23@Tokenize:

; 1177 :         if ( rc == ERROR ) {

	cmp	DWORD PTR rc$[rsp], -1
	jne	SHORT $LN24@Tokenize

; 1178 :             p.index = start; /* skip this line */

	mov	eax, DWORD PTR start$[rsp]
	mov	DWORD PTR p$[rsp+24], eax

; 1179 :             break;

	jmp	$LN3@Tokenize
$LN24@Tokenize:

; 1180 :         }
; 1181 :         /* v2.04: this has been moved here from condasm.c to
; 1182 :          * avoid problems with (conditional) listings. It also
; 1183 :          * avoids having to search for the first token twice.
; 1184 :          * Note: a conditional assembly directive within an
; 1185 :          *    inactive block and preceded by a label isn't detected!
; 1186 :          *    This is an exact copy of the Masm behavior, although
; 1187 :          *    it probably is just a bug!
; 1188 :          */
; 1189 :         if ( !(flags & TOK_RESCAN) ) {

	mov	eax, DWORD PTR flags$[rsp]
	and	eax, 1
	test	eax, eax
	jne	$LN25@Tokenize

; 1190 :             if ( p.index == 0 || ( p.index == 2 && ( tokenarray[1].token == T_COLON || tokenarray[1].token == T_DBL_COLON) ) ) {

	cmp	DWORD PTR p$[rsp+24], 0
	je	SHORT $LN27@Tokenize
	cmp	DWORD PTR p$[rsp+24], 2
	jne	$LN26@Tokenize
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN28@Tokenize
	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 13
	jne	$LN26@Tokenize
$LN28@Tokenize:
$LN27@Tokenize:

; 1191 :                 if ( tokenarray[p.index].token == T_DIRECTIVE &&

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 3
	jne	$LN29@Tokenize
	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1]
	test	eax, eax
	jne	SHORT $LN29@Tokenize

; 1192 :                     tokenarray[p.index].bytval == DRT_CONDDIR ) {
; 1193 :                     if ( tokenarray[p.index].tokval == T_COMMENT ) {

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	cmp	DWORD PTR [rcx+rax+16], 358		; 00000166H
	jne	SHORT $LN31@Tokenize

; 1194 :                         DebugMsg1(("tokenize: COMMENT starting, delim is >%c<\n", ModuleInfo.inside_comment));

	movzx	eax, BYTE PTR ModuleInfo+407
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG11304
	call	DoDebugMsg1

; 1195 :                         StartComment( p.input );

	mov	rcx, QWORD PTR p$[rsp]
	call	StartComment

; 1196 :                         break; /* p.index is 0 or 2 */

	jmp	$LN3@Tokenize
$LN31@Tokenize:

; 1197 :                     }
; 1198 :                     conditional_assembly_prepare( tokenarray[p.index].tokval );

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	ecx, DWORD PTR [rcx+rax+16]
	call	conditional_assembly_prepare

; 1199 :                     if ( CurrIfState != BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, 0
	je	SHORT $LN32@Tokenize

; 1200 :                         p.index++;

	mov	eax, DWORD PTR p$[rsp+24]
	inc	eax
	mov	DWORD PTR p$[rsp+24], eax

; 1201 :                         break; /* p.index is 1 or 3 */

	jmp	$LN3@Tokenize
$LN32@Tokenize:

; 1202 :                     }

	jmp	SHORT $LN30@Tokenize
$LN29@Tokenize:

; 1203 :                 } else if( CurrIfState != BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, 0
	je	SHORT $LN33@Tokenize

; 1204 :                     /* further processing skipped. p.index is 0 */
; 1205 :                     break;

	jmp	SHORT $LN3@Tokenize
$LN33@Tokenize:
$LN30@Tokenize:
$LN26@Tokenize:
$LN25@Tokenize:

; 1206 :                 }
; 1207 :             }
; 1208 :         }
; 1209 :         p.index++;

	mov	eax, DWORD PTR p$[rsp+24]
	inc	eax
	mov	DWORD PTR p$[rsp+24], eax

; 1210 :         if( p.index >= MAX_TOKEN ) {

	cmp	DWORD PTR p$[rsp+24], 150		; 00000096H
	jb	SHORT $LN34@Tokenize

; 1211 :             DebugMsg1(("tokenize: token index %u >= MAX_TOKEN (=%u), line=>%s<\n", p.index, MAX_TOKEN, line ));

	mov	r9, QWORD PTR line$[rsp]
	mov	r8d, 150				; 00000096H
	mov	edx, DWORD PTR p$[rsp+24]
	lea	rcx, OFFSET FLAT:$SG11308
	call	DoDebugMsg1

; 1212 :             EmitError( TOO_MANY_TOKENS );

	mov	ecx, 63					; 0000003fH
	call	EmitError

; 1213 :             p.index = start;

	mov	eax, DWORD PTR start$[rsp]
	mov	DWORD PTR p$[rsp+24], eax

; 1214 :             goto skipline;

	jmp	SHORT $skipline$37
$LN34@Tokenize:

; 1215 :         }
; 1216 : 
; 1217 : #if TOKSTRALIGN
; 1218 :         p.output = GetAlignedPointer( token_stringbuf, p.output - token_stringbuf );

	mov	rax, QWORD PTR token_stringbuf
	mov	rcx, QWORD PTR p$[rsp+8]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR token_stringbuf
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp+8], rax

; 1219 : #endif
; 1220 : 
; 1221 :     }

	jmp	$LN2@Tokenize
$LN3@Tokenize:

; 1222 : #if TOKSTRALIGN
; 1223 :     p.output = GetAlignedPointer( token_stringbuf, p.output - token_stringbuf );

	mov	rax, QWORD PTR token_stringbuf
	mov	rcx, QWORD PTR p$[rsp+8]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 8
	and	rax, -8
	mov	rcx, QWORD PTR token_stringbuf
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp+8], rax

; 1224 : #endif
; 1225 :     StringBufferEnd = p.output;

	mov	rax, QWORD PTR p$[rsp+8]
	mov	QWORD PTR ModuleInfo+488, rax
$skipline$37:

; 1226 : skipline:
; 1227 :     tokenarray[p.index].token  = T_FINAL;

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 1228 :     tokenarray[p.index].bytval = p.flags3;

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	movzx	edx, BYTE PTR p$[rsp+30]
	mov	BYTE PTR [rcx+rax+1], dl

; 1229 :     tokenarray[p.index].string_ptr = "";

	mov	eax, DWORD PTR p$[rsp+24]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR tokenarray$[rsp]
	lea	rdx, OFFSET FLAT:$SG11309
	mov	QWORD PTR [rcx+rax+8], rdx

; 1230 :     return( p.index );

	mov	eax, DWORD PTR p$[rsp+24]

; 1231 : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:Tokenize$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
Tokenize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
token$ = 48
p$ = 56
GetToken PROC

; 1041 : {

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 1042 :     if( isdigit( *p->input ) ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isdigit
	test	eax, eax
	je	SHORT $LN2@GetToken

; 1043 :         return( get_number( token, p ) );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR token$[rsp]
	call	get_number
	jmp	$LN1@GetToken
	jmp	$LN3@GetToken
$LN2@GetToken:

; 1044 :     } else if( is_valid_id_start( *p->input ) ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	QWORD PTR __imp_isalpha
	test	eax, eax
	jne	SHORT $LN6@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN6@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN6@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN6@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN4@GetToken
$LN6@GetToken:

; 1045 :         return( get_id( token, p ) );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR token$[rsp]
	call	get_id
	jmp	$LN1@GetToken

; 1046 :     } else if( *p->input == '.' &&

	jmp	$LN5@GetToken
$LN4@GetToken:

; 1047 : #if DOTNAMEX /* allow dots within identifiers */
; 1048 :               ( is_valid_id_char(*(p->input+1)) || *(p->input+1) == '.' ) &&
; 1049 : #else
; 1050 :               is_valid_id_char(*(p->input+1)) &&

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 46					; 0000002eH
	jne	$LN7@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+1]
	mov	ecx, eax
	call	QWORD PTR __imp_isalnum
	test	eax, eax
	jne	SHORT $LN9@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN9@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN9@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN9@GetToken
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN7@GetToken
$LN9@GetToken:
	mov	rax, QWORD PTR p$[rsp]
	cmp	DWORD PTR [rax+24], 0
	je	SHORT $LN10@GetToken
	mov	eax, 32					; 00000020H
	imul	rax, rax, -1
	mov	rcx, QWORD PTR token$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 2
	je	SHORT $LN7@GetToken
	mov	eax, 32					; 00000020H
	imul	rax, rax, -1
	mov	rcx, QWORD PTR token$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN7@GetToken
	mov	eax, 32					; 00000020H
	imul	rax, rax, -1
	mov	rcx, QWORD PTR token$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN7@GetToken
	mov	eax, 32					; 00000020H
	imul	rax, rax, -1
	mov	rcx, QWORD PTR token$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN7@GetToken
$LN10@GetToken:

; 1051 : #endif
; 1052 :               /* v2.11: member last_token has been removed */
; 1053 :               //( p->last_token != T_REG &&  p->last_token != T_CL_BRACKET && p->last_token != T_CL_SQ_BRACKET && p->last_token != T_ID ) ) {
; 1054 :               ( p->index == 0 || ( token[-1].token != T_REG && token[-1].token != T_CL_BRACKET && token[-1].token != T_CL_SQ_BRACKET && token[-1].token != T_ID ) ) ) {
; 1055 :         return( get_id( token, p ) );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR token$[rsp]
	call	get_id
	jmp	SHORT $LN1@GetToken
	jmp	SHORT $LN8@GetToken
$LN7@GetToken:

; 1056 : #if BACKQUOTES
; 1057 :     } else if( *p->input == '`' && Options.strict_masm_compat == FALSE ) {

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 96					; 00000060H
	jne	SHORT $LN11@GetToken
	movzx	eax, BYTE PTR Options+143
	test	eax, eax
	jne	SHORT $LN11@GetToken

; 1058 :         return( get_id_in_backquotes( token, p ) );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR token$[rsp]
	call	get_id_in_backquotes
	jmp	SHORT $LN1@GetToken
$LN11@GetToken:
$LN8@GetToken:
$LN5@GetToken:
$LN3@GetToken:

; 1059 : #endif
; 1060 :     }
; 1061 :     return( get_special_symbol( token, p ) );

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR token$[rsp]
	call	get_special_symbol
$LN1@GetToken:

; 1062 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
GetToken ENDP
_TEXT	ENDS
END
