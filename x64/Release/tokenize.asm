; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG11284 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
_DATA	ENDS
_DATA	SEGMENT
$SG10899 DB	'1to2', 00H
	ORG $+3
$SG10902 DB	'1to4', 00H
	ORG $+3
$SG10905 DB	'1to8', 00H
	ORG $+3
$SG10908 DB	'1to16', 00H
	ORG $+2
$SG11079 DB	'::', 00H
	ORG $+1
$SG11080 DB	':', 00H
	ORG $+2
$SG11083 DB	'OUT', 00H
$SG11085 DB	'%', 00H
	ORG $+2
$SG11097 DB	'=', 00H
	ORG $+2
$SG11107 DB	'&', 00H
	ORG $+2
$SG11100 DB	'=!<>&|', 0a6H, 00H
$SG11192 DB	'?', 00H
_DATA	ENDS
CONST	SEGMENT
stokstr1 DW	028H
	DW	029H
	DW	02aH
	DW	02bH
	DW	02cH
	DW	02dH
	DW	02eH
	DW	02fH
stokstr2 DW	05bH
	DW	00H
	DW	05dH
CONST	ENDS
PUBLIC	GetToken
PUBLIC	Tokenize
PUBLIC	get_broads
PUBLIC	get_decos
EXTRN	isalpha:PROC
EXTRN	isdigit:PROC
EXTRN	isspace:PROC
EXTRN	isalnum:PROC
EXTRN	strchr:PROC
EXTRN	_memicmp:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	SymFind:PROC
EXTRN	conditional_assembly_prepare:PROC
EXTRN	FindResWord:PROC
EXTRN	GetTextLine:PROC
EXTRN	memcpy:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	InstrTable:BYTE
EXTRN	SpecialTable:BYTE
EXTRN	optable_idx:BYTE
EXTRN	CurrIfState:DWORD
EXTRN	UseSavedState:BYTE
EXTRN	token_stringbuf:QWORD
EXTRN	commentbuffer:QWORD
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$GetToken DD imagerel $LN32
	DD	imagerel $LN32+55
	DD	imagerel $unwind$GetToken
$pdata$0$GetToken DD imagerel $LN32+55
	DD	imagerel $LN32+318
	DD	imagerel $chain$0$GetToken
$pdata$2$GetToken DD imagerel $LN32+318
	DD	imagerel $LN32+362
	DD	imagerel $chain$2$GetToken
$pdata$4$GetToken DD imagerel $LN32+362
	DD	imagerel $LN32+388
	DD	imagerel $chain$4$GetToken
$pdata$6$GetToken DD imagerel $LN32+388
	DD	imagerel $LN32+414
	DD	imagerel $chain$6$GetToken
$pdata$Tokenize DD imagerel $LN131
	DD	imagerel $LN131+850
	DD	imagerel $unwind$Tokenize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsMultiLine DD imagerel IsMultiLine
	DD	imagerel IsMultiLine+132
	DD	imagerel $unwind$IsMultiLine
pdata	ENDS
pdata	SEGMENT
$pdata$get_broads DD imagerel $LN14
	DD	imagerel $LN14+228
	DD	imagerel $unwind$get_broads
$pdata$get_decos DD imagerel $LN38
	DD	imagerel $LN38+405
	DD	imagerel $unwind$get_decos
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_float DD imagerel get_float
	DD	imagerel get_float+47
	DD	imagerel $unwind$get_float
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$get_float DD imagerel get_float+47
	DD	imagerel get_float+137
	DD	imagerel $chain$0$get_float
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$get_float DD imagerel get_float+137
	DD	imagerel get_float+214
	DD	imagerel $chain$1$get_float
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConcatLine DD imagerel ConcatLine
	DD	imagerel ConcatLine+264
	DD	imagerel $unwind$ConcatLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_string DD imagerel get_string
	DD	imagerel get_string+1059
	DD	imagerel $unwind$get_string
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_special_symbol DD imagerel get_special_symbol
	DD	imagerel get_special_symbol+857
	DD	imagerel $unwind$get_special_symbol
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_number DD imagerel get_number
	DD	imagerel get_number+536
	DD	imagerel $unwind$get_number
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$get_number DD imagerel get_number+536
	DD	imagerel get_number+576
	DD	imagerel $chain$0$get_number
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$get_number DD imagerel get_number+576
	DD	imagerel get_number+740
	DD	imagerel $chain$1$get_number
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_id_in_backquotes DD imagerel get_id_in_backquotes
	DD	imagerel get_id_in_backquotes+114
	DD	imagerel $unwind$get_id_in_backquotes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_id DD imagerel get_id
	DD	imagerel get_id+616
	DD	imagerel $unwind$get_id
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$StartComment DD imagerel StartComment
	DD	imagerel StartComment+115
	DD	imagerel $unwind$StartComment
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StartComment DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_id DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_id_in_backquotes DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$get_number DD 021H
	DD	imagerel get_number
	DD	imagerel get_number+536
	DD	imagerel $unwind$get_number
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$get_number DD 020521H
	DD	06e405H
	DD	imagerel get_number
	DD	imagerel get_number+536
	DD	imagerel $unwind$get_number
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_number DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_special_symbol DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_string DD 0c2101H
	DD	0d6421H
	DD	0c5421H
	DD	0b3421H
	DD	0f01d3221H
	DD	0d019e01bH
	DD	07015c017H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConcatLine DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$get_float DD 021H
	DD	imagerel get_float
	DD	imagerel get_float+47
	DD	imagerel $unwind$get_float
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$get_float DD 020521H
	DD	086405H
	DD	imagerel get_float
	DD	imagerel get_float+47
	DD	imagerel $unwind$get_float
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_float DD 0a1901H
	DD	0b7419H
	DD	0a5419H
	DD	093419H
	DD	0f0153219H
	DD	0c011e013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsMultiLine DD 010401H
	DD	04204H
xdata	ENDS
xdata	SEGMENT
$unwind$GetToken DD 040a01H
	DD	07340aH
	DD	07006320aH
$chain$0$GetToken DD 020521H
	DD	066405H
	DD	imagerel $LN32
	DD	imagerel $LN32+55
	DD	imagerel $unwind$GetToken
$chain$2$GetToken DD 020021H
	DD	066400H
	DD	imagerel $LN32
	DD	imagerel $LN32+55
	DD	imagerel $unwind$GetToken
$chain$4$GetToken DD 020021H
	DD	066400H
	DD	imagerel $LN32
	DD	imagerel $LN32+55
	DD	imagerel $unwind$GetToken
$chain$6$GetToken DD 020021H
	DD	066400H
	DD	imagerel $LN32
	DD	imagerel $LN32+55
	DD	imagerel $unwind$GetToken
$unwind$Tokenize DD 0c2301H
	DD	0117423H
	DD	0106423H
	DD	0e3423H
	DD	0f01c7223H
	DD	0d018e01aH
	DD	05014c016H
$unwind$get_broads DD 020601H
	DD	030023206H
$unwind$get_decos DD 020601H
	DD	030023206H
xdata	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
;	COMDAT StartComment
_TEXT	SEGMENT
p$ = 48
StartComment PROC					; COMDAT

; 1068 : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1069 :     while ( isspace( *p ) ) p++;

	movsx	ecx, BYTE PTR [rcx]
	call	isspace
	test	eax, eax
	je	SHORT $LN3@StartComme
	npad	11
$LL2@StartComme:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL2@StartComme
$LN3@StartComme:

; 1070 :     if ( *p == NULLC ) {

	movzx	eax, BYTE PTR [rbx]
	test	al, al
	jne	SHORT $LN4@StartComme

; 1071 :         EmitError( COMMENT_DELIMITER_EXPECTED );

	mov	ecx, 99					; 00000063H

; 1076 :         ModuleInfo.inside_comment = NULLC;
; 1077 :     return;
; 1078 : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1071 :         EmitError( COMMENT_DELIMITER_EXPECTED );

	jmp	EmitError
$LN4@StartComme:

; 1072 :         return;
; 1073 :     }
; 1074 :     ModuleInfo.inside_comment = *p++;
; 1075 :     if( strchr( p, ModuleInfo.inside_comment ) )

	movzx	edx, al
	lea	rcx, QWORD PTR [rbx+1]
	mov	BYTE PTR ModuleInfo+407, al
	call	strchr
	movzx	ecx, BYTE PTR ModuleInfo+407
	xor	edx, edx
	test	rax, rax
	cmovne	ecx, edx
	mov	BYTE PTR ModuleInfo+407, cl

; 1076 :         ModuleInfo.inside_comment = NULLC;
; 1077 :     return;
; 1078 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
StartComment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
;	COMDAT get_id
_TEXT	SEGMENT
buf$ = 48
p$ = 56
get_id	PROC						; COMDAT

; 855  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 856  :     //struct ReservedWord *resw;
; 857  :     char *src = p->input;

	mov	rsi, QWORD PTR [rdx]
	mov	rbx, rdx

; 858  :     char *dst = p->output;

	mov	r14, QWORD PTR [rdx+8]
	mov	rdi, rcx
	npad	9
$LL4@get_id:

; 859  :     int  index;
; 860  :     unsigned size;
; 861  : 
; 862  : #if CONCATID || DOTNAMEX
; 863  : continue_scan:
; 864  : #endif
; 865  :     do {
; 866  :         *dst++ = *src++;

	movzx	eax, BYTE PTR [rsi]
	inc	rsi
	mov	BYTE PTR [r14], al
	inc	r14

; 867  :     } while ( is_valid_id_char( *src ) );

	movsx	ecx, BYTE PTR [rsi]
	call	isalnum
	test	eax, eax
	jne	SHORT $LL4@get_id
	movzx	eax, BYTE PTR [rsi]
	cmp	al, 95					; 0000005fH
	je	SHORT $LL4@get_id
	cmp	al, 64					; 00000040H
	je	SHORT $LL4@get_id
	cmp	al, 36					; 00000024H
	je	SHORT $LL4@get_id
	cmp	al, 63					; 0000003fH
	je	SHORT $LL4@get_id

; 868  : #if CONCATID
; 869  :     /* v2.05: in case there's a backslash right behind
; 870  :      * the ID, check if a line concatenation is to occur.
; 871  :      * If yes, and the first char of the concatenated line
; 872  :      * is also a valid ID char, continue to scan the name.
; 873  :      * Problem: it's ok for EQU, but less good for other directives.
; 874  :      */
; 875  :     if ( *src == '\\' ) {
; 876  :         if ( ConcatLine( src, src - p->input, dst, p ) != EMPTY ) {
; 877  :             p->concat = TRUE;
; 878  :             if ( is_valid_id_char( *src ) )
; 879  :                 goto continue_scan;
; 880  :         }
; 881  :     }
; 882  : #endif
; 883  : #if DOTNAMEX
; 884  :     /* if the name starts with a dot or underscore, then accept dots
; 885  :      * within the name (though not as last char). OPTION DOTNAME
; 886  :      * must be on.
; 887  :      */
; 888  :     if ( *src == '.' && ModuleInfo.dotname &&
; 889  :         ( *(p->output) == '.' || *(p->output) == '_' ) &&
; 890  :         ( is_valid_id_char(*(src+1)) || *(src+1) == '.' ) )
; 891  :         goto continue_scan;
; 892  : #endif
; 893  :     /* v2.04: check added */
; 894  :     size = dst - p->output;

	mov	ebp, r14d
	sub	ebp, DWORD PTR [rbx+8]

; 895  :     if ( size > MAX_ID_LEN ) {

	cmp	ebp, 247				; 000000f7H
	jbe	SHORT $LN9@get_id

; 896  :         EmitErr( IDENTIFIER_TOO_LONG );

	mov	ecx, 71					; 00000047H
	call	EmitErr

; 897  :         dst = p->output + MAX_ID_LEN;

	mov	r14, QWORD PTR [rbx+8]
	add	r14, 247				; 000000f7H
$LN9@get_id:

; 898  :     }
; 899  :     *dst++ = NULLC;

	mov	BYTE PTR [r14], 0
	inc	r14

; 900  : 
; 901  :     /* now decide what to do with it */
; 902  : 
; 903  :     if( size == 1 && *p->output == '?' ) {

	cmp	ebp, 1
	jne	SHORT $LN10@get_id
	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax], 63			; 0000003fH
	jne	SHORT $LN10@get_id

; 904  :         p->input = src;

	mov	QWORD PTR [rbx], rsi

; 905  :         buf->token = T_QUESTION_MARK;
; 906  :         buf->string_ptr = "?";

	lea	rax, OFFSET FLAT:$SG11192
	mov	QWORD PTR [rdi+8], rax
	mov	BYTE PTR [rdi], 63			; 0000003fH

; 907  :         return( NOT_ERROR );

	jmp	SHORT $LN5@get_id
$LN10@get_id:

; 908  :     }
; 909  :     index = FindResWord( p->output, size );

	mov	rcx, QWORD PTR [rbx+8]
	movzx	edx, bpl
	call	FindResWord

; 910  :     if( index == 0 ) {

	test	eax, eax
	jne	SHORT $LN11@get_id

; 911  :         /* if ID begins with a DOT, check for OPTION DOTNAME.
; 912  :          * if not set, skip the token and return a T_DOT instead!
; 913  :          */
; 914  :         if ( *p->output == '.' && ModuleInfo.dotname == FALSE ) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax], 46			; 0000002eH
	jne	SHORT $LN12@get_id
	test	BYTE PTR ModuleInfo+408, 16
	jne	SHORT $LN12@get_id

; 915  :            buf->token = T_DOT;
; 916  :            buf->string_ptr = (char *)&stokstr1['.' - '('];

	lea	rax, OFFSET FLAT:stokstr1+12
	mov	BYTE PTR [rdi], 46			; 0000002eH
	mov	QWORD PTR [rdi+8], rax

; 917  :            p->input++;

	inc	QWORD PTR [rbx]

; 918  :            return( NOT_ERROR );

	jmp	SHORT $LN5@get_id
$LN12@get_id:

; 919  :         }
; 920  :         p->input = src;

	mov	QWORD PTR [rbx], rsi

; 921  :         p->output = dst;

	mov	QWORD PTR [rbx+8], r14
$LN25@get_id:

; 1012 :     default: /* shouldn't happen */
; 1013 :         DebugMsg(("get_id: error, unknown type in SpecialTable[%u]=%u\n", index, SpecialTable[index].type ));
; 1014 :         /**/myassert( 0 );
; 1015 :         buf->token = T_ID;

	mov	BYTE PTR [rdi], 8

; 1016 :         buf->idarg = 0;

	mov	DWORD PTR [rdi+16], 0
$LN5@get_id:

; 1017 :         break;
; 1018 :     }
; 1019 :     return( NOT_ERROR );
; 1020 : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN11@get_id:

; 922  :         buf->token = T_ID;
; 923  :         buf->idarg = 0;
; 924  :         return( NOT_ERROR );
; 925  :     }
; 926  :     p->input = src;

	mov	QWORD PTR [rbx], rsi

; 927  :     p->output = dst;

	mov	QWORD PTR [rbx+8], r14

; 928  :     buf->tokval = index; /* is a enum instr_token value */

	mov	DWORD PTR [rdi+16], eax

; 929  :     /* v2.11: RWF_SPECIAL now obsolete */
; 930  :     //if ( ! ( ResWordTable[index].flags & RWF_SPECIAL ) ) {
; 931  :     if ( index >= SPECIAL_LAST ) {

	cmp	eax, 450				; 000001c2H
	jl	SHORT $LN13@get_id

; 932  : 
; 933  :         //  DebugMsg(("found item >%s< in instruction table, rm=%X\n", buf->string_ptr, InstrTable[index].rm_byte));
; 934  : 
; 935  :         /* if -Zm is set, the following from the Masm docs is relevant:
; 936  :          *
; 937  :          * Reserved Keywords Dependent on CPU Mode with OPTION M510
; 938  :          *
; 939  :          * With OPTION M510, keywords and instructions not available in the
; 940  :          * current CPU mode (such as ENTER under .8086) are not treated as
; 941  :          * keywords. This also means the USE32, FLAT, FAR32, and NEAR32 segment
; 942  :          * types and the 80386/486 registers are not keywords with a processor
; 943  :          * selection less than .386.
; 944  :          * If you remove OPTION M510, any reserved word used as an identifier
; 945  :          * generates a syntax error. You can either rename the identifiers or
; 946  :          * use OPTION NOKEYWORD. For more information on OPTION NOKEYWORD, see
; 947  :          * OPTION NOKEYWORD, later in this appendix.
; 948  :          *
; 949  :          * The current implementation of this rule below is likely to be improved.
; 950  :          */
; 951  :         if ( ModuleInfo.m510 ) {

	test	BYTE PTR ModuleInfo+408, 64		; 00000040H
	je	SHORT $LN15@get_id

; 952  :             /* checking the cpu won't give the expected results currently since
; 953  :              * some instructions in the table (i.e. MOV) start with a 386 variant!
; 954  :              */
; 955  :             index = IndexFromToken( buf->tokval );

	add	eax, -450				; fffffe3eH
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, WORD PTR optable_idx[rdx+rax*2]

; 956  : #if 0 /* changed for v1.96 */
; 957  :             if (( InstrTable[index].cpu & P_EXT_MASK ) > ( ModuleInfo.curr_cpu & P_EXT_MASK )) {
; 958  : #else
; 959  :             if (( InstrTable[index].cpu & P_CPU_MASK ) > ( ModuleInfo.curr_cpu & P_CPU_MASK ) ||

	imul	rax, rax, 14
	movzx	r8d, WORD PTR InstrTable[rax+rdx+10]
	mov	edx, DWORD PTR ModuleInfo+392
	mov	ecx, r8d
	mov	eax, edx
	and	ecx, 240				; 000000f0H
	and	eax, 240				; 000000f0H
	cmp	ecx, eax
	jg	SHORT $LN25@get_id
	and	r8d, 65280				; 0000ff00H
	and	edx, 65280				; 0000ff00H
	cmp	r8d, edx
	jg	$LN25@get_id
$LN15@get_id:

; 960  :                 ( InstrTable[index].cpu & P_EXT_MASK ) > ( ModuleInfo.curr_cpu & P_EXT_MASK )) {
; 961  : #endif
; 962  :                 buf->token = T_ID;
; 963  :                 buf->idarg = 0;
; 964  :                 return( NOT_ERROR );
; 965  :             }
; 966  :         }
; 967  :         buf->token = T_INSTRUCTION;

	mov	BYTE PTR [rdi], 1

; 968  :         return( NOT_ERROR );

	jmp	$LN5@get_id
$LN13@get_id:

; 969  :     }
; 970  :     index = buf->tokval;
; 971  : 
; 972  :     /* for RWT_SPECIAL, field <bytval> contains further infos:
; 973  :      - RWT_REG:             register number (regnum)
; 974  :      - RWT_DIRECTIVE:       type of directive (dirtype)
; 975  :      - RWT_UNARY_OPERATOR:  operator precedence
; 976  :      - RWT_BINARY_OPERATOR: operator precedence
; 977  :      - RWT_STYPE:           memtype
; 978  :      - RWT_RES_ID:          for languages, LANG_xxx value
; 979  :                             for the rest, unused.
; 980  :      */
; 981  :     buf->bytval = SpecialTable[index].bytval;

	cdqe
	lea	rdx, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	r8, QWORD PTR [rcx*4]
	movzx	eax, BYTE PTR SpecialTable[r8+rdx+10]
	mov	BYTE PTR [rdi+1], al

; 982  : 
; 983  :     switch ( SpecialTable[index].type ) {

	movzx	eax, BYTE PTR SpecialTable[r8+rdx+11]
	add	eax, -2
	cmp	eax, 5
	ja	$LN25@get_id
	cdqe
	mov	ecx, DWORD PTR $LN38@get_id[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN17@get_id:

; 984  :     case RWT_REG:
; 985  :         buf->token = T_REG;

	mov	BYTE PTR [rdi], 2

; 986  : #if AVXSUPP 
; 987  :         /* Intercept here '{' for EVEX mask  {k1}{z} */
; 988  :         while ( isspace( *p->input )) p->input++;

	mov	rax, QWORD PTR [rbx]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN8@get_id
	npad	13
$LL7@get_id:
	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL7@get_id
$LN8@get_id:

; 989  :         if (*p->input == '{'){

	mov	rax, QWORD PTR [rbx]
	cmp	BYTE PTR [rax], 123			; 0000007bH
	jne	$LN5@get_id

; 990  :           p->input++;

	inc	rax

; 991  :           get_decos( p ) ; // mask decorators

	mov	rcx, rbx
	mov	QWORD PTR [rbx], rax
	call	get_decos

; 992  :       }
; 993  : #endif        
; 994  :         break;

	jmp	$LN5@get_id
$LN19@get_id:

; 995  :     case RWT_DIRECTIVE:
; 996  :         buf->token = T_DIRECTIVE;

	mov	BYTE PTR [rdi], 3

; 997  :         if ( p->flags2 == 0 )

	cmp	BYTE PTR [rbx+29], 0
	jne	$LN5@get_id

; 998  :             p->flags2 = SpecialTable[index].value;

	movzx	eax, BYTE PTR SpecialTable[r8+rdx]
	mov	BYTE PTR [rbx+29], al

; 999  :         break;

	jmp	$LN5@get_id
$LN21@get_id:

; 1000 :     case RWT_UNARY_OP: /* OFFSET, LOW, HIGH, LOWWORD, HIGHWORD, SHORT, ... */
; 1001 :         buf->token  = T_UNARY_OPERATOR;

	mov	BYTE PTR [rdi], 4

; 1002 :         break;

	jmp	$LN5@get_id
$LN22@get_id:

; 1003 :     case RWT_BINARY_OP: /* GE, GT, LE, LT, EQ, NE, MOD, PTR */
; 1004 :         buf->token = T_BINARY_OPERATOR;

	mov	BYTE PTR [rdi], 5

; 1005 :         break;

	jmp	$LN5@get_id
$LN23@get_id:

; 1006 :     case RWT_STYPE:  /* BYTE, WORD, FAR, NEAR, FAR16, NEAR32 ... */
; 1007 :         buf->token = T_STYPE;

	mov	BYTE PTR [rdi], 6

; 1008 :         break;

	jmp	$LN5@get_id
$LN24@get_id:

; 1009 :     case RWT_RES_ID: /* DUP, ADDR, FLAT, VARARG, language types [, FRAME (64-bit)] */
; 1010 :         buf->token = T_RES_ID;

	mov	BYTE PTR [rdi], 7

; 1011 :         break;

	jmp	$LN5@get_id
	npad	1
$LN38@get_id:

; 1017 :         break;
; 1018 :     }
; 1019 :     return( NOT_ERROR );
; 1020 : }

	DD	$LN17@get_id
	DD	$LN19@get_id
	DD	$LN21@get_id
	DD	$LN22@get_id
	DD	$LN23@get_id
	DD	$LN24@get_id
get_id	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
;	COMDAT get_id_in_backquotes
_TEXT	SEGMENT
buf$ = 48
p$ = 56
get_id_in_backquotes PROC				; COMDAT

; 830  : {

	sub	rsp, 40					; 00000028H

; 831  :     char *optr = p->output;

	mov	r8, QWORD PTR [rdx+8]

; 832  :     buf->token = T_ID;

	mov	BYTE PTR [rcx], 8

; 833  :     buf->idarg = 0;

	mov	DWORD PTR [rcx+16], 0

; 834  : 
; 835  :     p->input++;         /* strip off the backquotes */

	inc	QWORD PTR [rdx]
	mov	rcx, QWORD PTR [rdx]

; 836  :     for( ; *p->input != '`'; ) {

	movzx	eax, BYTE PTR [rcx]
	cmp	al, 96					; 00000060H
	je	SHORT $LN3@get_id_in_
	npad	1
$LL2@get_id_in_:

; 837  :         if( *p->input == NULLC || *p->input == ';' ) {

	test	al, al
	je	SHORT $LN9@get_id_in_
	cmp	al, 59					; 0000003bH
	je	SHORT $LN9@get_id_in_

; 841  :         }
; 842  :         *optr++ = *p->input++;

	mov	BYTE PTR [r8], al
	inc	r8
	inc	QWORD PTR [rdx]
	mov	rcx, QWORD PTR [rdx]
	movzx	eax, BYTE PTR [rcx]
	cmp	al, 96					; 00000060H
	jne	SHORT $LL2@get_id_in_
$LN3@get_id_in_:

; 843  :     }
; 844  :     p->input++;         /* skip the terminating '`' */

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdx], rax

; 845  :     *optr++ = NULLC;

	lea	rax, QWORD PTR [r8+1]
	mov	BYTE PTR [r8], 0

; 846  :     p->output = optr;

	mov	QWORD PTR [rdx+8], rax

; 847  :     return( NOT_ERROR );

	xor	eax, eax

; 848  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN9@get_id_in_:

; 838  :             *p->output = NULLC;

	mov	rax, QWORD PTR [rdx+8]

; 839  :             EmitErr( BACKQUOTE_MISSING, p->output );

	mov	ecx, 98					; 00000062H
	mov	BYTE PTR [rax], 0
	mov	rdx, QWORD PTR [rdx+8]
	call	EmitErr

; 840  :             return( ERROR );

	or	eax, -1

; 848  : }

	add	rsp, 40					; 00000028H
	ret	0
get_id_in_backquotes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
;	COMDAT get_number
_TEXT	SEGMENT
buf$ = 48
p$ = 56
get_number PROC						; COMDAT

; 673  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 674  :     char                *ptr = p->input;

	mov	rdi, QWORD PTR [rdx]

; 675  :     char                *dig_start;
; 676  :     char                *dig_end;
; 677  :     unsigned            base = 0;

	xor	r8d, r8d
	mov	rsi, rdx
	mov	rbx, rcx

; 678  :     unsigned            len;
; 679  :     uint_32             digits_seen;
; 680  :     char                last_char;
; 681  : 
; 682  : #define VALID_BINARY    0x0003
; 683  : #define VALID_OCTAL     0x00ff
; 684  : #define VALID_DECIMAL   0x03ff
; 685  : #define OK_NUM( t )     ((digits_seen & ~VALID_##t) == 0)
; 686  : 
; 687  :     digits_seen = 0;

	mov	r9d, r8d

; 688  : #if CHEXPREFIX
; 689  :     if( *ptr == '0' && (tolower( *(ptr+1) ) == 'x' ) ) {

	cmp	BYTE PTR [rdi], 48			; 00000030H
	jne	SHORT $LN12@get_number
	movzx	r10d, BYTE PTR [rdi+1]
	lea	eax, DWORD PTR [r10-65]
	cmp	al, 25
	movsx	eax, r10b
	ja	SHORT $LN39@get_number
	or	eax, 32					; 00000020H
$LN39@get_number:
	cmp	eax, 120				; 00000078H
	jne	SHORT $LN12@get_number

; 690  :         ptr += 2;

	add	rdi, 2

; 691  :         base = 16;

	lea	r8d, QWORD PTR [rax-104]
$LN12@get_number:

; 692  :     }
; 693  : #endif
; 694  :     dig_start = ptr;

	mov	rbp, rdi
	mov	r11d, 1
$LL4@get_number:

; 695  :     for( ;; ptr++ ) {
; 696  :         if (*ptr >= '0' && *ptr <= '9')

	movzx	ecx, BYTE PTR [rdi]
	lea	eax, DWORD PTR [rcx-48]
	cmp	al, 9
	ja	SHORT $LN13@get_number

; 697  :             digits_seen |= 1 << (*ptr - '0');

	movsx	ecx, cl

; 701  :                 digits_seen |= 1 << ( last_char + 10 - 'a' );

	mov	edx, r11d
	sub	ecx, 48					; 00000030H
	shl	edx, cl
	or	r9d, edx
	inc	rdi
	jmp	SHORT $LL4@get_number
$LN13@get_number:
	lea	eax, DWORD PTR [rcx-65]
	cmp	al, 25
	ja	SHORT $LN40@get_number

; 698  :         else {
; 699  :             last_char = tolower( *ptr );

	or	cl, 32					; 00000020H
$LN40@get_number:

; 700  :             if ( last_char >= 'a' && last_char <= 'f' )

	lea	eax, DWORD PTR [rcx-97]
	cmp	al, 5
	ja	SHORT $LN15@get_number

; 701  :                 digits_seen |= 1 << ( last_char + 10 - 'a' );

	movsx	ecx, cl
	mov	edx, r11d
	sub	ecx, 87					; 00000057H
	shl	edx, cl
	or	r9d, edx
	inc	rdi
	jmp	SHORT $LL4@get_number
$LN15@get_number:

; 702  :             else
; 703  :                 break;
; 704  :         }
; 705  :     }
; 706  : 
; 707  :     /* note that a float MUST contain a dot.
; 708  :      * 1234e78 is NOT a valid float
; 709  :      */
; 710  :     if ( last_char == '.' )

	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN17@get_number

; 711  :         return( get_float( buf, p ) );

	mov	rdx, rsi
	mov	rcx, rbx
	call	get_float
	jmp	$LN1@get_number
$LN17@get_number:

; 712  : 
; 713  : #if 0
; 714  :     /* v2.08: if suffix isn't followed by a non-id char, don't use it! */
; 715  :     if ( last_char && is_valid_id_char( *(ptr+1) ) ) {
; 716  :         last_char = NULLC;
; 717  :         while ( *(ptr-1) > '9' )
; 718  :             ptr--;
; 719  :         digits_seen &= 0x3FF;
; 720  : 
; 721  :     }
; 722  : #endif
; 723  : 
; 724  : #if CHEXPREFIX
; 725  :     if ( base != 0 ) {

	test	r8d, r8d
	je	SHORT $LN18@get_number

; 726  :         dig_end = ptr;

	mov	rdx, rdi

; 727  :         if ( digits_seen == 0 )

	test	r9d, r9d
	jne	$LN33@get_number
$LN34@get_number:

; 811  :         buf->token = T_BAD_NUM;

	mov	BYTE PTR [rbx], 12
	mov	rbx, 576460752706076673			; 0800000018000001H
$LL10@get_number:

; 812  :         DebugMsg(("get_number: BAD_NUMBER (%s), radix=%u, base=%u, ptr=>%s<, digits_seen=%Xh\n", dig_start, ModuleInfo.radix, base, ptr, digits_seen ));
; 813  :         /* swallow remainder of token */
; 814  :         while( is_valid_id_char( *ptr ) ) ++ptr;

	movsx	ecx, BYTE PTR [rdi]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN36@get_number
	movzx	eax, BYTE PTR [rdi]
	sub	al, 36					; 00000024H
	cmp	al, 59					; 0000003bH
	ja	SHORT $number_done$69
	bt	rbx, rax
	jae	SHORT $number_done$69
$LN36@get_number:
	inc	rdi
	jmp	SHORT $LL10@get_number
$LN18@get_number:

; 728  :             base = 0;
; 729  :     } else
; 730  : #endif
; 731  :     switch( last_char ) {

	movsx	eax, cl
	add	eax, -104				; ffffffffffffff98H
	cmp	eax, 17
	ja	$LN29@get_number
	lea	rdx, OFFSET FLAT:__ImageBase
	cdqe
	mov	ecx, DWORD PTR $LN63@get_number[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN21@get_number:

; 732  :     case 'r': /* a float with the "real number designator" */
; 733  :         buf->token = T_FLOAT;

	mov	WORD PTR [rbx], 29195			; 0000720bH

; 734  :         buf->floattype = 'r';
; 735  :         ptr++;

	inc	rdi
$number_done$69:

; 815  :     }
; 816  : number_done:
; 817  :     len = ptr - p->input;
; 818  :     memcpy( p->output, p->input, len );

	mov	rdx, QWORD PTR [rsi]
	mov	eax, edi
	sub	eax, DWORD PTR [rsi]
	mov	rcx, QWORD PTR [rsi+8]
	mov	r8d, eax
	mov	ebx, eax
	call	memcpy

; 819  : 
; 820  :     p->output += len;

	add	QWORD PTR [rsi+8], rbx
	mov	rax, QWORD PTR [rsi+8]

; 821  :     *p->output++ = NULLC;

	mov	BYTE PTR [rax], 0
	inc	QWORD PTR [rsi+8]

; 822  :     p->input = ptr;
; 823  : 
; 824  :     return( NOT_ERROR );

	xor	eax, eax
	mov	QWORD PTR [rsi], rdi
$LN1@get_number:

; 825  : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN22@get_number:

; 736  :         goto number_done;
; 737  :     case 'h':
; 738  :         base = 16;
; 739  :         dig_end = ptr;

	mov	rdx, rdi

; 803  : #else
; 804  :     if ( base != 0 && is_valid_id_char( *ptr ) == FALSE ) {
; 805  : #endif
; 806  :         buf->token = T_NUM;

	mov	BYTE PTR [rbx], 10
	inc	rdi
	mov	r8d, 16

; 807  :         buf->numbase = base;
; 808  :         buf->itemlen = dig_end - dig_start;

	sub	edx, ebp
	mov	BYTE PTR [rbx+1], r8b
	mov	DWORD PTR [rbx+16], edx

; 809  :         //DebugMsg(("get_number: inp=%s, value=%" I32_SPEC "X\n", p->input, buf->value64 ));
; 810  :     } else {

	jmp	SHORT $number_done$69
$LN23@get_number:

; 740  :         ptr++;
; 741  :         break;
; 742  :     //case 'b':
; 743  :     case 'y':
; 744  :         if( OK_NUM( BINARY ) ) {

	test	r9d, -4					; fffffffcH
	jne	$LN34@get_number

; 745  :             base = 2;
; 746  :             dig_end = ptr;

	mov	rdx, rdi

; 803  : #else
; 804  :     if ( base != 0 && is_valid_id_char( *ptr ) == FALSE ) {
; 805  : #endif
; 806  :         buf->token = T_NUM;

	mov	BYTE PTR [rbx], 10
	inc	rdi
	mov	r8d, 2

; 807  :         buf->numbase = base;
; 808  :         buf->itemlen = dig_end - dig_start;

	sub	edx, ebp
	mov	BYTE PTR [rbx+1], r8b
	mov	DWORD PTR [rbx+16], edx

; 809  :         //DebugMsg(("get_number: inp=%s, value=%" I32_SPEC "X\n", p->input, buf->value64 ));
; 810  :     } else {

	jmp	SHORT $number_done$69
$LN25@get_number:

; 747  :             ptr++;
; 748  :         }
; 749  :         break;
; 750  :     //case 'd':
; 751  :     case 't':
; 752  :         if( OK_NUM( DECIMAL ) ) {

	test	r9d, -1024				; fffffc00H
	jne	$LN34@get_number

; 753  :             base = 10;
; 754  :             dig_end = ptr;

	mov	rdx, rdi
	mov	r8d, 10

; 755  :             ptr++;

	inc	rdi

; 803  : #else
; 804  :     if ( base != 0 && is_valid_id_char( *ptr ) == FALSE ) {
; 805  : #endif
; 806  :         buf->token = T_NUM;

	mov	BYTE PTR [rbx], r8b

; 807  :         buf->numbase = base;
; 808  :         buf->itemlen = dig_end - dig_start;

	sub	edx, ebp
	mov	BYTE PTR [rbx+1], r8b
	mov	DWORD PTR [rbx+16], edx

; 809  :         //DebugMsg(("get_number: inp=%s, value=%" I32_SPEC "X\n", p->input, buf->value64 ));
; 810  :     } else {

	jmp	$number_done$69
$LN27@get_number:

; 756  :         }
; 757  :         break;
; 758  :     case 'q':
; 759  :     case 'o':
; 760  :         if( OK_NUM( OCTAL ) ) {

	test	r9d, -256				; ffffff00H
	jne	$LN34@get_number

; 761  :             base = 8;
; 762  :             dig_end = ptr;

	mov	rdx, rdi

; 803  : #else
; 804  :     if ( base != 0 && is_valid_id_char( *ptr ) == FALSE ) {
; 805  : #endif
; 806  :         buf->token = T_NUM;

	mov	BYTE PTR [rbx], 10
	inc	rdi
	mov	r8d, 8

; 807  :         buf->numbase = base;
; 808  :         buf->itemlen = dig_end - dig_start;

	sub	edx, ebp
	mov	BYTE PTR [rbx+1], r8b
	mov	DWORD PTR [rbx+16], edx

; 809  :         //DebugMsg(("get_number: inp=%s, value=%" I32_SPEC "X\n", p->input, buf->value64 ));
; 810  :     } else {

	jmp	$number_done$69
$LN29@get_number:

; 763  :             ptr++;
; 764  :         }
; 765  :         break;
; 766  :     default:
; 767  :         last_char = tolower( *(ptr-1) );

	movzx	r10d, BYTE PTR [rdi-1]
	lea	rdx, QWORD PTR [rdi-1]
	lea	eax, DWORD PTR [r10-65]
	cmp	al, 25
	ja	SHORT $LN42@get_number
	or	r10b, 32				; 00000020H
$LN42@get_number:
	movzx	r8d, BYTE PTR ModuleInfo+396
	lea	eax, DWORD PTR [r10-98]
	test	al, 253					; 000000fdH
	jne	SHORT $LN32@get_number

; 768  :         if ( ( last_char == 'b' || last_char == 'd' ) && digits_seen >= ( 1UL << ModuleInfo.radix ) ) {

	movzx	ecx, r8b
	mov	eax, r11d
	shl	eax, cl
	cmp	r9d, eax
	jb	SHORT $LN32@get_number

; 769  :             char *tmp = dig_start;
; 770  :             char max = ( last_char == 'b' ? '1' : '9' );

	mov	QWORD PTR [rsp+48], r14
	cmp	r10b, 98				; 00000062H
	mov	r14d, 49				; 00000031H
	mov	ecx, 57					; 00000039H
	cmove	ecx, r14d
	mov	rax, rbp
	mov	r14, QWORD PTR [rsp+48]

; 771  :             for ( dig_end = ptr-1; tmp < dig_end && *tmp <= max; tmp++ );

	cmp	rbp, rdx
	jae	SHORT $LN65@get_number
	npad	3
$LL9@get_number:
	cmp	BYTE PTR [rax], cl
	jg	SHORT $LN65@get_number
	inc	rax
	cmp	rax, rdx
	jb	SHORT $LL9@get_number
$LN65@get_number:

; 772  :             if ( tmp == dig_end ) {

	cmp	rax, rdx
	jne	SHORT $LN32@get_number

; 773  :                 base = ( last_char == 'b' ? 2 : 10 );

	mov	r8d, 2
	cmp	r10b, 98				; 00000062H
	mov	eax, 10
	cmove	eax, r8d
	mov	r8d, eax

; 774  :                 break;

	jmp	SHORT $LN33@get_number
$LN32@get_number:

; 775  :             }
; 776  :         }
; 777  :         dig_end = ptr;
; 778  : #if COCTALS
; 779  :         if( Options.allow_c_octals && *dig_start == '0' ) {
; 780  :             if( OK_NUM( OCTAL ) ) {
; 781  :                 base = 8;
; 782  :                 break;
; 783  :             }
; 784  :         }
; 785  : #endif
; 786  :         /* radix      max. digits_seen
; 787  :          -----------------------------------------------------------
; 788  :          2            3      2^2-1  (0,1)
; 789  :          8            255    2^8-1  (0,1,2,3,4,5,6,7)
; 790  :          10           1023   2^10-1 (0,1,2,3,4,5,6,7,8,9)
; 791  :          16           65535  2^16-1 (0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f)
; 792  :          */
; 793  :         if ( digits_seen < (1UL << ModuleInfo.radix) )

	movzx	r8d, r8b
	mov	rdx, rdi
	mov	ecx, r8d
	shl	r11d, cl
	cmp	r9d, r11d
	jae	$LN34@get_number
$LN33@get_number:

; 794  :             base = ModuleInfo.radix;
; 795  :         break;
; 796  :     }
; 797  : 
; 798  : #if MASMNUMBER
; 799  :     /* Masm doesn't swallow alphanum chars which may follow the
; 800  :      * number!
; 801  :      */
; 802  :     if ( base != 0 ) {

	test	r8d, r8d
	je	$LN34@get_number

; 807  :         buf->numbase = base;
; 808  :         buf->itemlen = dig_end - dig_start;

	sub	edx, ebp
	mov	BYTE PTR [rbx], 10
	mov	DWORD PTR [rbx+16], edx
	mov	BYTE PTR [rbx+1], r8b

; 809  :         //DebugMsg(("get_number: inp=%s, value=%" I32_SPEC "X\n", p->input, buf->value64 ));
; 810  :     } else {

	jmp	$number_done$69
	npad	3
$LN63@get_number:

; 825  : }

	DD	$LN22@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN27@get_number
	DD	$LN29@get_number
	DD	$LN27@get_number
	DD	$LN21@get_number
	DD	$LN29@get_number
	DD	$LN25@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN29@get_number
	DD	$LN23@get_number
get_number ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
;	COMDAT get_special_symbol
_TEXT	SEGMENT
buf$ = 48
p$ = 56
get_special_symbol PROC					; COMDAT

; 511  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	rbx, rdx

; 512  :     char    symbol;
; 513  :     char    c;
; 514  :     int     i;
; 515  :     int  index;
; 516  : 
; 517  :     symbol = *p->input;

	mov	rcx, QWORD PTR [rdx]
	movsx	esi, BYTE PTR [rcx]

; 518  :     switch( symbol ) {

	mov	ebp, esi
	lea	eax, DWORD PTR [rsi-37]
	cmp	eax, 56					; 00000038H
	ja	$LN22@get_specia
	lea	r14, OFFSET FLAT:__ImageBase
	cdqe
	movzx	eax, BYTE PTR $LN38@get_specia[r14+rax]
	mov	edx, DWORD PTR $LN39@get_specia[r14+rax*4]
	add	rdx, r14
	jmp	rdx
$LN6@get_specia:

; 519  :     case ':' : /* T_COLON binary operator (0x3A) */
; 520  :         p->input++;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rax

; 521  :         if ( *p->input == ':' ) {

	cmp	BYTE PTR [rax], 58			; 0000003aH
	jne	SHORT $LN7@get_specia

; 522  :             p->input++;

	inc	rax
	mov	QWORD PTR [rbx], rax

; 523  :             buf->token = T_DBL_COLON;
; 524  :             buf->string_ptr = "::";

	lea	rax, OFFSET FLAT:$SG11079

; 640  :             buf->token = '&';
; 641  :             buf->string_ptr = "&";

	mov	QWORD PTR [rdi+8], rax

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	mov	BYTE PTR [rdi], 13
	jmp	$LN1@get_specia
$LN7@get_specia:

; 525  :         } else {
; 526  :             buf->token = T_COLON;
; 527  :             buf->string_ptr = ":";

	lea	rax, OFFSET FLAT:$SG11080
	mov	BYTE PTR [rdi], 58			; 0000003aH

; 640  :             buf->token = '&';
; 641  :             buf->string_ptr = "&";

	mov	QWORD PTR [rdi+8], rax

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_specia
$LN9@get_specia:

; 528  :         }
; 529  :         break;
; 530  :     case '%' : /* T_PERCENT (0x25) */
; 531  : #if PERCENT_OUT
; 532  :         /* %OUT directive? */
; 533  :         if ( ( _memicmp( p->input+1, "OUT", 3 ) == 0 ) && !is_valid_id_char( *(p->input+4) ) ) {

	inc	rcx
	lea	rdx, OFFSET FLAT:$SG11083
	mov	r8d, 3
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN10@get_specia
	mov	rax, QWORD PTR [rbx]
	movsx	ecx, BYTE PTR [rax+4]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN10@get_specia
	mov	rax, QWORD PTR [rbx]
	movzx	ecx, BYTE PTR [rax+4]
	sub	cl, 36					; 00000024H
	cmp	cl, 59					; 0000003bH
	ja	SHORT $LN36@get_specia
	mov	rax, 576460752706076673			; 0800000018000001H
	bt	rax, rcx
	jb	SHORT $LN10@get_specia
$LN36@get_specia:

; 534  :             buf->token = T_DIRECTIVE;

	mov	WORD PTR [rdi], 11779			; 00002e03H

; 535  :             buf->tokval = T_ECHO;

	mov	DWORD PTR [rdi+16], 441			; 000001b9H

; 536  :             buf->dirtype = DRT_ECHO;
; 537  :             memcpy( p->output, p->input, 4 );

	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 538  :             p->input += 4;
; 539  :             p->output += 4;

	add	QWORD PTR [rbx+8], 4
	mov	rax, QWORD PTR [rbx+8]
	add	QWORD PTR [rbx], 4

; 540  :             *(p->output)++ = NULLC;

	mov	BYTE PTR [rax], 0
	inc	QWORD PTR [rbx+8]

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_specia
$LN10@get_specia:

; 541  :             break;
; 542  :         }
; 543  : #endif
; 544  :         p->input++;

	inc	QWORD PTR [rbx]

; 545  :         if ( p->flags == TOK_DEFAULT && p->index == 0 ) {

	cmp	BYTE PTR [rbx+28], 0
	jne	SHORT $LN11@get_specia
	cmp	DWORD PTR [rbx+24], 0
	jne	SHORT $LN11@get_specia

; 546  :             p->flags3 |= TF3_EXPANSION;

	or	BYTE PTR [rbx+30], 2

; 547  :             return( EMPTY );

	mov	eax, -2
	jmp	$LN1@get_specia
$LN11@get_specia:

; 548  :         }
; 549  :         buf->token = T_PERCENT;
; 550  :         buf->string_ptr = "%";

	lea	rax, OFFSET FLAT:$SG11085
	mov	BYTE PTR [rdi], 37			; 00000025H

; 640  :             buf->token = '&';
; 641  :             buf->string_ptr = "&";

	mov	QWORD PTR [rdi+8], rax

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_specia
$LN12@get_specia:

; 551  :         break;
; 552  :     case '(' : /* 0x28: T_OP_BRACKET operator - needs a matching ')' */
; 553  :         /* v2.11: reset c-expression flag if a macro function call is detected */
; 554  :         if ( ( p->flags2 & DF_CEXPR ) && p->index && (buf-1)->token == T_ID ) {

	test	BYTE PTR [rbx+29], 1
	je	SHORT $LN14@get_specia
	cmp	DWORD PTR [rbx+24], 0
	je	SHORT $LN14@get_specia
	cmp	BYTE PTR [rdi-32], 8
	jne	SHORT $LN14@get_specia

; 555  :             struct asym *sym = SymSearch( (buf-1)->string_ptr );

	mov	rcx, QWORD PTR [rdi-24]
	call	SymFind

; 556  :             if ( sym && ( sym->state == SYM_MACRO ) && sym->isfunc )

	test	rax, rax
	je	SHORT $LN14@get_specia
	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN14@get_specia
	test	BYTE PTR [rax+44], 2
	je	SHORT $LN14@get_specia

; 557  :                 p->flags2 &= ~DF_CEXPR;

	and	BYTE PTR [rbx+29], -2
$LN14@get_specia:

; 558  :         }
; 559  :         /* no break */
; 560  :     case ')' : /* 0x29: T_CL_BRACKET */
; 561  :     case '*' : /* 0x2A: binary operator */
; 562  :     case '+' : /* 0x2B: unary|binary operator */
; 563  :     case ',' : /* 0x2C: T_COMMA */
; 564  :     case '-' : /* 0x2D: unary|binary operator */
; 565  :     case '.' : /* 0x2E: T_DOT binary operator */
; 566  :     case '/' : /* 0x2F: binary operator */
; 567  :         /* all of these are themselves a token */
; 568  :         p->input++;

	inc	QWORD PTR [rbx]

; 569  :         buf->token = symbol;
; 570  :         buf->specval = 0; /* initialize, in case the token needs extra data */
; 571  :         /* v2.06: use constants for the token string */
; 572  :         buf->string_ptr = (char *)&stokstr1[symbol - '('];

	lea	eax, DWORD PTR [rbp-40]
	movsxd	rcx, eax
	lea	rax, QWORD PTR stokstr1[r14]
	mov	BYTE PTR [rdi], sil
	mov	BYTE PTR [rdi+1], 0
	lea	rax, QWORD PTR [rax+rcx*2]

; 640  :             buf->token = '&';
; 641  :             buf->string_ptr = "&";

	mov	QWORD PTR [rdi+8], rax

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_specia
$LN16@get_specia:

; 573  :         break;
; 574  :     case '[' : /* T_OP_SQ_BRACKET operator - needs a matching ']' (0x5B) */
; 575  :     case ']' : /* T_CL_SQ_BRACKET (0x5D) */
; 576  :         p->input++;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rax

; 577  : #if AVXSUPP
; 578  :         while ( isspace( *p->input )) p->input++; 

	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN5@get_specia
	npad	12
$LL4@get_specia:
	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL4@get_specia
$LN5@get_specia:

; 579  :         c = *p->input;

	mov	rax, QWORD PTR [rbx]
	movzx	edx, BYTE PTR [rax]

; 580  : #endif
; 581  :         buf->token = symbol;
; 582  :         /* v2.06: use constants for the token string */
; 583  :         buf->string_ptr = (char *)&stokstr2[symbol - '['];

	lea	eax, DWORD PTR [rbp-91]
	movsxd	rcx, eax
	lea	rax, QWORD PTR stokstr2[r14]
	mov	BYTE PTR [rdi], sil
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	QWORD PTR [rdi+8], rax

; 584  : #if AVXSUPP
; 585  :         /* Intercept here '{' for EVEX mask or broadcast events 
; 586  :          * it could be {k1}, ]{k1}{z}, {1to2},{1to4},{1to8},{1to16}
; 587  :         */
; 588  :         if (c == '{')

	cmp	dl, 123					; 0000007bH
	jne	$LN2@get_specia

; 589  :         {
; 590  :           p->input++;

	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]

; 591  :           if ((*p->input | 0x20) == 'k' || (*p->input | 0x20) == 'z')

	movzx	ecx, BYTE PTR [rax]
	or	cl, 32					; 00000020H
	cmp	cl, 107					; 0000006bH
	je	SHORT $LN20@get_specia
	cmp	cl, 122					; 0000007aH
	je	SHORT $LN20@get_specia

; 593  :           else
; 594  :             get_broads( p ) ;   // broadcast decorators

	mov	rcx, rbx
	call	get_broads

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_specia
$LN20@get_specia:

; 592  :             get_decos( p ) ;    // mask decorators

	mov	rcx, rbx
	call	get_decos

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_specia
$LN21@get_specia:

; 595  :         }
; 596  : #endif
; 597  :         break;
; 598  :     case '=' : /* (0x3D) */
; 599  :         if ( *(p->input+1) != '=' ) {

	cmp	BYTE PTR [rcx+1], 61			; 0000003dH
	je	SHORT $LN22@get_specia

; 600  :             buf->token = T_DIRECTIVE;
; 601  :             buf->tokval = T_EQU;
; 602  :             buf->dirtype = DRT_EQUALSGN; /* to make it differ from EQU directive */
; 603  :             buf->string_ptr = "=";

	lea	rax, OFFSET FLAT:$SG11097
	mov	WORD PTR [rdi], 12291			; 00003003H
	mov	QWORD PTR [rdi+8], rax
	mov	DWORD PTR [rdi+16], 443			; 000001bbH

; 604  :             p->input++;

	inc	QWORD PTR [rbx]

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@get_specia
$LN22@get_specia:

; 605  :             break;
; 606  :         }
; 607  :         /* fall through */
; 608  :     default:
; 609  :         /* detect C style operators.
; 610  :          * DF_CEXPR is set if .IF, .WHILE, .ELSEIF or .UNTIL
; 611  :          * has been detected in the current line.
; 612  :          * will catch: '!', '<', '>', '&', '==', '!=', '<=', '>=', '&&', '||'
; 613  :          * A single '|' will also be caught, although it isn't a valid
; 614  :          * operator - it will cause a 'operator expected' error msg later.
; 615  :          * the tokens are stored as one- or two-byte sized "strings".
; 616  :          */
; 617  :       if ( ( p->flags2 & DF_CEXPR ) && strchr( "=!<>&|¦", symbol ) ) {     //habran added '¦'

	test	BYTE PTR [rbx+29], 1
	je	SHORT $LN24@get_specia
	mov	edx, ebp
	lea	rcx, OFFSET FLAT:$SG11100
	call	strchr
	test	rax, rax
	je	SHORT $LN24@get_specia

; 618  :             *(p->output)++ = symbol;

	mov	rax, QWORD PTR [rbx+8]
	mov	BYTE PTR [rax], sil
	inc	QWORD PTR [rbx+8]

; 619  :             p->input++;

	inc	QWORD PTR [rbx]

; 620  :             buf->stringlen = 1;

	mov	DWORD PTR [rdi+16], 1

; 621  :             if ( symbol == '&' || symbol == '|' ) {

	cmp	sil, 38					; 00000026H
	je	SHORT $LN27@get_specia
	cmp	sil, 124				; 0000007cH
	je	SHORT $LN27@get_specia

; 626  :                 }
; 627  :             } else if ( *p->input == '=' ) {

	mov	rax, QWORD PTR [rbx]
	cmp	BYTE PTR [rax], 61			; 0000003dH
	jne	SHORT $LN28@get_specia

; 628  :                 *(p->output)++ = '=';

	mov	rax, QWORD PTR [rbx+8]
	mov	BYTE PTR [rax], 61			; 0000003dH

; 629  :                 p->input++;
; 630  :                 buf->stringlen = 2;

	jmp	SHORT $LN41@get_specia
$LN27@get_specia:

; 622  :                 if ( *p->input == symbol ) {

	mov	rax, QWORD PTR [rbx]
	cmp	BYTE PTR [rax], sil
	jne	SHORT $LN28@get_specia

; 623  :                     *(p->output)++ = symbol;

	mov	rax, QWORD PTR [rbx+8]
	mov	BYTE PTR [rax], sil
$LN41@get_specia:
	inc	QWORD PTR [rbx+8]

; 624  :                     p->input++;

	inc	QWORD PTR [rbx]

; 625  :                     buf->stringlen = 2;

	mov	DWORD PTR [rdi+16], 2
$LN28@get_specia:

; 631  :             }
; 632  :             buf->token = T_STRING;

	mov	WORD PTR [rdi], 9

; 633  :             buf->string_delim = NULLC;
; 634  :             *(p->output)++ = NULLC;

	mov	rax, QWORD PTR [rbx+8]
	mov	BYTE PTR [rax], 0
	inc	QWORD PTR [rbx+8]

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@get_specia
$LN24@get_specia:

; 635  :             break;
; 636  :         }
; 637  :         /* v2.08: ampersand is a special token */
; 638  :         if ( symbol == '&' ) {

	cmp	sil, 38					; 00000026H
	jne	SHORT $LN30@get_specia

; 639  :             p->input++;

	inc	QWORD PTR [rbx]

; 640  :             buf->token = '&';
; 641  :             buf->string_ptr = "&";

	lea	rax, OFFSET FLAT:$SG11107
	mov	QWORD PTR [rdi+8], rax
	mov	BYTE PTR [rdi], sil
$LN2@get_specia:

; 648  :     }
; 649  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@get_specia
$LN30@get_specia:

; 642  :             break;
; 643  :         }
; 644  :         /* anything we don't recognise we will consider a string,
; 645  :          * delimited by space characters, commas, newlines or nulls
; 646  :          */
; 647  :         return( get_string( buf, p ) );

	mov	rdx, rbx
	mov	rcx, rdi
	call	get_string
$LN1@get_specia:

; 650  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
	npad	3
$LN39@get_specia:
	DD	$LN9@get_specia
	DD	$LN12@get_specia
	DD	$LN14@get_specia
	DD	$LN6@get_specia
	DD	$LN21@get_specia
	DD	$LN16@get_specia
	DD	$LN22@get_specia
$LN38@get_specia:
	DB	0
	DB	6
	DB	6
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	6
	DB	5
get_special_symbol ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
;	COMDAT get_string
_TEXT	SEGMENT
buf$ = 80
p$ = 88
get_string PROC						; COMDAT

; 316  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 317  :     char    symbol_o;
; 318  :     char    symbol_c;
; 319  :     char    c;
; 320  :     char    *src = p->input;

	mov	rbx, QWORD PTR [rdx]

; 321  :     char    *dst = p->output;
; 322  :     int     count = 0;

	xor	ebp, ebp
	mov	rsi, QWORD PTR [rdx+8]
	mov	r14, rdx

; 323  :     int     level;
; 324  : 
; 325  :     symbol_o = *src;

	movzx	r15d, BYTE PTR [rbx]

; 326  : 
; 327  :     switch( symbol_o ) {

	cmp	r15b, 34				; 00000022H
	je	$LN19@get_string
	cmp	r15b, 39				; 00000027H
	je	$LN19@get_string
	cmp	r15b, 60				; 0000003cH
	je	SHORT $LN26@get_string
	cmp	r15b, 123				; 0000007bH
	jne	$undelimited_string$107

; 349  :             }
; 350  :         }
; 351  :         break;  /* end of string marker is the same */
; 352  :     case '{':
; 353  :         if ( p->flags & TOK_NOCURLBRACES )

	test	BYTE PTR [rdx+28], 2
	jne	$undelimited_string$107
$LN26@get_string:

; 354  :             goto undelimited_string;
; 355  :     case '<':
; 356  :         buf->string_delim = symbol_o;
; 357  :         symbol_c = ( symbol_o == '<' ? '>' : '}' );

	cmp	r15b, 60				; 0000003cH
	mov	BYTE PTR [rcx+1], r15b
	mov	eax, 62					; 0000003eH
	mov	r13d, 125				; 0000007dH
	cmove	r13d, eax

; 358  :         src++;
; 359  :         for( level = 0; count < MAX_STRING_LEN; ) {

	mov	r12d, ebp
	inc	rbx
	npad	4
$LL7@get_string:

; 360  :             c = *src;

	movzx	edi, BYTE PTR [rbx]

; 361  :             if( c == symbol_o ) { /* < or { ? */

	cmp	dil, r15b
	jne	SHORT $LN28@get_string

; 362  :                 level++;
; 363  :                 *dst++ = c; src++;

	mov	BYTE PTR [rsi], dil
	inc	r12d
	inc	rsi
	inc	rbx

; 364  :                 count++;

	inc	ebp
	jmp	$LN75@get_string
$LN28@get_string:

; 365  :             } else if( c == symbol_c ) { /* > or }? */

	cmp	dil, r13b
	jne	SHORT $LN30@get_string

; 366  :                 if( level ) {
; 367  :                     level--;
; 368  :                     *dst++ = c; src++;

	inc	rbx
	test	r12d, r12d
	je	$LN103@get_string
	mov	BYTE PTR [rsi], dil
	dec	r12d
	inc	rsi

; 369  :                     count++;

	inc	ebp

; 370  :                 } else {
; 371  :                     /* store the string delimiter unless it is <> */
; 372  :                     /* v2.08: don't store delimiters for {}-literals */
; 373  :                     //if (symbol_o != '<')
; 374  :                     //    *dst++ = c;
; 375  :                     src++;
; 376  :                     break; /* exit loop */
; 377  :                 }

	jmp	$LN75@get_string
$LN30@get_string:

; 378  : #if 1
; 379  :             /*
; 380  :              a " or ' inside a <>/{} string? Since it's not a must that
; 381  :              [double-]quotes are paired in a literal it must be done
; 382  :              directive-dependant!
; 383  :              see: IFIDN <">,<">
; 384  :              */
; 385  :             } else if( ( c == '"' || c == '\'' ) && ( p->flags2 & DF_STRPARM ) == 0 ) {

	cmp	dil, 34					; 00000022H
	je	SHORT $LN36@get_string
	cmp	dil, 39					; 00000027H
	jne	$LN34@get_string
$LN36@get_string:
	test	BYTE PTR [r14+29], 2
	jne	SHORT $LN34@get_string

; 386  :                 char delim = c;
; 387  :                 char *tdst;
; 388  :                 char *tsrc;
; 389  :                 int tcount;
; 390  :                 *dst++ = c; src++;

	inc	rbx
	mov	BYTE PTR [rsi], dil
	inc	rsi

; 391  :                 count++;

	inc	ebp

; 392  :                 tdst = dst;

	mov	rcx, rsi

; 393  :                 tsrc = src;

	mov	rdx, rbx

; 394  :                 tcount = count;

	mov	r8d, ebp

; 395  :                 while (*src != delim && *src != NULLC && count < MAX_STRING_LEN-1 ) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, dil
	je	SHORT $LN93@get_string
	npad	1
$LL10@get_string:
	test	al, al
	je	SHORT $LN11@get_string
	cmp	ebp, 567				; 00000237H
	jge	SHORT $LN11@get_string

; 396  :                     if ( symbol_o == '<' && *src == '!' && *(src+1) != NULLC )

	cmp	r15b, 60				; 0000003cH
	jne	SHORT $LN37@get_string
	cmp	al, 33					; 00000021H
	jne	SHORT $LN37@get_string
	cmp	BYTE PTR [rbx+1], 0
	lea	rax, QWORD PTR [rbx+1]
	cmovne	rbx, rax
$LN37@get_string:

; 397  :                         src++;
; 398  :                     *dst++ = *src++;

	movzx	eax, BYTE PTR [rbx]

; 399  :                     count++;

	inc	ebp
	inc	rbx
	mov	BYTE PTR [rsi], al
	inc	rsi
	movzx	eax, BYTE PTR [rbx]
	cmp	al, dil
	jne	SHORT $LL10@get_string
$LN93@get_string:

; 402  :                     *dst++ = *src++;

	movzx	eax, BYTE PTR [rbx]
	inc	rbx
	mov	BYTE PTR [rsi], al
	inc	rsi

; 403  :                     count++;

	inc	ebp

; 404  :                     continue;

	jmp	$LN75@get_string
$LN11@get_string:

; 400  :                 }
; 401  :                 if ( *src == delim ) {

	cmp	BYTE PTR [rbx], dil
	je	SHORT $LN93@get_string

; 405  :                 } else {
; 406  :                     /* restore values */
; 407  :                     src = tsrc;

	mov	rbx, rdx

; 408  :                     dst = tdst;

	mov	rsi, rcx

; 409  :                     count = tcount;

	mov	ebp, r8d

; 410  :                 }

	jmp	$LN75@get_string
$LN34@get_string:

; 411  : #endif
; 412  :             } else if( c == '!' && symbol_o == '<' && *(src+1) ) {

	cmp	dil, 33					; 00000021H
	jne	SHORT $LN40@get_string
	cmp	r15b, 60				; 0000003cH
	jne	SHORT $LN44@get_string
	cmp	BYTE PTR [rbx+1], 0
	lea	rax, QWORD PTR [rbx+1]
	je	SHORT $LN44@get_string

; 413  :                 /* handle literal-character operator '!'.
; 414  :                  * it makes the next char to enter the literal uninterpreted.
; 415  :                  */
; 416  :                 /* v2.09: don't store the '!' */
; 417  :                 //*dst++ = c; src++;
; 418  :                 //count++;
; 419  :                 //if ( count == MAX_STRING_LEN )
; 420  :                 //    break;
; 421  :                 src++;
; 422  :                 *dst++ = *src++;

	lea	rbx, QWORD PTR [rax+1]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rsi], al
	inc	rsi

; 423  :                 count++;

	inc	ebp
	jmp	$LN75@get_string
$LN40@get_string:

; 424  :             } else if( c == '\\' &&  ConcatLine( src, count, dst, p ) != EMPTY ) {

	cmp	dil, 92					; 0000005cH
	jne	SHORT $LN42@get_string
	mov	r9, r14
	mov	r8, rsi
	mov	edx, ebp
	mov	rcx, rbx
	call	ConcatLine
	cmp	eax, -2
	je	SHORT $LN44@get_string

; 425  :                 p->flags3 |= TF3_ISCONCAT;

	or	BYTE PTR [r14+30], 1
	jmp	$LN75@get_string
$LN42@get_string:

; 426  :             } else if( c == NULLC || ( c == ';' && symbol_o == '{' )) {

	test	dil, dil
	je	SHORT $LN46@get_string
	cmp	dil, 59					; 0000003bH
	jne	SHORT $LN44@get_string
	cmp	r15b, 123				; 0000007bH
	je	SHORT $LN46@get_string
$LN44@get_string:

; 453  :                 goto undelimited_string;
; 454  :             } else {
; 455  :                 *dst++ = c; src++;

	mov	BYTE PTR [rsi], dil
	inc	rbx
	inc	rsi

; 456  :                 count++;

	inc	ebp

; 457  :             }
; 458  :         }

	jmp	$LN75@get_string
$LN46@get_string:

; 427  :                 if ( p->flags == TOK_DEFAULT && (( p->flags2 & DF_NOCONCAT ) == 0 ) ) { /* <{ */

	cmp	BYTE PTR [r14+28], 0
	jne	$LN49@get_string
	test	BYTE PTR [r14+29], 32			; 00000020H
	jne	$LN49@get_string

; 428  :                     /* if last nonspace character was a comma
; 429  :                      * get next line and continue string scan
; 430  :                      */
; 431  :                     char *tmp = dst-1;
; 432  :                     while ( isspace(*tmp) ) tmp--;

	movsx	ecx, BYTE PTR [rsi-1]
	lea	rdi, QWORD PTR [rsi-1]
	call	isspace
	test	eax, eax
	je	SHORT $LN13@get_string
$LL12@get_string:
	movsx	ecx, BYTE PTR [rdi-1]
	dec	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL12@get_string
$LN13@get_string:

; 433  :                     if ( *tmp == ',' ) {

	cmp	BYTE PTR [rdi], 44			; 0000002cH
	jne	$LN49@get_string

; 434  :                         DebugMsg1(("Tokenize.get_string: comma concatenation: %s\n", src ));
; 435  :                         tmp = GetAlignedPointer( p->output, strlen( p->output ) );

	mov	rax, QWORD PTR [r14+8]
	or	rdi, -1
$LL99@get_string:
	inc	rdi
	cmp	BYTE PTR [rax+rdi], 0
	jne	SHORT $LL99@get_string
	add	rdi, 8
	and	rdi, -8
	add	rdi, rax

; 436  :                         if( GetTextLine( tmp ) ) {

	mov	rcx, rdi
	call	GetTextLine
	test	rax, rax
	je	$LN49@get_string

; 437  :                             /* skip leading spaces */
; 438  :                             while ( isspace( *tmp ) ) tmp++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN15@get_string
$LL14@get_string:
	movsx	ecx, BYTE PTR [rdi+1]
	inc	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL14@get_string
$LN15@get_string:

; 439  :                             /* this size check isn't fool-proved yet */
; 440  :                             if ( strlen( tmp ) + count >= MAX_LINE_LEN ) {

	or	rcx, -1
	npad	8
$LL98@get_string:
	inc	rcx
	cmp	BYTE PTR [rdi+rcx], 0
	jne	SHORT $LL98@get_string
	movsxd	rax, ebp
	add	rcx, rax
	cmp	rcx, 600				; 00000258H
	jae	SHORT $LN68@get_string

; 443  :                             }
; 444  :                             strcpy( src, tmp );

	mov	rcx, rbx
	sub	rcx, rdi
	npad	2
$LL60@get_string:
	movzx	eax, BYTE PTR [rdi]
	mov	BYTE PTR [rcx+rdi], al
	inc	rdi
	test	al, al
	jne	SHORT $LL60@get_string
$LN75@get_string:

; 358  :         src++;
; 359  :         for( level = 0; count < MAX_STRING_LEN; ) {

	cmp	ebp, 568				; 00000238H
	jl	$LL7@get_string
$LN103@get_string:
	mov	rcx, QWORD PTR buf$[rsp]
$LN5@get_string:

; 493  :         }
; 494  :         break;
; 495  :     }
; 496  : 
; 497  :     if ( count == MAX_STRING_LEN ) {

	cmp	ebp, 568				; 00000238H
$LN104@get_string:
	jne	$LN58@get_string

; 498  :         EmitError( STRING_OR_TEXT_LITERAL_TOO_LONG );

	mov	ecx, 156				; 0000009cH
	call	EmitError

; 499  :         return( ERROR );

	or	eax, -1
	jmp	$LN1@get_string
$LN68@get_string:

; 441  :                                 EmitError( LINE_TOO_LONG );

	mov	ecx, 62					; 0000003eH
	call	EmitError

; 442  :                                 return( ERROR );

	or	eax, -1
	jmp	$LN1@get_string
$LN49@get_string:

; 445  :                             continue;
; 446  :                         }
; 447  :                     }
; 448  :                 }
; 449  :                 src = p->input;

	mov	rbx, QWORD PTR [r14]

; 450  :                 dst = p->output;
; 451  :                 *dst++ = *src++;
; 452  :                 count = 1;

	mov	ebp, 1
	mov	rsi, QWORD PTR [r14+8]
	mov	rcx, QWORD PTR buf$[rsp]
	movzx	eax, BYTE PTR [rbx]
	mov	BYTE PTR [rsi], al
	inc	rsi
	inc	rbx
$undelimited_string$107:

; 459  :         break;
; 460  :     default:
; 461  :         undelimited_string:
; 462  :         buf->string_delim = NULLC;

	mov	BYTE PTR [rcx+1], 0

; 463  :         /* this is an undelimited string,
; 464  :          * so just copy it until we hit something that looks like the end.
; 465  :          * this format is used by the INCLUDE directive, but may also
; 466  :          * occur inside the string macros!
; 467  :          */
; 468  :         /* v2.05: also stop if a ')' is found - see literal2.asm regression test */
; 469  :         //for( count = 0 ; count < MAX_STRING_LEN && *src != NULLC && !isspace( *src ) && *src != ',' && *src != ';'; ) {
; 470  :         for( ; count < MAX_STRING_LEN &&
; 471  :             /* v2.08: stop also at < and % */
; 472  :             //*src != NULLC && !isspace( *src ) && *src != ',' && *src != ';' && *src != ')'; ) {
; 473  :             //*src && !isspace( *src ) && *src != ',' && *src != ')' && *src != '<' && *src != '%'; ) {
; 474  :             *src && !isspace( *src ) && *src != ',' && *src != ')' && *src != '%'; ) {

	cmp	ebp, 568				; 00000238H
	jge	SHORT $LN104@get_string
	mov	rdi, 19928648253440			; 0000122000000000H
$LL16@get_string:
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN103@get_string
	movsx	ecx, al
	call	isspace
	test	eax, eax
	jne	SHORT $LN103@get_string
	movzx	ecx, BYTE PTR [rbx]
	cmp	cl, 44					; 0000002cH
	ja	SHORT $LN94@get_string
	movsx	rax, cl
	bt	rdi, rax
	jb	$LN103@get_string
$LN94@get_string:

; 475  :             if ( *src == ';' && p->flags == TOK_DEFAULT )

	cmp	cl, 59					; 0000003bH
	jne	SHORT $LN52@get_string
	cmp	BYTE PTR [r14+28], 0
	je	$LN103@get_string
$LN52@get_string:

; 476  :                 break;
; 477  :             /* v2.11: handle '\' also for expanded lines */
; 478  :             //if (  *src == '\\' && !( p->flags & TOK_NOCURLBRACES ) ) {
; 479  :             if (  *src == '\\' && ( p->flags == TOK_DEFAULT || ( p->flags & TOK_LINE ) ) ) {

	cmp	cl, 92					; 0000005cH
	jne	SHORT $LN55@get_string
	movzx	eax, BYTE PTR [r14+28]
	test	al, al
	je	SHORT $LN54@get_string
	test	al, 4
	je	SHORT $LN55@get_string
$LN54@get_string:

; 480  :                 if ( ConcatLine( src, count, dst, p ) != EMPTY ) {

	mov	r9, r14
	mov	r8, rsi
	mov	edx, ebp
	mov	rcx, rbx
	call	ConcatLine
	cmp	eax, -2
	je	SHORT $LN55@get_string

; 481  :                     DebugMsg1(("Tokenize.get_string: backslash concatenation: >%s<\n", src ));
; 482  :                     p->flags3 |= TF3_ISCONCAT;

	or	BYTE PTR [r14+30], 1

; 483  :                     if ( count )

	test	ebp, ebp
	jne	SHORT $LN76@get_string

; 484  :                         continue;
; 485  :                     return( EMPTY );

	lea	eax, QWORD PTR [rbp-2]
	jmp	$LN1@get_string
$LN55@get_string:

; 486  :                 }
; 487  :             }
; 488  :             /* v2.08: handle '!' operator */
; 489  :             if ( *src == '!' && *(src+1) && count < MAX_STRING_LEN - 1 )

	cmp	BYTE PTR [rbx], 33			; 00000021H
	jne	SHORT $LN57@get_string
	cmp	BYTE PTR [rbx+1], 0
	lea	rax, QWORD PTR [rbx+1]
	je	SHORT $LN57@get_string
	cmp	ebp, 567				; 00000237H
	jge	SHORT $LN57@get_string

; 490  :                 *dst++ = *src++;

	mov	BYTE PTR [rsi], 33			; 00000021H
	mov	rbx, rax
	inc	rsi
$LN57@get_string:

; 491  :             *dst++ = *src++;

	movzx	eax, BYTE PTR [rbx]
	inc	rbx
	mov	BYTE PTR [rsi], al
	inc	rsi

; 492  :             count++;

	inc	ebp
$LN76@get_string:

; 463  :         /* this is an undelimited string,
; 464  :          * so just copy it until we hit something that looks like the end.
; 465  :          * this format is used by the INCLUDE directive, but may also
; 466  :          * occur inside the string macros!
; 467  :          */
; 468  :         /* v2.05: also stop if a ')' is found - see literal2.asm regression test */
; 469  :         //for( count = 0 ; count < MAX_STRING_LEN && *src != NULLC && !isspace( *src ) && *src != ',' && *src != ';'; ) {
; 470  :         for( ; count < MAX_STRING_LEN &&
; 471  :             /* v2.08: stop also at < and % */
; 472  :             //*src != NULLC && !isspace( *src ) && *src != ',' && *src != ';' && *src != ')'; ) {
; 473  :             //*src && !isspace( *src ) && *src != ',' && *src != ')' && *src != '<' && *src != '%'; ) {
; 474  :             *src && !isspace( *src ) && *src != ',' && *src != ')' && *src != '%'; ) {

	cmp	ebp, 568				; 00000238H
	jl	$LL16@get_string
	jmp	$LN103@get_string
$LN19@get_string:

; 328  :     case '"':
; 329  :     case '\'':
; 330  :         buf->string_delim = symbol_o;

	mov	BYTE PTR [rcx+1], r15b

; 331  :         *dst++ = symbol_o;

	mov	BYTE PTR [rsi], r15b
	inc	rsi

; 332  :         src++;

	inc	rbx
	npad	4
$LL6@get_string:

; 334  :             c = *src;

	movzx	eax, BYTE PTR [rbx]

; 335  :             if( c == symbol_o ) { /* another quote? */

	cmp	al, r15b
	jne	SHORT $LN20@get_string

; 336  :                 *dst++ = c; /* store it */

	mov	BYTE PTR [rsi], al

; 337  :                 src++;

	inc	rbx
	inc	rsi

; 338  :                 if( *src != c )

	cmp	BYTE PTR [rbx], al
	jne	$LN5@get_string

; 339  :                     break; /* exit loop */
; 340  :                 /* a pair of quotes inside the string is
; 341  :                  * handled as a single quote */
; 342  :             } else if( c == NULLC ) {

	jmp	SHORT $LN4@get_string
$LN20@get_string:
	test	al, al
	je	SHORT $LN71@get_string

; 346  :                 break;
; 347  :             } else {
; 348  :                 *dst++ = c;

	mov	BYTE PTR [rsi], al
	inc	rsi
$LN4@get_string:

; 333  :         for ( ; count < MAX_STRING_LEN; src++, count++ ) {

	inc	rbx
	inc	ebp
	cmp	ebp, 568				; 00000238H
	jl	SHORT $LL6@get_string

; 339  :                     break; /* exit loop */
; 340  :                 /* a pair of quotes inside the string is
; 341  :                  * handled as a single quote */
; 342  :             } else if( c == NULLC ) {

	jmp	$LN5@get_string
$LN71@get_string:

; 343  :                 /* missing terminating quote, change to undelimited string */
; 344  :                 buf->string_delim = NULLC;

	mov	BYTE PTR [rcx+1], 0

; 345  :                 count++; /* count the first quote */

	inc	ebp
	jmp	$LN5@get_string
$LN58@get_string:

; 500  :     }
; 501  :     *dst++ = NULLC;

	mov	BYTE PTR [rsi], 0
	lea	rax, QWORD PTR [rsi+1]

; 502  :     buf->token = T_STRING;

	mov	BYTE PTR [rcx], 9

; 503  :     buf->stringlen = count;

	mov	DWORD PTR [rcx+16], ebp

; 504  :     p->input = src;
; 505  :     p->output = dst;

	mov	QWORD PTR [r14+8], rax

; 506  :     return( NOT_ERROR );

	xor	eax, eax
	mov	QWORD PTR [r14], rbx
$LN1@get_string:

; 507  : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
get_string ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
;	COMDAT ConcatLine
_TEXT	SEGMENT
src$ = 64
cnt$ = 72
out$ = 80
ls$ = 88
ConcatLine PROC						; COMDAT

; 287  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx

; 288  :     char *p = src+1;

	lea	rdi, QWORD PTR [rcx+1]

; 289  :     int max;
; 290  : 
; 291  :     while ( isspace(*p) ) p++;

	movsx	ecx, BYTE PTR [rcx+1]
	mov	rbp, r9
	mov	rbx, r8
	mov	r15d, edx
	call	isspace
	test	eax, eax
	je	SHORT $LN3@ConcatLine
	npad	11
$LL2@ConcatLine:
	movsx	ecx, BYTE PTR [rdi+1]
	inc	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL2@ConcatLine
$LN3@ConcatLine:

; 292  :     if ( *p == NULLC || *p == ';' ) {

	movzx	eax, BYTE PTR [rdi]
	test	al, al
	je	SHORT $LN7@ConcatLine
	cmp	al, 59					; 0000003bH
	jne	$LN8@ConcatLine
$LN7@ConcatLine:

; 293  :         //char *buffer = GetAlignedPointer( out, strlen( out ) );
; 294  :         char *buffer = out;
; 295  :         if( GetTextLine( buffer ) ) {

	mov	rcx, rbx
	call	GetTextLine
	test	rax, rax
	je	SHORT $LN8@ConcatLine

; 296  :             p = buffer;
; 297  :             /* skip leading spaces */
; 298  :             while ( isspace( *p ) ) p++;

	movsx	ecx, BYTE PTR [rbx]
	call	isspace
	test	eax, eax
	je	SHORT $LN5@ConcatLine
	npad	8
$LL4@ConcatLine:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL4@ConcatLine
$LN5@ConcatLine:

; 299  :             max = strlen( p );

	or	rcx, -1
$LL20@ConcatLine:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL20@ConcatLine

; 300  :             if ( cnt == 0 )

	test	r15d, r15d
	jne	SHORT $LN9@ConcatLine

; 301  :                 *src++ = ' ';

	mov	BYTE PTR [rsi], 32			; 00000020H
	inc	rsi
$LN9@ConcatLine:

; 302  :             if ( ( src - ls->start ) + max >= MAX_LINE_LEN ) {

	movsxd	rax, ecx
	sub	rax, QWORD PTR [rbp+16]
	add	rax, rsi
	cmp	rax, 600				; 00000258H
	jl	SHORT $LN10@ConcatLine

; 303  :                 EmitError( LINE_TOO_LONG );

	mov	ecx, 62					; 0000003eH
	call	EmitError

; 304  :                 max = MAX_LINE_LEN - ( src - ls->start + 1 );

	mov	eax, DWORD PTR [rbp+16]
	sub	eax, esi
	add	eax, 599				; 00000257H
	movsxd	rcx, eax

; 305  :                 *(p+max) = NULLC;

	mov	BYTE PTR [rcx+rbx], 0
$LN10@ConcatLine:

; 306  :             }
; 307  :             memcpy( src, p, max+1 );

	lea	eax, DWORD PTR [rcx+1]
	mov	rdx, rbx
	movsxd	r8, eax
	mov	rcx, rsi
	call	memcpy

; 308  :             return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN1@ConcatLine
$LN8@ConcatLine:

; 309  :         }
; 310  :     }
; 311  :     return( EMPTY );

	mov	eax, -2
$LN1@ConcatLine:

; 312  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
ConcatLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
;	COMDAT get_float
_TEXT	SEGMENT
buf$ = 64
p$ = 72
get_float PROC						; COMDAT

; 245  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 246  :     /* valid floats look like:  (int)[.(int)][e(int)]
; 247  :      * Masm also allows hex format, terminated by 'r' (3F800000r)
; 248  :      */
; 249  : 
; 250  :     char    got_decimal = FALSE;
; 251  :     char    got_e = FALSE;
; 252  :     char    *ptr = p->input;

	mov	rdi, QWORD PTR [rdx]
	xor	bpl, bpl
	xor	r14b, r14b
	mov	r15, rdx
	mov	r12, rcx

; 253  : 
; 254  :     for( ; *ptr != NULLC; ptr++ ) {

	movzx	ebx, BYTE PTR [rdi]
	test	bl, bl
	je	SHORT $LN21@get_float
	mov	QWORD PTR [rsp+64], rsi
$LL4@get_float:

; 255  :         char c = *ptr;
; 256  :         if( isdigit( c ) ) {

	movsx	esi, bl
	mov	ecx, esi
	call	isdigit
	test	eax, eax
	jne	SHORT $LN2@get_float

; 257  :             ;
; 258  :         } else if ( c == '.' && got_decimal == FALSE ) {

	cmp	bl, 46					; 0000002eH
	jne	SHORT $LN7@get_float
	test	bpl, bpl
	jne	SHORT $LN14@get_float

; 259  :             got_decimal = TRUE;

	mov	bpl, 1
	jmp	SHORT $LN2@get_float
$LN7@get_float:

; 260  :         } else if ( tolower( c ) == 'e' && got_e == FALSE ) {

	sub	bl, 65					; 00000041H
	cmp	bl, 25
	ja	SHORT $LN14@get_float
	or	esi, 32					; 00000020H
$LN14@get_float:
	cmp	esi, 101				; 00000065H
	jne	SHORT $LN22@get_float
	test	r14b, r14b
	jne	SHORT $LN22@get_float

; 253  : 
; 254  :     for( ; *ptr != NULLC; ptr++ ) {

	movzx	eax, BYTE PTR [rdi+1]
	lea	rcx, QWORD PTR [rdi+1]
	sub	al, 43					; 0000002bH

; 261  :             got_e = TRUE;

	mov	r14b, 1
	and	al, 253					; 000000fdH
	cmove	rdi, rcx
$LN2@get_float:

; 253  : 
; 254  :     for( ; *ptr != NULLC; ptr++ ) {

	movzx	ebx, BYTE PTR [rdi+1]
	inc	rdi
	test	bl, bl
	jne	SHORT $LL4@get_float
$LN22@get_float:
	mov	rsi, QWORD PTR [rsp+64]
$LN21@get_float:

; 262  :             /* accept e+2 / e-4 /etc. */
; 263  :             if ( *(ptr+1) == '+' || *(ptr+1) == '-' )
; 264  :                 ptr++;
; 265  :             /* it's accepted if there's no digit behind 'e' */
; 266  :             //if ( !isdigit( *(ptr+1) ) )
; 267  :             //    break;
; 268  :         } else
; 269  :             break;
; 270  :     }
; 271  : 
; 272  :     buf->token = T_FLOAT;

	mov	WORD PTR [r12], 11

; 273  :     buf->floattype = NULLC;
; 274  :     memcpy( p->output, p->input, ptr - p->input );

	mov	r8, rdi
	mov	rdx, QWORD PTR [r15]
	mov	rcx, QWORD PTR [r15+8]
	sub	r8, rdx
	call	memcpy

; 275  :     p->output += ( ptr - p->input );
; 276  :     *p->output++ = NULLC;
; 277  :     p->input = ptr;
; 278  : 
; 279  :     /* the binary value isn't used currently */
; 280  :     //*((float *)(&buf->value)) = atof( buf->string_ptr );
; 281  : 
; 282  :     return( NOT_ERROR );
; 283  : }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rax, rdi
	sub	rax, QWORD PTR [r15]
	add	QWORD PTR [r15+8], rax
	mov	rax, QWORD PTR [r15+8]
	mov	rbp, QWORD PTR [rsp+80]
	mov	BYTE PTR [rax], 0
	inc	QWORD PTR [r15+8]
	mov	QWORD PTR [r15], rdi
	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
get_float ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
p$ = 48
get_decos PROC

; 155  : void get_decos(struct line_status *p) {

$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H

; 156  : 			/************************************************/
; 157  : 			unsigned char c;
; 158  : 			if (!evex)

	cmp	BYTE PTR evex, 0
	mov	rbx, rcx
	jne	SHORT $LN6@get_decos

; 159  : 				EmitError(UNAUTHORISED_USE_OF_EVEX_ENCODING);

	mov	ecx, 23
	call	EmitError
$LN6@get_decos:

; 160  : 			c = (*p->input | 0x20);

	mov	rax, QWORD PTR [rbx]
	movzx	ecx, BYTE PTR [rax]
	or	cl, 32					; 00000020H

; 161  : 			p->input++;

	inc	rax
	mov	QWORD PTR [rbx], rax

; 162  : 			/* if first decorator is the z  */
; 163  : 			if (c == 'z'){

	cmp	cl, 122					; 0000007aH
	jne	$LN7@get_decos

; 164  :             decoflags |= 0x80; 

	or	BYTE PTR decoflags, 128			; 00000080H

; 165  :             p->input++;

	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]

; 166  :             c = *p->input;
; 167  :             if (c != '}'){

	cmp	BYTE PTR [rax], 125			; 0000007dH
	je	SHORT $LN9@get_decos
$LN36@get_decos:

; 168  :               EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15

; 239  :           return;
; 240  :         }
; 241  :       }

	add	rsp, 32					; 00000020H
	pop	rbx

; 226  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);
; 227  :                 return;
; 228  :               }
; 229  :               p->input++;
; 230  :             }
; 231  :             else {
; 232  :               EmitError(TO_MANY_DECORATORS);
; 233  :               return;
; 234  :             }
; 235  :           }
; 236  :         }
; 237  :         else {
; 238  :           EmitError(TO_MANY_DECORATORS);

	jmp	EmitError
$LN9@get_decos:

; 169  :               return;
; 170  :             }
; 171  :             p->input++;

	inc	rax
	mov	QWORD PTR [rbx], rax

; 172  :             while ( isspace( *p->input )) p->input++;

	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN3@get_decos
	npad	9
$LL2@get_decos:
	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL2@get_decos
$LN3@get_decos:

; 173  :             c = *p->input;

	mov	rcx, QWORD PTR [rbx]

; 174  :             if (c != '{'){

	cmp	BYTE PTR [rcx], 123			; 0000007bH
	je	SHORT $LN10@get_decos

; 175  :               EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14

; 239  :           return;
; 240  :         }
; 241  :       }

	add	rsp, 32					; 00000020H
	pop	rbx

; 226  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);
; 227  :                 return;
; 228  :               }
; 229  :               p->input++;
; 230  :             }
; 231  :             else {
; 232  :               EmitError(TO_MANY_DECORATORS);
; 233  :               return;
; 234  :             }
; 235  :           }
; 236  :         }
; 237  :         else {
; 238  :           EmitError(TO_MANY_DECORATORS);

	jmp	EmitError
$LN10@get_decos:

; 176  :               return;
; 177  :             }
; 178  :             p->input++;

	inc	rcx
	mov	QWORD PTR [rbx], rcx

; 179  :             c = (*p->input | 0x20);

	movzx	eax, BYTE PTR [rcx]
	or	al, 32					; 00000020H

; 180  :             if (c != 'k'){

	cmp	al, 107					; 0000006bH
	jne	SHORT $LN36@get_decos

; 181  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);
; 182  :                 return;
; 183  :             }else{
; 184  :               p->input++;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rax

; 185  :               c = *p->input;

	movzx	ecx, BYTE PTR [rax]

; 186  :               if (c > '7' || c < '1'){

	lea	eax, DWORD PTR [rcx-49]
	cmp	al, 6
	ja	SHORT $LN14@get_decos

; 188  :                 return;
; 189  :               }
; 190  :               decoflags |= (c & 0x7);

	and	cl, 7
	or	BYTE PTR decoflags, cl

; 191  :               p->input++;

	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]

; 192  :               c = *p->input;
; 193  :               if (c != '}'){

	cmp	BYTE PTR [rax], 125			; 0000007dH
	jne	$LN36@get_decos
$LN15@get_decos:

; 194  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);
; 195  :                 return;
; 196  :               }
; 197  :               p->input++;

	inc	rax
	mov	QWORD PTR [rbx], rax

; 239  :           return;
; 240  :         }
; 241  :       }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN14@get_decos:

; 187  :                 EmitError(WRONG_MASK_REGISTER_NUBER);

	mov	ecx, 16

; 239  :           return;
; 240  :         }
; 241  :       }

	add	rsp, 32					; 00000020H
	pop	rbx

; 226  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);
; 227  :                 return;
; 228  :               }
; 229  :               p->input++;
; 230  :             }
; 231  :             else {
; 232  :               EmitError(TO_MANY_DECORATORS);
; 233  :               return;
; 234  :             }
; 235  :           }
; 236  :         }
; 237  :         else {
; 238  :           EmitError(TO_MANY_DECORATORS);

	jmp	EmitError
$LN7@get_decos:

; 198  :             }
; 199  :           }
; 200  :           /* if first decorator is the mask register */
; 201  :           else if (c == 'k'){

	cmp	cl, 107					; 0000006bH
	jne	$LN16@get_decos

; 202  :           c = *p->input;

	movzx	ecx, BYTE PTR [rax]

; 203  :           if (c > '7' || c < '1'){

	lea	eax, DWORD PTR [rcx-49]
	cmp	al, 6
	ja	SHORT $LN14@get_decos

; 204  :             EmitError(WRONG_MASK_REGISTER_NUBER);
; 205  :             return;
; 206  :           }
; 207  :           decoflags |= (c & 0x7);

	and	cl, 7
	or	BYTE PTR decoflags, cl

; 208  :           p->input++;

	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]

; 209  :           c = *p->input;
; 210  :           if (c != '}'){

	cmp	BYTE PTR [rax], 125			; 0000007dH
	jne	$LN36@get_decos

; 211  :             EmitError(DECORATOR_OR_BRACE_EXPECTED);
; 212  :             return;
; 213  :           }
; 214  :           p->input++;

	inc	rax
	mov	QWORD PTR [rbx], rax

; 215  :           /* check if there is more decorators */
; 216  :           while ( isspace( *p->input )) p->input++;

	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN5@get_decos
	npad	7
$LL4@get_decos:
	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL4@get_decos
$LN5@get_decos:

; 217  :           c = *p->input;

	mov	rax, QWORD PTR [rbx]

; 218  :           if (c == '{'){

	cmp	BYTE PTR [rax], 123			; 0000007bH
	jne	SHORT $LN17@get_decos

; 219  :             p->input++;

	inc	rax
	mov	QWORD PTR [rbx], rax

; 220  :             c = (*p->input | 0x20);

	movzx	ecx, BYTE PTR [rax]
	or	cl, 32					; 00000020H

; 221  :             if (c == 'z'){

	cmp	cl, 122					; 0000007aH
	jne	SHORT $LN16@get_decos

; 222  :               decoflags |= 0x80;

	or	BYTE PTR decoflags, 128			; 00000080H

; 223  :               p->input++;

	inc	QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx]

; 224  :               c = *p->input;
; 225  :               if (c != '}'){

	cmp	BYTE PTR [rax], 125			; 0000007dH
	je	$LN15@get_decos

; 168  :               EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15

; 239  :           return;
; 240  :         }
; 241  :       }

	add	rsp, 32					; 00000020H
	pop	rbx

; 226  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);
; 227  :                 return;
; 228  :               }
; 229  :               p->input++;
; 230  :             }
; 231  :             else {
; 232  :               EmitError(TO_MANY_DECORATORS);
; 233  :               return;
; 234  :             }
; 235  :           }
; 236  :         }
; 237  :         else {
; 238  :           EmitError(TO_MANY_DECORATORS);

	jmp	EmitError
$LN16@get_decos:
	mov	ecx, 17

; 239  :           return;
; 240  :         }
; 241  :       }

	add	rsp, 32					; 00000020H
	pop	rbx

; 226  :                 EmitError(DECORATOR_OR_BRACE_EXPECTED);
; 227  :                 return;
; 228  :               }
; 229  :               p->input++;
; 230  :             }
; 231  :             else {
; 232  :               EmitError(TO_MANY_DECORATORS);
; 233  :               return;
; 234  :             }
; 235  :           }
; 236  :         }
; 237  :         else {
; 238  :           EmitError(TO_MANY_DECORATORS);

	jmp	EmitError
$LN17@get_decos:

; 239  :           return;
; 240  :         }
; 241  :       }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
get_decos ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
p$ = 48
get_broads PROC

; 126  : void get_broads(struct line_status *p) {

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H

; 127  : 	/************************************************/
; 128  : 	if (!evex)

	cmp	BYTE PTR evex, 0
	mov	rbx, rcx
	jne	SHORT $LN2@get_broads

; 129  : 		EmitError(UNAUTHORISED_USE_OF_EVEX_ENCODING);

	mov	ecx, 23
	call	EmitError
$LN2@get_broads:

; 130  : 
; 131  : 	if (_memicmp(p->input, "1to2", 4) == 0) {

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:$SG10899
	mov	r8d, 4
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN3@get_broads

; 132  : 		broadflags = 0x10;

	mov	BYTE PTR broadflags, 16

; 133  : 		p->input += 4;

	add	QWORD PTR [rbx], 4

; 134  : 	}

	jmp	SHORT $LN10@get_broads
$LN3@get_broads:

; 135  : 	else if (_memicmp(p->input, "1to4", 4) == 0){

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:$SG10902
	mov	r8d, 4
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN5@get_broads

; 136  :       broadflags = 0x20;

	mov	BYTE PTR broadflags, 32			; 00000020H

; 137  :       p->input += 4;

	add	QWORD PTR [rbx], 4

; 138  :     }

	jmp	SHORT $LN10@get_broads
$LN5@get_broads:

; 139  :     else if (_memicmp(p->input, "1to8", 4) == 0){

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:$SG10905
	mov	r8d, 4
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN7@get_broads

; 140  :       broadflags = 0x30;

	mov	BYTE PTR broadflags, 48			; 00000030H

; 141  :       p->input += 4;

	add	QWORD PTR [rbx], 4

; 142  :     }

	jmp	SHORT $LN10@get_broads
$LN7@get_broads:

; 143  :     else if (_memicmp(p->input, "1to16", 5) == 0){

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:$SG10908
	mov	r8d, 5
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN9@get_broads

; 144  :       broadflags = 0x40;

	mov	BYTE PTR broadflags, 64			; 00000040H

; 145  :       p->input += 5;

	add	QWORD PTR [rbx], 5

; 146  :     }

	jmp	SHORT $LN10@get_broads
$LN9@get_broads:

; 147  :     else
; 148  :       EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN10@get_broads:

; 149  :     if (*p->input++ != '}')

	mov	rax, QWORD PTR [rbx]
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rbx], rax
	cmp	cl, 125					; 0000007dH
	je	SHORT $LN11@get_broads

; 150  :       EmitError(DECORATOR_OR_BRACE_EXPECTED);

	mov	ecx, 15

; 151  : 
; 152  :   }

	add	rsp, 32					; 00000020H
	pop	rbx

; 150  :       EmitError(DECORATOR_OR_BRACE_EXPECTED);

	jmp	EmitError
$LN11@get_broads:

; 151  : 
; 152  :   }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
get_broads ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
;	COMDAT IsMultiLine
_TEXT	SEGMENT
tokenarray$ = 48
IsMultiLine PROC					; COMDAT

; 98   : {

	sub	rsp, 40					; 00000028H

; 99   :     struct asym *sym;
; 100  :     int i;
; 101  : 
; 102  :     if ( tokenarray[1].token == T_DIRECTIVE && tokenarray[1].tokval == T_EQU )

	movzx	edx, BYTE PTR [rcx+32]
	cmp	dl, 3
	jne	SHORT $LN2@IsMultiLin
	cmp	DWORD PTR [rcx+48], 443			; 000001bbH
	je	SHORT $LN8@IsMultiLin
$LN2@IsMultiLin:

; 103  :         return( FALSE );
; 104  :     i = ( tokenarray[1].token == T_COLON ? 2 : 0 );

	xor	eax, eax
	mov	r8d, 2
	cmp	dl, 58					; 0000003aH
	cmove	eax, r8d

; 105  :     /* don't concat macros */
; 106  :     if ( tokenarray[i].token == T_ID ) {

	cdqe
	shl	rax, 5
	lea	rdx, QWORD PTR [rax+rcx]
	movzx	eax, BYTE PTR [rax+rcx]
	cmp	al, 8
	jne	SHORT $LN3@IsMultiLin

; 107  :         sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rdx+8]
	call	SymFind

; 108  :         if ( sym && ( sym->state == SYM_MACRO )
; 109  : #if VARARGML
; 110  :             && sym->mac_multiline == FALSE  /* v2.11: added */

	test	rax, rax
	je	SHORT $LN6@IsMultiLin
	cmp	DWORD PTR [rax+32], 9
	jne	SHORT $LN6@IsMultiLin
	test	BYTE PTR [rax+44], 8
	jne	SHORT $LN6@IsMultiLin
$LN8@IsMultiLin:

; 115  :                ( tokenarray[i].token == T_DIRECTIVE &&
; 116  :                ( tokenarray[i].tokval == T_ECHO ||
; 117  :                 tokenarray[i].tokval == T_INCLUDE ||
; 118  :                 tokenarray[i].tokval == T_FORC ||
; 119  :                 tokenarray[i].tokval == T_IRPC ) ) ) {
; 120  :         return( FALSE );

	xor	al, al

; 123  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@IsMultiLin:

; 111  : #endif
; 112  :            )
; 113  :             return( FALSE );
; 114  :     } else if ( tokenarray[i].token == T_INSTRUCTION ||

	cmp	al, 1
	je	SHORT $LN8@IsMultiLin
	cmp	al, 3
	jne	SHORT $LN6@IsMultiLin
	mov	eax, DWORD PTR [rdx+16]
	add	eax, -386				; fffffe7eH
	cmp	eax, 55					; 00000037H
	ja	SHORT $LN6@IsMultiLin
	mov	rcx, 36028797018966021			; 0080000000000805H
	bt	rcx, rax
	jb	SHORT $LN8@IsMultiLin
$LN6@IsMultiLin:

; 121  :     }
; 122  :     return( TRUE );

	mov	al, 1

; 123  : }

	add	rsp, 40					; 00000028H
	ret	0
IsMultiLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
p$ = 32
line$ = 112
start$ = 120
tokenarray$ = 128
flags$ = 136
Tokenize PROC

; 1089 : {

$LN131:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	mov	DWORD PTR [rsp+16], edx
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 64					; 00000040H

; 1090 :     int                         rc;
; 1091 :     struct line_status          p;
; 1092 : 
; 1093 :     p.input = line;

	mov	QWORD PTR p$[rbp-64], rcx
	mov	r12d, r9d

; 1094 :     p.start = line;
; 1095 :     p.index = start;
; 1096 :     //p.last_token = T_FINAL; /* v2.11: last_token is obsolete */
; 1097 :     p.flags = flags;

	mov	BYTE PTR p$[rbp-36], r12b
	mov	r13, r8
	mov	QWORD PTR p$[rbp-48], rcx
	mov	ebx, edx
	mov	DWORD PTR p$[rbp-40], edx
	mov	r15, rcx

; 1098 :     p.flags2 = 0;

	mov	WORD PTR p$[rbp-35], 0
	mov	rdi, rcx
	mov	r14d, edx

; 1099 :     p.flags3 = 0;
; 1100 :     if ( p.index == 0 ) {

	test	edx, edx
	jne	SHORT $LN11@Tokenize

; 1101 : #ifdef DEBUG_OUT
; 1102 :         cnttok0++;
; 1103 : #endif
; 1104 :         /* v2.06: these flags are now initialized on a higher level */
; 1105 :         //ModuleInfo.line_flags = 0;
; 1106 :         p.output = token_stringbuf;
; 1107 :         if( ModuleInfo.inside_comment ) {

	movzx	eax, BYTE PTR ModuleInfo+407
	mov	rsi, QWORD PTR token_stringbuf
	mov	QWORD PTR p$[rbp-56], rsi
	test	al, al
	je	SHORT $LL2@Tokenize

; 1108 :             DebugMsg1(("COMMENT active, delim is >%c<, line is >%s<\n", ModuleInfo.inside_comment, line));
; 1109 :             if( strchr( line, ModuleInfo.inside_comment ) != NULL ) {

	movzx	edx, al
	call	strchr
	test	rax, rax
	je	$skipline$132

; 1110 :                 DebugMsg1(("COMMENT mode exited\n"));
; 1111 :                 ModuleInfo.inside_comment = NULLC;

	mov	BYTE PTR ModuleInfo+407, r14b

; 1112 :             }
; 1113 :             goto skipline;

	jmp	$skipline$132
$LN11@Tokenize:

; 1114 :         }
; 1115 :         /* v2.08: expansion operator % at pos 0 is handled differently.
; 1116 :          */
; 1117 :         //while( isspace( *p.input )) p.input++;
; 1118 :         //if ( *p.input == '%' ) {
; 1119 :         //    *p.input++ = ' ';
; 1120 :         //    expansion = TRUE;
; 1121 :         //}
; 1122 :     } else {
; 1123 : #ifdef DEBUG_OUT
; 1124 :         cnttok1++;
; 1125 : #endif
; 1126 :         p.output = StringBufferEnd;

	mov	rsi, QWORD PTR ModuleInfo+488
$LN128@Tokenize:
	mov	QWORD PTR p$[rbp-56], rsi
	npad	5
$LL2@Tokenize:

; 1127 :     }
; 1128 : 
; 1129 :     for( ;; ) {
; 1130 : 
; 1131 :         while( isspace( *p.input ) ) p.input++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN6@Tokenize
	npad	4
$LL5@Tokenize:
	movsx	ecx, BYTE PTR [rdi+1]
	inc	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL5@Tokenize
	mov	QWORD PTR p$[rbp-64], rdi
$LN6@Tokenize:

; 1132 : 
; 1133 :         if ( *p.input == ';' && flags == TOK_DEFAULT ) {

	cmp	BYTE PTR [rdi], 59			; 0000003bH
	jne	SHORT $LN15@Tokenize
	test	r12d, r12d
	jne	SHORT $LN15@Tokenize

; 1134 :             while ( p.input > line && isspace( *(p.input-1) ) ) p.input--; /* skip */

	cmp	rdi, r15
	jbe	SHORT $LN8@Tokenize
$LL7@Tokenize:
	movsx	ecx, BYTE PTR [rdi-1]
	lea	rbx, QWORD PTR [rdi-1]
	call	isspace
	test	eax, eax
	je	SHORT $LN119@Tokenize
	mov	rdi, rbx
	cmp	rbx, r15
	ja	SHORT $LL7@Tokenize
$LN119@Tokenize:
	mov	ebx, DWORD PTR start$[rbp-64]
	mov	QWORD PTR p$[rbp-64], rdi
$LN8@Tokenize:

; 1135 :             strcpy( commentbuffer, p.input );

	mov	rdx, QWORD PTR commentbuffer
	mov	rcx, rdi
	npad	3
$LL36@Tokenize:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx], al
	lea	rdx, QWORD PTR [rdx+1]
	test	al, al
	jne	SHORT $LL36@Tokenize

; 1136 :             ModuleInfo.CurrComment = commentbuffer;

	mov	rax, QWORD PTR commentbuffer
	mov	QWORD PTR ModuleInfo+472, rax

; 1137 :             *p.input = NULLC;

	mov	BYTE PTR [rdi], 0
$LN15@Tokenize:

; 1138 :         }
; 1139 : 
; 1140 :         tokenarray[p.index].tokpos = p.input;

	mov	ecx, r14d
	shl	rcx, 5
	add	rcx, r13
	mov	QWORD PTR [rcx+24], rdi

; 1141 :         if( *p.input == NULLC ) {

	cmp	BYTE PTR [rdi], 0
	jne	$LN16@Tokenize

; 1142 :             /* if a comma is last token, concat lines ... with some exceptions
; 1143 :              * v2.05: moved from PreprocessLine(). Moved because the
; 1144 :              * concatenation may be triggered by a comma AFTER expansion.
; 1145 :              */
; 1146 :             if ( p.index > 1 &&
; 1147 :                 tokenarray[p.index-1].token == T_COMMA
; 1148 : #if FASTPASS
; 1149 :                 && ( Parse_Pass == PASS_1 || UseSavedState == FALSE ) /* is it an already preprocessed line? */
; 1150 : #endif
; 1151 :                 && start == 0 ) {

	cmp	r14d, 1
	jbe	$LN49@Tokenize
	lea	ecx, DWORD PTR [r14-1]
	shl	rcx, 5
	cmp	BYTE PTR [rcx+r13], 44			; 0000002cH
	jne	$LN49@Tokenize
	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN18@Tokenize
	cmp	BYTE PTR UseSavedState, 0
	jne	$LN49@Tokenize
$LN18@Tokenize:
	test	ebx, ebx
	jne	$LN49@Tokenize

; 1152 :                 DebugMsg1(("Tokenize: calling IsMultiLine()\n" ));
; 1153 :                 if ( IsMultiLine( tokenarray ) ) {

	mov	rcx, r13
	call	IsMultiLine
	test	al, al
	je	$LN49@Tokenize

; 1154 :                     char *ptr = GetAlignedPointer( p.output, strlen( p.output ) );

	or	rbx, -1
	npad	8
$LL91@Tokenize:
	inc	rbx
	cmp	BYTE PTR [rsi+rbx], 0
	jne	SHORT $LL91@Tokenize
	add	rbx, 8
	and	rbx, -8
	add	rbx, rsi

; 1155 :                     DebugMsg1(("Tokenize: IsMultiLine(%s)=TRUE\n", line ));
; 1156 :                     if ( GetTextLine( ptr ) ) {

	mov	rcx, rbx
	call	GetTextLine
	test	rax, rax
	je	$LN49@Tokenize

; 1157 :                         while ( isspace( *ptr ) ) ptr++;

	movsx	ecx, BYTE PTR [rbx]
	call	isspace
	test	eax, eax
	je	SHORT $LN10@Tokenize
$LL9@Tokenize:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL9@Tokenize
$LN10@Tokenize:

; 1158 :                         if ( *ptr ) {

	cmp	BYTE PTR [rbx], 0
	je	$LN49@Tokenize

; 1159 :                             strcpy( p.input, ptr );

	mov	rcx, rdi
	sub	rcx, rbx
$LL37@Tokenize:
	movzx	eax, BYTE PTR [rbx]
	mov	BYTE PTR [rcx+rbx], al
	lea	rbx, QWORD PTR [rbx+1]
	test	al, al
	jne	SHORT $LL37@Tokenize

; 1160 :                             if ( strlen( p.start ) >= MAX_LINE_LEN ) {

	mov	rcx, QWORD PTR p$[rbp-48]
	or	rax, -1
$LL90@Tokenize:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL90@Tokenize
	cmp	rax, 600				; 00000258H
	jae	$LN45@Tokenize

; 1164 :                             }
; 1165 :                             DebugMsg1(("Tokenize: line concatenation, line=%s\n", line ));
; 1166 :                             continue;

	mov	ebx, DWORD PTR start$[rbp-64]
	jmp	$LL2@Tokenize
$LN16@Tokenize:

; 1167 :                         }
; 1168 :                     }
; 1169 :                 }
; 1170 :             }
; 1171 :             break;
; 1172 :         }
; 1173 :         tokenarray[p.index].string_ptr = p.output;
; 1174 :         rc = GetToken( &tokenarray[p.index], &p );

	lea	rdx, QWORD PTR p$[rbp-64]
	mov	QWORD PTR [rcx+8], rsi
	call	GetToken

; 1175 :         if ( rc == EMPTY )

	cmp	eax, -2
	jne	SHORT $LN110@Tokenize

; 1114 :         }
; 1115 :         /* v2.08: expansion operator % at pos 0 is handled differently.
; 1116 :          */
; 1117 :         //while( isspace( *p.input )) p.input++;
; 1118 :         //if ( *p.input == '%' ) {
; 1119 :         //    *p.input++ = ' ';
; 1120 :         //    expansion = TRUE;
; 1121 :         //}
; 1122 :     } else {
; 1123 : #ifdef DEBUG_OUT
; 1124 :         cnttok1++;
; 1125 : #endif
; 1126 :         p.output = StringBufferEnd;

	mov	r14d, DWORD PTR p$[rbp-40]
	mov	rsi, QWORD PTR p$[rbp-56]
	mov	rdi, QWORD PTR p$[rbp-64]
	jmp	$LL2@Tokenize
$LN110@Tokenize:

; 1176 :             continue;
; 1177 :         if ( rc == ERROR ) {

	cmp	eax, -1
	je	$LN46@Tokenize

; 1179 :             break;
; 1180 :         }
; 1181 :         /* v2.04: this has been moved here from condasm.c to
; 1182 :          * avoid problems with (conditional) listings. It also
; 1183 :          * avoids having to search for the first token twice.
; 1184 :          * Note: a conditional assembly directive within an
; 1185 :          *    inactive block and preceded by a label isn't detected!
; 1186 :          *    This is an exact copy of the Masm behavior, although
; 1187 :          *    it probably is just a bug!
; 1188 :          */
; 1189 :         if ( !(flags & TOK_RESCAN) ) {

	mov	r14d, DWORD PTR p$[rbp-40]
	test	r12b, 1
	jne	SHORT $LN33@Tokenize

; 1190 :             if ( p.index == 0 || ( p.index == 2 && ( tokenarray[1].token == T_COLON || tokenarray[1].token == T_DBL_COLON) ) ) {

	test	r14d, r14d
	je	SHORT $LN28@Tokenize
	cmp	r14d, 2
	jne	SHORT $LN33@Tokenize
	movzx	eax, BYTE PTR [r13+32]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN28@Tokenize
	cmp	al, 13
	jne	SHORT $LN33@Tokenize
$LN28@Tokenize:

; 1191 :                 if ( tokenarray[p.index].token == T_DIRECTIVE &&

	mov	rax, r14
	shl	rax, 5
	cmp	BYTE PTR [rax+r13], 3
	jne	SHORT $LN29@Tokenize
	cmp	BYTE PTR [rax+r13+1], 0
	jne	SHORT $LN29@Tokenize

; 1192 :                     tokenarray[p.index].bytval == DRT_CONDDIR ) {
; 1193 :                     if ( tokenarray[p.index].tokval == T_COMMENT ) {

	mov	ecx, DWORD PTR [rax+r13+16]
	cmp	ecx, 358				; 00000166H
	je	SHORT $LN47@Tokenize

; 1197 :                     }
; 1198 :                     conditional_assembly_prepare( tokenarray[p.index].tokval );

	call	conditional_assembly_prepare

; 1199 :                     if ( CurrIfState != BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, 0
	je	SHORT $LN33@Tokenize

; 1200 :                         p.index++;

	inc	r14d
	jmp	SHORT $LN129@Tokenize
$LN29@Tokenize:

; 1201 :                         break; /* p.index is 1 or 3 */
; 1202 :                     }
; 1203 :                 } else if( CurrIfState != BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, 0
	jne	SHORT $LN129@Tokenize
$LN33@Tokenize:

; 1204 :                     /* further processing skipped. p.index is 0 */
; 1205 :                     break;
; 1206 :                 }
; 1207 :             }
; 1208 :         }
; 1209 :         p.index++;

	inc	r14d
	mov	DWORD PTR p$[rbp-40], r14d

; 1210 :         if( p.index >= MAX_TOKEN ) {

	cmp	r14d, 150				; 00000096H
	jae	SHORT $LN50@Tokenize

; 1214 :             goto skipline;
; 1215 :         }
; 1216 : 
; 1217 : #if TOKSTRALIGN
; 1218 :         p.output = GetAlignedPointer( token_stringbuf, p.output - token_stringbuf );

	mov	rsi, QWORD PTR p$[rbp-56]
	sub	rsi, QWORD PTR token_stringbuf

; 1219 : #endif
; 1220 : 
; 1221 :     }

	mov	rdi, QWORD PTR p$[rbp-64]
	add	rsi, 8
	and	rsi, -8
	add	rsi, QWORD PTR token_stringbuf
	jmp	$LN128@Tokenize
$LN45@Tokenize:

; 1161 :                                 EmitError( LINE_TOO_LONG );

	mov	ecx, 62					; 0000003eH
	call	EmitError

; 1162 :                                 p.index = start;

	xor	r14d, r14d

; 1163 :                                 break;

	jmp	SHORT $LN49@Tokenize
$LN47@Tokenize:

; 1194 :                         DebugMsg1(("tokenize: COMMENT starting, delim is >%c<\n", ModuleInfo.inside_comment));
; 1195 :                         StartComment( p.input );

	mov	rcx, QWORD PTR p$[rbp-64]
	call	StartComment

; 1196 :                         break; /* p.index is 0 or 2 */

	jmp	SHORT $LN129@Tokenize
$LN50@Tokenize:

; 1211 :             DebugMsg1(("tokenize: token index %u >= MAX_TOKEN (=%u), line=>%s<\n", p.index, MAX_TOKEN, line ));
; 1212 :             EmitError( TOO_MANY_TOKENS );

	mov	ecx, 63					; 0000003fH
	call	EmitError

; 1213 :             p.index = start;

	mov	r14d, ebx
	jmp	SHORT $skipline$132
$LN46@Tokenize:

; 1178 :             p.index = start; /* skip this line */

	mov	r14d, ebx
$LN129@Tokenize:
	mov	rsi, QWORD PTR p$[rbp-56]
$LN49@Tokenize:

; 1222 : #if TOKSTRALIGN
; 1223 :     p.output = GetAlignedPointer( token_stringbuf, p.output - token_stringbuf );
; 1224 : #endif
; 1225 :     StringBufferEnd = p.output;

	sub	rsi, QWORD PTR token_stringbuf
	add	rsi, 8
	and	rsi, -8
	add	rsi, QWORD PTR token_stringbuf
	mov	QWORD PTR ModuleInfo+488, rsi
$skipline$132:

; 1226 : skipline:
; 1227 :     tokenarray[p.index].token  = T_FINAL;
; 1228 :     tokenarray[p.index].bytval = p.flags3;

	movzx	ecx, BYTE PTR p$[rbp-34]

; 1229 :     tokenarray[p.index].string_ptr = "";
; 1230 :     return( p.index );
; 1231 : }

	lea	r11, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [r11+48]
	lea	rax, OFFSET FLAT:$SG11284
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	edx, r14d
	shl	rdx, 5
	mov	BYTE PTR [rdx+r13], 0
	mov	BYTE PTR [rdx+r13+1], cl
	mov	QWORD PTR [rdx+r13+8], rax
	mov	eax, r14d
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
Tokenize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tokenize.c
_TEXT	SEGMENT
token$ = 48
p$ = 56
GetToken PROC

; 1041 : {

$LN32:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1042 :     if( isdigit( *p->input ) ) {

	mov	rax, QWORD PTR [rdx]
	mov	rdi, rcx
	mov	rbx, rdx
	movsx	ecx, BYTE PTR [rax]
	call	isdigit
	test	eax, eax
	je	SHORT $LN2@GetToken

; 1043 :         return( get_number( token, p ) );

	mov	rdx, rbx
	mov	rcx, rdi

; 1062 : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1043 :         return( get_number( token, p ) );

	jmp	get_number
$LN2@GetToken:

; 1044 :     } else if( is_valid_id_start( *p->input ) ) {

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rsp+48], rsi
	movsx	ecx, BYTE PTR [rax]
	call	isalpha
	test	eax, eax
	jne	$LN6@GetToken
	mov	rdx, QWORD PTR [rbx]
	mov	rsi, 576460752706076673			; 0800000018000001H
	movzx	ecx, BYTE PTR [rdx]
	lea	eax, DWORD PTR [rcx-36]
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN25@GetToken
	movsx	rax, al
	bt	rsi, rax
	jb	$LN6@GetToken
$LN25@GetToken:

; 1046 :     } else if( *p->input == '.' &&
; 1047 : #if DOTNAMEX /* allow dots within identifiers */
; 1048 :               ( is_valid_id_char(*(p->input+1)) || *(p->input+1) == '.' ) &&
; 1049 : #else
; 1050 :               is_valid_id_char(*(p->input+1)) &&

	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN7@GetToken
	movsx	ecx, BYTE PTR [rdx+1]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN9@GetToken
	mov	rax, QWORD PTR [rbx]
	movzx	ecx, BYTE PTR [rax+1]
	sub	cl, 36					; 00000024H
	cmp	cl, 59					; 0000003bH
	ja	SHORT $LN7@GetToken
	movsx	rax, cl
	bt	rsi, rax
	jae	SHORT $LN7@GetToken
$LN9@GetToken:
	cmp	DWORD PTR [rbx+24], 0
	je	$LN6@GetToken
	movzx	ecx, BYTE PTR [rdi-32]
	cmp	cl, 41					; 00000029H
	ja	SHORT $LN28@GetToken
	mov	rdx, 2199023255812			; 0000020000000104H
	bt	rdx, rcx
	jb	SHORT $LN7@GetToken
$LN28@GetToken:
	cmp	cl, 93					; 0000005dH

; 1051 : #endif
; 1052 :               /* v2.11: member last_token has been removed */
; 1053 :               //( p->last_token != T_REG &&  p->last_token != T_CL_BRACKET && p->last_token != T_CL_SQ_BRACKET && p->last_token != T_ID ) ) {
; 1054 :               ( p->index == 0 || ( token[-1].token != T_REG && token[-1].token != T_CL_BRACKET && token[-1].token != T_CL_SQ_BRACKET && token[-1].token != T_ID ) ) ) {
; 1055 :         return( get_id( token, p ) );

	jne	$LN6@GetToken
$LN7@GetToken:

; 1056 : #if BACKQUOTES
; 1057 :     } else if( *p->input == '`' && Options.strict_masm_compat == FALSE ) {

	mov	rax, QWORD PTR [rbx]
	cmp	BYTE PTR [rax], 96			; 00000060H
	jne	$LN11@GetToken
	cmp	BYTE PTR Options+127, 0
	jne	$LN11@GetToken

; 1058 :         return( get_id_in_backquotes( token, p ) );

	mov	rdx, QWORD PTR [rbx+8]
	xor	r8d, r8d
	mov	DWORD PTR [rdi+16], r8d
	mov	BYTE PTR [rdi], 8
	inc	QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx]
	movzx	eax, BYTE PTR [rcx]
	cmp	al, 96					; 00000060H
	je	SHORT $LN15@GetToken
	npad	4
$LL14@GetToken:
	test	al, al
	je	SHORT $LN21@GetToken
	cmp	al, 59					; 0000003bH
	je	SHORT $LN21@GetToken
	mov	BYTE PTR [rdx], al
	inc	rdx
	inc	QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx]
	movzx	eax, BYTE PTR [rcx]
	cmp	al, 96					; 00000060H
	jne	SHORT $LL14@GetToken
$LN15@GetToken:
	mov	rsi, QWORD PTR [rsp+48]
	inc	rcx
	mov	QWORD PTR [rbx], rcx
	mov	eax, r8d
	lea	rcx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rdx], r8b
	mov	QWORD PTR [rbx+8], rcx

; 1062 : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN21@GetToken:

; 1058 :         return( get_id_in_backquotes( token, p ) );

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, 98					; 00000062H
	mov	BYTE PTR [rax], r8b
	mov	rdx, QWORD PTR [rbx+8]
	call	EmitErr
	mov	rsi, QWORD PTR [rsp+48]
	or	r8d, -1
	mov	eax, r8d

; 1062 : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN11@GetToken:

; 1059 : #endif
; 1060 :     }
; 1061 :     return( get_special_symbol( token, p ) );

	mov	rdx, rbx
	mov	rcx, rdi
	mov	rsi, QWORD PTR [rsp+48]

; 1062 : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1059 : #endif
; 1060 :     }
; 1061 :     return( get_special_symbol( token, p ) );

	jmp	get_special_symbol
$LN6@GetToken:

; 1045 :         return( get_id( token, p ) );

	mov	rdx, rbx
	mov	rcx, rdi
	mov	rsi, QWORD PTR [rsp+48]

; 1062 : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1045 :         return( get_id( token, p ) );

	jmp	get_id
GetToken ENDP
_TEXT	ENDS
END
